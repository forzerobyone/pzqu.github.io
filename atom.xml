<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pzqu 的自言自语</title>
  
  <subtitle>应用开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.qupzhi.com/"/>
  <updated>2019-01-10T03:34:41.758Z</updated>
  <id>http://www.qupzhi.com/</id>
  
  <author>
    <name>pzqu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mariadb 内存占用优化</title>
    <link href="http://www.qupzhi.com/mariadb-better/"/>
    <id>http://www.qupzhi.com/mariadb-better/</id>
    <published>2019-01-09T14:25:00.000Z</published>
    <updated>2019-01-10T03:34:41.758Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 10 2019 11:36:57 GMT+0800 (China Standard Time) --><p>摘要：我们在使用mariadb的时候发现有时候不能启动起来，在使用过程中mariadb占用的内存很大，在这里学习下mariadb与内存相关的配置项，对mariadb进行调优。</p><a id="more"></a><h1 id="查询最高内存占用"><a href="#查询最高内存占用" class="headerlink" title="查询最高内存占用"></a>查询最高内存占用</h1><p>使用以下命令可以知道mysql的配置使用多少 RAM<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT ( @@key_buffer_size</span><br><span class="line">+ @@query_cache_size</span><br><span class="line">+ @@innodb_buffer_pool_size</span><br><span class="line">+ @@innodb_additional_mem_pool_size</span><br><span class="line">+ @@innodb_log_buffer_size</span><br><span class="line">+ @@max_connections * ( @@read_buffer_size</span><br><span class="line">+ @@read_rnd_buffer_size</span><br><span class="line">+ @@sort_buffer_size</span><br><span class="line">+ @@join_buffer_size</span><br><span class="line">+ @@binlog_cache_size</span><br><span class="line">+ @@thread_stack</span><br><span class="line">+ @@tmp_table_size</span><br><span class="line">)</span><br><span class="line">) / (1024 * 1024 * 1024) AS MAX_MEMORY_GB;</span><br></pre></td></tr></table></figure><p></p><p>可以使用<a href="http://www.mysqlcalculator.com/" target="_blank" rel="noopener">mysql计算器</a>来计算内存使用</p><p>下面是理论，可以直接到<a href="#mariadb 推荐配置">推荐配置</a></p><h1 id="如何调整配置"><a href="#如何调整配置" class="headerlink" title="如何调整配置"></a>如何调整配置</h1><h2 id="key-buffer-size（MyISAM索引用）"><a href="#key-buffer-size（MyISAM索引用）" class="headerlink" title="key_buffer_size（MyISAM索引用）"></a>key_buffer_size（MyISAM索引用）</h2><blockquote><p>指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。为了最小化磁盘的 I/O ， MyISAM 存储引擎的表使用键高速缓存来缓存索引，这个键高速缓存的大小则通过 key-buffer-size 参数来设置。如果应用系统中使用的表以 MyISAM 存储引擎为主，则应该适当增加该参数的值，以便尽可能的缓存索引，提高访问的速度。</p></blockquote><h3 id="怎么设"><a href="#怎么设" class="headerlink" title="怎么设"></a>怎么设</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'key_read%'</span>;</span><br><span class="line"></span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Key_read_requests | 27813678764 |</span><br><span class="line">| Key_reads | 6798830 |</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。</li><li>比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'%created_tmp_disk_tables%'</span>;</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。</li><li>对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M）</li></ul><p><strong>另一个参考如下</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'key_blocks_u%'</span>;</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Key_blocks_unused | 0 |</span><br><span class="line">| Key_blocks_used | 413543 |</span><br><span class="line">+------------------------+-------------+</span><br></pre></td></tr></table></figure><p></p><p>Key_blocks_unused表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置：</p><ul><li>可以根据此工式来动态的调整<code>Key_blocks_used / (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><ul><li>查询存储引擎</li></ul><h2 id="innodb-buffer-pool-size-（innodb索引用）"><a href="#innodb-buffer-pool-size-（innodb索引用）" class="headerlink" title="innodb_buffer_pool_size （innodb索引用）"></a>innodb_buffer_pool_size （innodb索引用）</h2><blockquote><p>这个参数和MyISAM的<code>key_buffer_size</code>有相似之处，但也是有差别的。这个参数主要缓存innodb表的索引，数据，插入数据时的缓冲。为Innodb加速优化首要参数。<br>该参数分配内存的原则：这个参数默认分配只有8M，可以说是非常小的一个值。</p><ul><li>如果是专用的DB服务器，且以InnoDB引擎为主的场景，通常可设置物理内存的50%，这个参数不能动态更改，所以分配需多考虑。分配过大，会使Swap占用过多，致使Mysql的查询特慢。</li><li>如果是非专用DB服务器，可以先尝试设置成内存的1/4，如果有问题再调整</li></ul></blockquote><h2 id="query-cache-size（查询缓存）"><a href="#query-cache-size（查询缓存）" class="headerlink" title="query_cache_size（查询缓存）"></a>query_cache_size（查询缓存）</h2><blockquote><p>缓存机制简单的说就是缓存sql文本及查询结果，如果运行相同的sql，服务器直接从缓存中取到结果，而不需要再去解析和执行sql。如果表更改了，那么使用这个表的所有缓冲查询将不再有效，查询缓存值的相关条目被清空。更改指的是表中任何数据或是结构的改变，包括INSERT、UPDATE、DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE等，也包括那些映射到改变了的表的使用MERGE表的查询。显然，这对于频繁更新的表，查询缓存是不适合的，而对于一些不常改变数据且有大量相同sql查询的表，查询缓存会节约很大的性能。</p><ul><li>注意：如果你查询的表更新比较频繁，而且很少有相同的查询，最好不要使用查询缓存。因为这样会消耗很大的系统性能还没有任何的效果</li></ul></blockquote><h3 id="要不要打开？"><a href="#要不要打开？" class="headerlink" title="要不要打开？"></a>要不要打开？</h3><p>先设置成这样跑一段时间<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_size=128M </span><br><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure><p></p><p>看看命中结果来进行进一步的判断<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'%Qcache%'</span>;</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Qcache_free_blocks      | 669       |</span><br><span class="line">| Qcache_free_memory      | 132519160 |</span><br><span class="line">| Qcache_hits             | 1158      |</span><br><span class="line">| Qcache_inserts          | 284824    |</span><br><span class="line">| Qcache_lowmem_prunes    | 2741      |</span><br><span class="line">| Qcache_not_cached       | 1755767   |</span><br><span class="line">| Qcache_queries_in_cache | 579       |</span><br><span class="line">| Qcache_total_blocks     | 1853      |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>Qcache_free_blocks:表示查询缓存中目前还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能在一定的时间进行整理。<br>Qcache_free_memory:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。<br>Qcache_hits:表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。<br>Qcache_inserts: 表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数，次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。<br>Qcache_lowmem_prunes:该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。<br>Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。<br>Qcache_queries_in_cache:当前缓存中缓存的查询数量。<br>Qcache_total_blocks:当前缓存的block数量。</p></blockquote><ul><li><p>我们可以看到现网命中1158，未缓存的有1755767次，说明我们这个系统命中的太少了，表变动比较多，不什么开启这个功能</p><h3 id="涉及参数"><a href="#涉及参数" class="headerlink" title="涉及参数"></a>涉及参数</h3></li><li><p>query_cache_limit：允许 Cache 的单条 Query 结果集的最大容量，默认是1MB，超过此参数设置的 Query 结果集将不会被 Cache</p></li><li>query_cache_min_res_unit：设置 Query Cache 中每次分配内存的最小空间大小，也就是每个 Query 的 Cache 最小占用的内存空间大小</li><li>query_cache_size：设置 Query Cache 所使用的内存大小，默认值为0，大小必须是1024的整数倍，如果不是整数倍，MySQL 会自动调整降低最小量以达到1024的倍数</li><li>query_cache_type：控制 Query Cache 功能的开关，可以设置为0(OFF),1(ON)和2(DEMAND)三种，意义分别如下：<br>0(OFF)：关闭 Query Cache 功能，任何情况下都不会使用 Query Cache<br>1(ON)：开启 Query Cache 功能，但是当 SELECT 语句中使用的 SQL_NO_CACHE 提示后，将不使用Query Cache<br>2(DEMAND)：开启 Query Cache 功能，但是只有当 SELECT 语句中使用了 SQL_CACHE 提示后，才使用 Query Cache</li><li>query_cache_wlock_invalidate：控制当有写锁定发生在表上的时刻是否先失效该表相关的 Query Cache，如果设置为 1(TRUE)，则在写锁定的同时将失效该表相关的所有 Query Cache，如果设置为0(FALSE)则在锁定时刻仍然允许读取该表相关的 Query Cache。</li></ul><h2 id="innodb-additional-mem-pool-size（InnoDB内部目录大小）"><a href="#innodb-additional-mem-pool-size（InnoDB内部目录大小）" class="headerlink" title="innodb_additional_mem_pool_size（InnoDB内部目录大小）"></a>innodb_additional_mem_pool_size（InnoDB内部目录大小）</h2><p>InnoDB 字典信息缓存主要用来存放 InnoDB 存储引擎的字典信息以及一些 internal 的共享数据结构信息，也就是存放Innodb的内部目录，所以其大小也与系统中所使用的 InnoDB 存储引擎表的数量有较大关系。</p><p>这个值不用分配太大，通常设置16Ｍ够用了，默认8M，如果设置的内存大小不够，InnoDB 会自动申请更多的内存，并在 MySQL 的 Error Log 中记录警告信息。</p><h2 id="innodb-log-buffer-size-（日志缓冲）"><a href="#innodb-log-buffer-size-（日志缓冲）" class="headerlink" title="innodb_log_buffer_size （日志缓冲）"></a>innodb_log_buffer_size （日志缓冲）</h2><p>表示InnoDB写入到磁盘上的日志文件时使用的缓冲区的字节数，默认值为16M。一个大的日志缓冲区允许大量的事务在提交之前不用写日志到磁盘，所以如果有更新，插入或删除许多行的事务，则使日志缓冲区更大一些可以节省磁盘IO</p><p>通常最大设为64M足够</p><h2 id="max-connections-最大并发连接"><a href="#max-connections-最大并发连接" class="headerlink" title="max_connections (最大并发连接)"></a>max_connections (最大并发连接)</h2><p>MySQL的max_connections参数用来设置最大连接（用户）数。每个连接MySQL的用户均算作一个连接，max_connections的默认值为100。</p><ul><li>这个参数实际起作用的最大值（实际最大可连接数）为16384，即该参数最大值不能超过16384，即使超过也以16384为准；</li><li>增加max_connections参数的值，不会占用太多系统资源。系统资源（CPU、内存）的占用主要取决于查询的密度、效率等；</li><li>该参数设置过小的最明显特征是出现”Too many connections”错误</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'%max_connect%'</span>;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| extra_max_connections | 1     |</span><br><span class="line">| max_connect_errors    | 100   |</span><br><span class="line">| max_connections       | 2048  |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like <span class="string">'Threads%'</span>;</span><br><span class="line">+-------------------+---------+</span><br><span class="line">| Variable_name     | Value   |</span><br><span class="line">+-------------------+---------+</span><br><span class="line">| Threads_cached    | 0       |</span><br><span class="line">| Threads_connected | 1       |</span><br><span class="line">| Threads_created   | 9626717 |</span><br><span class="line">| Threads_running   | 1       |</span><br><span class="line">+-------------------+---------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到此时的并发数也就是Threads_connected=1，还远远达不到2048</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'open_files_limit'</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| open_files_limit | 65535 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>max_connections 还取决于操作系统对单进程允许打开最大文件数的限制<br>也就是说如果操作系统限制单个进程最大可以打开100个文件<br>那么 max_connections 设置为200也没什么用<br>MySQL 的 open_files_limit 参数值是在MySQL启动时记录的操作系统对单进程打开最大文件数限制的值<br>可以使用 show variables like ‘open_files_limit’; 查看 open_files_limit 值<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n</span><br><span class="line">65535</span><br></pre></td></tr></table></figure><p></p><p>或者直接在 Linux 下通过ulimit -n命令查看操作系统对单进程打开最大文件数限制 ( 默认为1024 )</p><h1 id="connection级内存参数-线程独享"><a href="#connection级内存参数-线程独享" class="headerlink" title="connection级内存参数(线程独享)"></a>connection级内存参数(线程独享)</h1><p>connection级参数，是在每个connection第一次需要使用这个buffer的时候，一次性分配设置的内存。</p><h2 id="排序性能"><a href="#排序性能" class="headerlink" title="排序性能"></a>排序性能</h2><p>mysql对于排序,使用了两个变量来控制sort_buffer_size和 max_length_for_sort_data, 不象oracle使用SGA控制. 这种方式的缺点是要单独控制,容易出现排序性能问题.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS like <span class="string">'%sort%'</span>;</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">| Variable_name             | Value  |</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">| Sort_merge_passes         | 0      |</span><br><span class="line">| Sort_priority_queue_sorts | 1409   |</span><br><span class="line">| Sort_range                | 0      |</span><br><span class="line">| Sort_rows                 | 843479 |</span><br><span class="line">| Sort_scan                 | 13053  |</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>如果发现<code>Sort_merge_passes</code>的值比较大，你可以考虑增加<code>sort_buffer_size</code> 来加速ORDER BY 或者GROUP BY 操作,不能通过查询或者索引优化的。我们这为0，那就没必要设置那么大。</li></ul><h2 id="读取缓存"><a href="#读取缓存" class="headerlink" title="读取缓存"></a>读取缓存</h2><p>read_buffer_size = 128K(默认128K)为需要全表扫描的MYISAM数据表线程指定缓存<br>read_rnd_buffer_size = 4M：(默认256K)首先，该变量可以被任何存储引擎使用，当从一个已经排序的键值表中读取行时，会先从该缓冲区中获取而不再从磁盘上获取。</p><h2 id="大事务binlog"><a href="#大事务binlog" class="headerlink" title="大事务binlog"></a>大事务binlog</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">'binlog_cache%'</span>;</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Variable_name         | Value    |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Binlog_cache_disk_use | 220840   |</span><br><span class="line">| Binlog_cache_use      | 67604667 |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p>Binlog_cache_disk_use表示因为我们binlog_cache_size设计的内存不足导致缓存二进制日志用到了临时文件的次数</p></li><li><p>Binlog_cache_use 表示 用binlog_cache_size缓存的次数</p></li><li><p>当对应的Binlog_cache_disk_use 值比较大的时候 我们可以考虑适当的调高 binlog_cache_size 对应的值</p></li><li><p>如上图，现网是32K，我们加到64K</p></li></ul><h2 id="join语句内存影响"><a href="#join语句内存影响" class="headerlink" title="join语句内存影响"></a>join语句内存影响</h2><p>如果应用中，很少出现join语句，则可以不用太在乎join_buffer_size参数的设置大小。</p><p>如果join语句不是很少的话，个人建议可以适当增大join_buffer_size到1MB左右，如果内存充足可以设置为2MB。</p><h2 id="线程内存影响"><a href="#线程内存影响" class="headerlink" title="线程内存影响"></a>线程内存影响</h2><p>Thread_stack：每个连接线程被创建时，MySQL给它分配的内存大小。当MySQL创建一个新的连接线程时，需要给它分配一定大小的内存堆栈空间，以便存放客户端的请求的Query及自身的各种状态和处理信息。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'%threads%'</span>;</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Variable_name           | Value   |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Delayed_insert_threads  | 0       |</span><br><span class="line">| Slow_launch_threads     | 0       |</span><br><span class="line">| Threadpool_idle_threads | 0       |</span><br><span class="line">| Threadpool_threads      | 0       |</span><br><span class="line">| Threads_cached          | 0       |</span><br><span class="line">| Threads_connected       | 1       |</span><br><span class="line">| Threads_created         | 9649301 |</span><br><span class="line">| Threads_running         | 1       |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like <span class="string">'connections'</span>;</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Variable_name | Value   |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Connections   | 9649311 |</span><br><span class="line">+---------------+---------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><p>如上：系统启动到现在共接受到客户端的连接9649311次，共创建了9649301个连接线程，当前有1个连接线程处于和客户端连接的状态。而在Thread Cache池中共缓存了0个连接线程(Threads_cached)。</p><p>Thread Cache 命中率：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread_Cache_Hit = (Connections - Threads_created) / Connections * 100%;</span><br></pre></td></tr></table></figure><p></p><p>一般在系统稳定运行一段时间后，Thread Cache命中率应该保持在90%左右才算正常。</p><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><p>tmp_table_size 控制内存临时表的最大值,超过限值后就往硬盘写，写的位置由变量 tmpdir 决定<br>max_heap_table_size 用户可以创建的内存表(memory table)的大小.这个值用来计算内存表的最大行数值。<br>Order By 或者Group By操作多的话，加大这两个值，默认16M<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'Created_tmp_%'</span>;</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Created_tmp_disk_tables | 0     |</span><br><span class="line">| Created_tmp_files       | 626   |</span><br><span class="line">| Created_tmp_tables      | 3     |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>如上图，写入硬盘的为0，3次中间表，说明我们的默认值足够用了</li></ul><h1 id="mariadb-推荐配置"><a href="#mariadb-推荐配置" class="headerlink" title="mariadb 推荐配置"></a>mariadb 推荐配置</h1><ul><li>注意这里只推荐innodb引擎</li><li>内存配置只关注有注释的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">user=mysql</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># global settings</span></span><br><span class="line">table_cache=65535</span><br><span class="line">table_definition_cache=65535</span><br><span class="line"></span><br><span class="line">max_allowed_packet=4M</span><br><span class="line">net_buffer_length=1M</span><br><span class="line">bulk_insert_buffer_size=16M</span><br><span class="line"></span><br><span class="line">query_cache_type=0<span class="comment">#是否使用查询缓冲,0关闭</span></span><br><span class="line">query_cache_size=0<span class="comment">#0关闭，因为改表操作多，命中低，开启消耗cpu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shared</span></span><br><span class="line">key_buffer_size=8M<span class="comment">#保持8M MyISAM索引用</span></span><br><span class="line">innodb_buffer_pool_size=4G        <span class="comment">#DB专用mem*50%，非DB专用mem*15%到25%</span></span><br><span class="line">myisam_sort_buffer_size=32M</span><br><span class="line">max_heap_table_size=16M<span class="comment">#最大中间表大小</span></span><br><span class="line">tmp_table_size=16M<span class="comment">#中间表大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># per-thread</span></span><br><span class="line">sort_buffer_size=256K<span class="comment">#加速排序缓存大小</span></span><br><span class="line">read_buffer_size=128k<span class="comment">#为需要全表扫描的MYISAM数据表线程指定缓存</span></span><br><span class="line">read_rnd_buffer_size=4M<span class="comment">#已排序的表读取时缓存，如果比较大内存就到6M</span></span><br><span class="line">join_buffer_size=1M<span class="comment">#join语句多时加大，1-2M</span></span><br><span class="line">thread_stack=256k<span class="comment">#线程空间，256K or 512K</span></span><br><span class="line">binlog_cache_size=64K<span class="comment">#大事务binlog</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># big-tables</span></span><br><span class="line">innodb_file_per_table = 1</span><br><span class="line">skip-external-locking</span><br><span class="line">max_connections=2048<span class="comment">#最大连接数</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line"><span class="comment"># slow_query_log</span></span><br><span class="line">slow_query_log_file = /var/<span class="built_in">log</span>/mysql-slow.log</span><br><span class="line">long_query_time = 30</span><br><span class="line">group_concat_max_len=65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># according to tuning-primer.sh</span></span><br><span class="line">thread_cache_size = 8</span><br><span class="line">thread_concurrency = 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># set variables</span></span><br><span class="line">concurrent_insert=2</span><br></pre></td></tr></table></figure><h1 id="运行时修改"><a href="#运行时修改" class="headerlink" title="运行时修改"></a>运行时修改</h1><p>使用以下命令来修改变量<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global &#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br><span class="line"><span class="built_in">set</span> @@&#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br><span class="line"><span class="built_in">set</span> @@global.&#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br></pre></td></tr></table></figure><p></p><p>试验<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @@global.innodb_buffer_pool_size=4294967296;</span><br><span class="line">ERROR 1238 (HY000): Variable 'innodb_buffer_pool_size' is a read only variable</span><br><span class="line">mysql&gt; set @@global.thread_stack=262144;</span><br><span class="line">ERROR 1238 (HY000): Variable 'thread_stack' is a read only variable</span><br><span class="line">mysql&gt; set @@global.binlog_cache_size=65536;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@join_buffer_size=1048576;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@read_rnd_buffer_size=4194304;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@sort_buffer_size=262144;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@read_buffer_size=131072;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global key_buffer_size=8388608;</span><br><span class="line">Query OK, 0 rows affected (0.39 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>我们可以看到<code>innodb_buffer_pool_size</code>和<code>thread_stack</code>报错了，他们只能改配置文件，在运行时是只读的。<br>以下直接复制使用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@global.binlog_cache_size=<span class="number">65536</span>;</span><br><span class="line"><span class="keyword">set</span> @@join_buffer_size=<span class="number">1048576</span>;</span><br><span class="line"><span class="keyword">set</span> @@read_rnd_buffer_size=<span class="number">4194304</span>;</span><br><span class="line"><span class="keyword">set</span> @@sort_buffer_size=<span class="number">262144</span>;</span><br><span class="line"><span class="keyword">set</span> @@read_buffer_size=<span class="number">131072</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> key_buffer_size=<span class="number">8388608</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/dc666/article/details/78901341" target="_blank" rel="noopener">记一次Mysql占用内存过高的优化过程</a><br><a href="https://blog.csdn.net/rainysia/article/details/8767946" target="_blank" rel="noopener">mysql 优化技巧心得一(key_buffer_size设置)</a><br><a href="https://snippetinfo.net/mobile/media/1596" target="_blank" rel="noopener">mysql内存计算</a><br><a href="http://www.mysqlcalculator.com/" target="_blank" rel="noopener">mysql计算器</a><br><a href="https://mariadb.com/kb/en/library/documentation/" target="_blank" rel="noopener">mariadb官网</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 10 2019 11:36:57 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：我们在使用mariadb的时候发现有时候不能启动起来，在使用过程中mariadb占用的内存很大，在这里学习下mariadb与内存相关的配置项，对mariadb进行调优。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.qupzhi.com/categories/mysql/"/>
    
    
      <category term="mysql调优" scheme="http://www.qupzhi.com/tags/mysql%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>vimdiff</title>
    <link href="http://www.qupzhi.com/vimdiff/"/>
    <id>http://www.qupzhi.com/vimdiff/</id>
    <published>2019-01-01T12:23:00.000Z</published>
    <updated>2019-01-02T06:37:31.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：我们在windows平台上用过beyond compare来进行文件比较，在linux平台上也有类似的东西，还是免费的。那就是vimdiff，它是vim的diff模式，依赖于diff命令。在文件比较方便比diff要强大的多，它有简单明了的界面以及对比结果一目了然的特点，容易对多处差异进行对比和合并。</p><a id="more"></a><h1 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h1><p>保证安装了vim和diff命令<br>使用以下方法启动<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1 file2    <span class="comment">#垂直</span></span><br><span class="line">vimdiff -o file1 file2 <span class="comment">#水平</span></span><br></pre></td></tr></table></figure><p></p><h1 id="切换视角"><a href="#切换视角" class="headerlink" title="切换视角"></a>切换视角</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-w w <span class="comment">#在不同窗口间跳转</span></span><br><span class="line">Ctrl-w K <span class="comment">#把当前窗口移到最上边</span></span><br><span class="line">Ctrl-w H <span class="comment">#把当前窗口移到最左边</span></span><br><span class="line">Ctrl-w J <span class="comment">#把当前窗口移到最下边</span></span><br><span class="line">Ctrl-w L <span class="comment">#把当前窗口移到最右边</span></span><br></pre></td></tr></table></figure><p>其中K和J两个操作会把窗口改成水平分割方式。</p><h1 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h1><p><img src="/vimdiff/vimdiff_show1.png" alt="upload successful"></p><ul><li>只在某一文件中存在的行的背景色被设置为蓝色，而在另一文件中的对应位置被显示为绿色。</li><li>两个文件中都存在，但是包含差异的行显示为粉色背景，引起差异的文字用红色背景加以突出。</li><li><p><code>+-- 7 lines: #include &lt;stdio.h&gt;-------------------</code> 表示折叠的行 可以用<code>zo</code>（open）可以把折叠的行打开,使用<code>zc</code>(close)可以把折叠的行关闭</p></li><li><p><code>-------------------------------------------</code> 表示删除的行</p></li><li>上下文的展开和查看：比较和合并文件的时候经常需要结合上下文来确定最终要采取的操作。Vimdiff 缺省是会把不同之处上下各 6 行的文本都显示出来以供参考。其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数，可以这样设置(设置上下文为3行)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> diffopt=context:3</span><br></pre></td></tr></table></figure></li></ul><h1 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h1><p>可以使用快捷键在各个差异点之间快速移动。</p><ul><li><code>]c</code> 跳转到下一个差异点</li><li><code>[c</code> 跳转到上一个差异点</li><li><code>2]c</code>如果在命令前加上数字的话，可以跳过一个或数个差异点，从而实现跳的更远。比如如果在位于第一个差异点的行输入<code>2]c</code>，将越过下一个差异点，跳转到第三个差异点。</li></ul><h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><p>用到的命令：</p><ul><li><p><code>dp</code> （diff “put”）<br>如果希望把另一个文件的内容复制到当前行中，可以使用命令</p></li><li><p><code>do</code> (diff “get”，之所以不用dg，是因为dg已经被另一个命令占用了)</p></li><li><p><code>:diffupdate</code> 在修改一个或两个文件之后，vimdiff会试图自动来重新比较文件，来实时反映比较结果。但是也会有处理失败的情况，这个时候需要手工来刷新比较结果</p></li><li><p><code>&lt;ESC&gt;, u</code> 如果希望撤销修改，可以和平常用vim编辑一样，直接但是要注意一定要将<strong>光标移动到需要撤销修改的文件窗口</strong>中。</p></li></ul><p>备注： 如果有多个窗口的话只要在<code>dp</code>、<code>do</code>命令前加数字代表把当前行复制到哪个窗口中或者把哪个窗口中的复制到当前窗口</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://my.oschina.net/alphajay/blog/108834" target="_blank" rel="noopener">vimdiff的常用命令</a><br><a href="https://www.cnblogs.com/motoyang/p/6091281.html" target="_blank" rel="noopener">技巧：Vimdiff 使用</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：我们在windows平台上用过beyond compare来进行文件比较，在linux平台上也有类似的东西，还是免费的。那就是vimdiff，它是vim的diff模式，依赖于diff命令。在文件比较方便比diff要强大的多，它有简单明了的界面以及对比结果一目了然的特点，容易对多处差异进行对比和合并。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.qupzhi.com/categories/linux/"/>
    
    
      <category term="工具" scheme="http://www.qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="linux" scheme="http://www.qupzhi.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用腾讯云服务器搭建vpn</title>
    <link href="http://www.qupzhi.com/create_vpn/"/>
    <id>http://www.qupzhi.com/create_vpn/</id>
    <published>2018-12-27T05:42:00.000Z</published>
    <updated>2019-01-02T06:41:05.147Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：最近腾讯云发了优惠券那就给自己搭建一个vpn吧，便于随时上外网。</p><a id="more"></a><h1 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h1><p>腾讯云centos7.2 64位</p><h1 id="服务器上配置"><a href="#服务器上配置" class="headerlink" title="服务器上配置"></a>服务器上配置</h1><p>首先查看系统是否支持pptpd服务：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe ppp-compress-18 &amp;&amp; <span class="built_in">echo</span> yes</span><br></pre></td></tr></table></figure><p></p><p>安装ppp , pptpd，iptables<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ppp pptpd iptables</span><br><span class="line">systemctl mask firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p></p><p>修改配制<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pptpd.conf    <span class="comment">#找到配制文件中默认的值，去掉注释即可</span></span><br><span class="line">localip 192.168.0.2-238,192.168.0.245</span><br><span class="line">remoteip 192.168.1.2-238,192.168.1.245</span><br></pre></td></tr></table></figure><p></p><ul><li>需要注意的是：remoteip最好不用和VPN client本身所在的局域网的ip冲突。<br>修改DNS</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/options.pptpd      <span class="comment">#末尾添加dns</span></span><br><span class="line">ms-dns  8.8.8.8</span><br><span class="line">ms-dns  114.114.114.114</span><br></pre></td></tr></table></figure><p>添加vpn账户<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/chap-secrets</span><br><span class="line"><span class="comment"># client        server  secret                  IP addresses</span></span><br><span class="line">  user          pptpd   passwd                  *</span><br></pre></td></tr></table></figure><p></p><p>开启路由转发<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1 <span class="comment">#添加在配制文件的末尾即可</span></span><br><span class="line">sysctl -p    <span class="comment">#运行这个命令会输出上面添加的那一行信息，意思是使内核修改生效</span></span><br></pre></td></tr></table></figure><p></p><p>在防火墙上开启nat转发<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE  <span class="comment">#IP和网口根据实际情况修改即可</span></span><br></pre></td></tr></table></figure><p></p><p>开启服务<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service iptables save <span class="comment">#正常来说要做这个来使iptables生效</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line">systemctl restart pptpd</span><br></pre></td></tr></table></figure><p></p><p>检查是否成功<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -anlpt  | grep pptp</span><br><span class="line">tcp        0      0 0.0.0.0:1723            0.0.0.0:*               LISTEN      27202/pptpd</span><br></pre></td></tr></table></figure><p></p><p>如果不能访问的话，看系统日志位置</p><h1 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h1><p>加一个入站规则</p><p><img src="/create_vpn/ser.png" alt="upload successful"></p><h1 id="手机上连接"><a href="#手机上连接" class="headerlink" title="手机上连接"></a>手机上连接</h1><p><img src="/create_vpn/phone_vpn.png" alt="upload successful"></p><ul><li>手机上找到vpn</li><li>新建，pptp协议</li><li>服务器ip: 你的服务器ip</li><li>用户名：你刚刚设置的用户名<code>/etc/ppp/chap-secrets下</code></li><li>密码: 你刚刚设置的密码<code>/etc/ppp/chap-secrets下</code></li></ul><h1 id="mac上连接"><a href="#mac上连接" class="headerlink" title="mac上连接"></a>mac上连接</h1><p>我发现新的MacOS不支持PPTP协议，先用shimo，等试用期到了再看要不要加L2TP</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：最近腾讯云发了优惠券那就给自己搭建一个vpn吧，便于随时上外网。&lt;/p&gt;
    
    </summary>
    
      <category term="vpn" scheme="http://www.qupzhi.com/categories/vpn/"/>
    
    
      <category term="vpn" scheme="http://www.qupzhi.com/tags/vpn/"/>
    
      <category term="PPTP" scheme="http://www.qupzhi.com/tags/PPTP/"/>
    
  </entry>
  
  <entry>
    <title>base64</title>
    <link href="http://www.qupzhi.com/base64/"/>
    <id>http://www.qupzhi.com/base64/</id>
    <published>2018-12-23T09:59:00.000Z</published>
    <updated>2018-12-23T11:09:12.705Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎来到我的博客, 请输入密码来访问这篇文章." />    <label for="pass">欢迎来到我的博客, 请输入密码来访问这篇文章.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎来到我的博客, 请输入密码来访问这篇文章.
    
    </summary>
    
      <category term="base64" scheme="http://www.qupzhi.com/categories/base64/"/>
    
    
      <category term="base64" scheme="http://www.qupzhi.com/tags/base64/"/>
    
      <category term="编码" scheme="http://www.qupzhi.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="加密" scheme="http://www.qupzhi.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>版本控制工具——Git常用命令 </title>
    <link href="http://www.qupzhi.com/git-start2/"/>
    <id>http://www.qupzhi.com/git-start2/</id>
    <published>2018-12-18T05:04:00.000Z</published>
    <updated>2018-12-23T13:29:24.684Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：我们说过了git的几乎全部的常用情况，相信基本已经可以在平时团队协作开发的过程中游刃有余了。我熟悉了git的使用以后，这里给出git常用的命令，以下的命令几乎覆盖了所有的git常用操作，在此记录便于快速查找使用。</p><a id="more"></a><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git init                                              <span class="comment"># 初始化本地git仓库（创建新仓库）</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span>                   <span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@xxx.com"</span>          <span class="comment"># 配置邮件</span></span><br><span class="line">// git status等命令自动着色</span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         </span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line"></span><br><span class="line">// 查看当前代理设置</span><br><span class="line">git config --global http.proxy</span><br><span class="line">// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080</span><br><span class="line">git config --global http.proxy <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span> </span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy    <span class="comment">#删除 proxy git config</span></span><br></pre></td></tr></table></figure><h2 id="代码文件与提交相关"><a href="#代码文件与提交相关" class="headerlink" title="代码文件与提交相关"></a>代码文件与提交相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></span><br><span class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></span><br><span class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></span><br><span class="line">git commit -m <span class="string">'xxx'</span>                                       <span class="comment"># 提交</span></span><br><span class="line">git commit --amend -m <span class="string">'xxx'</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit -am <span class="string">'xxx'</span>                                      <span class="comment"># 将add和commit合为一步</span></span><br><span class="line">git rm xxx                                                <span class="comment"># 删除index中的文件</span></span><br><span class="line">git rm -r *                                               <span class="comment"># 递归删除</span></span><br><span class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></span><br><span class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></span><br><span class="line">git <span class="built_in">log</span> -5</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></span><br><span class="line">git <span class="built_in">log</span> -p -m</span><br><span class="line">git <span class="built_in">log</span> -- filename                                       <span class="comment"># 查看文件的修改日志 </span></span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></span><br><span class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></span><br><span class="line">git show HEAD                                             <span class="comment"># 显示HEAD提交日志</span></span><br><span class="line">git show HEAD^                                            <span class="comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span></span><br><span class="line">git whatchanged                                           <span class="comment"># 显示提交历史对应的文件修改</span></span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span></span><br></pre></td></tr></table></figure><h2 id="tag相关"><a href="#tag相关" class="headerlink" title="tag相关"></a>tag相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag                                                   <span class="comment"># 显示已存在的tag</span></span><br><span class="line">git tag -a v2.0 -m <span class="string">'xxx'</span>                                  <span class="comment"># 增加v2.0的tag</span></span><br><span class="line">git show v2.0                                             <span class="comment"># 显示v2.0的日志及详细内容</span></span><br><span class="line">git <span class="built_in">log</span> v2.0                                              <span class="comment"># 显示v2.0的日志</span></span><br><span class="line">git push --tags                                           <span class="comment"># 把所有tag推送到远程仓库</span></span><br><span class="line">git tag -d tag_name                                       <span class="comment"># 本地删除名为tag_name的tag</span></span><br><span class="line">git push origin :refs/tags/tag_name                       <span class="comment"># 远程删除名为tag_name的tag</span></span><br></pre></td></tr></table></figure><h2 id="差异比较相关"><a href="#差异比较相关" class="headerlink" title="差异比较相关"></a>差异比较相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff                                                  <span class="comment"># 显示所有未添加至index的变更</span></span><br><span class="line">git diff --cached                                         <span class="comment"># 显示所有已添加index但还未commit的变更</span></span><br><span class="line">git diff HEAD^                                            <span class="comment"># 比较与上一个版本的差异</span></span><br><span class="line">git diff HEAD -- ./lib                                    <span class="comment"># 比较与HEAD版本lib目录的差异</span></span><br><span class="line">git diff origin/master..master                            <span class="comment"># 比较远程分支master上有本地分支master上没有的</span></span><br><span class="line">git diff origin/master..master --<span class="built_in">stat</span>                     <span class="comment"># 只显示差异的文件，不显示具体内容</span></span><br></pre></td></tr></table></figure><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git <span class="comment"># 增加远程定义（用于push/pull/fetch）</span></span><br><span class="line">git branch                                                <span class="comment"># 显示本地分支</span></span><br><span class="line">git branch --contains 50089                               <span class="comment"># 显示包含提交50089的分支</span></span><br><span class="line">git branch -a                                             <span class="comment"># 显示所有分支</span></span><br><span class="line">git branch -r                                             <span class="comment"># 显示所有原创分支</span></span><br><span class="line">git branch --merged                                       <span class="comment"># 显示所有已合并到当前分支的分支</span></span><br><span class="line">git branch --no-merged                                    <span class="comment"># 显示所有未合并到当前分支的分支</span></span><br><span class="line">git branch -m master master_copy                          <span class="comment"># 本地分支改名</span></span><br><span class="line">git checkout -b master_copy                               <span class="comment"># 从当前分支创建新分支master_copy并检出</span></span><br><span class="line">git checkout -b master master_copy                        <span class="comment"># 上面的完整版</span></span><br><span class="line">git checkout features/performance                         <span class="comment"># 检出已存在的features/performance分支</span></span><br><span class="line">git checkout --track hotfixes/BJVEP933                    <span class="comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span></span><br><span class="line">git checkout v2.0                                         <span class="comment"># 检出版本v2.0</span></span><br><span class="line">git checkout -b devel origin/develop                      <span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">git checkout -- README                                    <span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git merge origin/master                                   <span class="comment"># 合并远程master分支至当前分支</span></span><br><span class="line">git cherry-pick ff44785404a8e                             <span class="comment"># 合并提交ff44785404a8e的修改</span></span><br><span class="line">git push origin master                                    <span class="comment"># 将当前分支push到远程master分支</span></span><br><span class="line">git push origin :hotfixes/BJVEP933                        <span class="comment"># 删除远程仓库的hotfixes/BJVEP933分支</span></span><br><span class="line">git fetch                                                 <span class="comment"># 获取所有远程分支（不更新本地分支，另需merge）</span></span><br><span class="line">git fetch --prune                                         <span class="comment"># 获取所有原创分支并清除服务器上已删掉的分支</span></span><br><span class="line">git pull origin master                                    <span class="comment"># 获取远程分支master并merge到当前分支</span></span><br><span class="line">git mv README README2                                     <span class="comment"># 重命名文件README为README2</span></span><br><span class="line">git reset --hard HEAD                                     <span class="comment"># 将当前版本重置为HEAD（通常用于merge失败回退）</span></span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           <span class="comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span></span><br><span class="line">git branch -D hotfixes/BJVEP933                           <span class="comment"># 强制删除分支hotfixes/BJVEP933，小心操作</span></span><br><span class="line">git ls-files                                              <span class="comment"># 列出git index包含的文件</span></span><br><span class="line">git show-branch                                           <span class="comment"># 图示当前分支历史</span></span><br><span class="line">git show-branch --all                                     <span class="comment"># 图示所有分支历史</span></span><br></pre></td></tr></table></figure><h2 id="图示命令"><a href="#图示命令" class="headerlink" title="图示命令"></a>图示命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git ls-tree HEAD                                          <span class="comment"># 内部命令：显示某个git对象</span></span><br><span class="line">git rev-parse v2.0                                        <span class="comment"># 内部命令：显示某个ref对于的SHA1 HASH</span></span><br><span class="line">git reflog                                                <span class="comment"># 显示所有提交，包括孤立节点</span></span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               <span class="comment"># 显示master分支昨天的状态</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph                   <span class="comment"># 图示提交日志</span></span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br></pre></td></tr></table></figure><h2 id="暂存相关"><a href="#暂存相关" class="headerlink" title="暂存相关"></a>暂存相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash                                                 <span class="comment"># 暂存当前修改，将所有至为HEAD状态</span></span><br><span class="line">git stash list                                            <span class="comment"># 查看所有暂存</span></span><br><span class="line">git stash show -p stash@&#123;0&#125;                               <span class="comment"># 参考第一次暂存</span></span><br><span class="line">git stash apply stash@&#123;0&#125;                                 <span class="comment"># 应用第一次暂存</span></span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git grep <span class="string">"delete from"</span>                                    <span class="comment">#查找当前分支下的文件内容，可以git grep --help看具体用法</span></span><br><span class="line">git grep <span class="string">"delete from"</span> v2.0                               <span class="comment">#指定tag来查找</span></span><br></pre></td></tr></table></figure><h2 id="git-index操作"><a href="#git-index操作" class="headerlink" title="git index操作"></a>git index操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git update-index —assume-unchanged 文件名                  <span class="comment">#取消本地跟踪</span></span><br><span class="line">git update-index —no-assume-unchanged 文件名               <span class="comment">#恢复本地跟踪</span></span><br><span class="line">git ls-files -v| grep <span class="string">'^h\ '</span>                               <span class="comment">#可以看到本地不跟踪的文件</span></span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：我们说过了git的几乎全部的常用情况，相信基本已经可以在平时团队协作开发的过程中游刃有余了。我熟悉了git的使用以后，这里给出git常用的命令，以下的命令几乎覆盖了所有的git常用操作，在此记录便于快速查找使用。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://www.qupzhi.com/categories/git/"/>
    
    
      <category term="工具" scheme="http://www.qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="版本控制" scheme="http://www.qupzhi.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git教程" scheme="http://www.qupzhi.com/tags/git%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>版本控制工具——Git常用操作（下）</title>
    <link href="http://www.qupzhi.com/git-start3/"/>
    <id>http://www.qupzhi.com/git-start3/</id>
    <published>2018-12-15T05:21:00.000Z</published>
    <updated>2018-12-23T13:21:05.121Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：上一集我们一起入门学习了git的基本概念和git常用的操作，包括提交和同步代码、使用分支、出现代码冲突的解决办法、紧急保存现场和恢复现场的操作。学会以后已经足够我们使用Git参加协作开发了，但是在开发的过程中难免会出错，本文主要介绍版本控制的过程中出错了的场景，以及Git开发的一些技巧，让我们用的更流畅。</p><a id="more"></a><p>上集回顾：</p><ul><li>Git的基本概念</li><li>一个人使用Git时的代码版本控制–（提交、拉代码、分支操作）</li><li>多人合作时的代码版本控制–（合并冲突、暂存代码）</li></ul><p>上集传送门：<a href="/git-start" target="view_window">版本控制工具——Git常用操作（上）</a></p><p>本文核心：</p><ul><li>后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）</li><li>哎呀，提交的时候漏了文件</li><li>tag操作</li><li>git忽略不想提交的文件</li></ul><h1 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h1><h2 id="撤消当前commit"><a href="#撤消当前commit" class="headerlink" title="撤消当前commit"></a>撤消当前commit</h2><p>如果你发现刚刚的操作一不小心commit了，所幸你还没有推送到远程仓库，你可以用<code>reset</code>命令来撤消你的这次提交。<br><code>reset</code>命令的作用：重置HEAD(当前分支的版本顶端）到另外一个commit。</p><blockquote><p>我们的撤消当前提交的时候往往不希望我们此次提交的代码发生任何丢失，只是撤消掉commit的操作，以便我们继续修改文件。如果我们是想直接不要了这次commit的全部内容的任何修改我们将在下一小节讨论。</p></blockquote><p>来，我们先说一句蠢话来diss老板<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ touch to_boss.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a bad guy!'</span> &gt; to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git add to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"[+]骂了我的boss"</span></span><br><span class="line">[master 3d113a7] [+]骂了我的boss</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 to_boss.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>创建to_boss.txt文件，并向其写入了<code>my boss is a bad guy!</code></li><li><code>add</code>然后<code>status</code>查看新文件已经加入跟踪</li><li><code>commit</code>提交了这次的修改</li></ul><p>好了，刚刚我们“不小心”diss了我们的老板，要是被发现就完了，所幸还没有<code>push</code>，要快点撤消这些提交，再换成一些好话才行。<br>我们使用以下命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft head^</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line"></span><br><span class="line">$ cat to_boss.txt</span><br><span class="line">my boss is a bad guy!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a good boy!'</span></span><br><span class="line">my boss is a good boy!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a good boy!'</span> &gt; to_boss.txt</span><br><span class="line"></span><br><span class="line">$ cat to_boss.txt</span><br><span class="line">my boss is a good boy!</span><br><span class="line"></span><br><span class="line">$ git add to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line">    </span><br><span class="line">$ git commit -m <span class="string">"[*]夸了我的boss"</span></span><br><span class="line">[master 8be46aa] [*]夸了我的boss</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 to_boss.txt</span><br></pre></td></tr></table></figure><p></p><ul><li><code>git reset --soft head^</code>撤消了本次提交，将工作区恢复到了提交前但是已经<code>add</code>的状态</li><li>将<code>to_boss.txt</code>的内容改成了<code>my boss is a good boy!</code></li><li><code>add</code>然后<code>commit</code>提交</li></ul><p>好了，有惊无险，这就是撤消commit的操作。另一种情况是如果你想撤消commit的时候支持舍弃这次全部的修改就把<code>git reset --soft head^</code>改成<code>git reset --hard head^</code>，这样你本地修改就彻底丢掉了(慎用)，如果真用了想找回来怎么办？见<a href="#救命的后悔药">救命的后悔药</a>。</p><p>当然了，你只要开心不加<code>soft</code>或<code>hard</code>参数也是安全的(相当于使用了<code>--mixed</code>参数)，只不过是撤消以后你的本次修改就会回到<code>add</code>之前的状态，你可以重新检视然后再做修改和<code>commit</code>。</p><h2 id="回退远程仓库"><a href="#回退远程仓库" class="headerlink" title="回退远程仓库"></a>回退远程仓库</h2><p>要是我们做的更过分一点，直接把这次<code>commit</code>直接给<code>push</code>怎么办？要是被发现就全完了,我们来看看github上的远程仓库。</p><p><img src="/git-start3/rollback_push.png" alt="upload successful"></p><p>完了，真的提交了（我刚刚push的）让我们冷静下来，用<a href="#撤消当前commit">撤消当前commit</a>的方法先撤消本地的<code>commit</code>,这次我们来试试用<code>hard</code>参数来撤消</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard head^</span><br><span class="line">HEAD is now at 3f22a06 [+]add file time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git push origin master --force</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> + 3d113a7...3f22a06 master -&gt; master (forced update)</span><br></pre></td></tr></table></figure><ul><li>使用<code>git reset --hard head^</code>回滚到上一个<code>commit</code></li><li>使用<code>git status</code>查看现在的工作区情况，提示<code>Your branch is behind &#39;origin/master&#39; by 1 commit</code>,代表成功表了上一次的提示状态，<code>nothing to commit, working tree clean</code>代表这次的修改全没了，清理的算是一个彻底。如果还想找回来怎么办，我们还真是有办法让你找回来的，见<a href="#救命的后悔药">救命的后悔药</a>。</li><li><code>git push origin master --force</code> 命令强制提交到远程仓库(注意，如果是在团队合作的情况下，不到迫不得已不要给命令加–force参数)<br>让我们看看<code>github</code></li></ul><p><img src="/git-start3/rollback_push2.png" alt="upload successful"></p><p>真的撤消了远程仓库，长舒一口气。</p><h2 id="暂存区（Stage）到工作区（Working-Directory）"><a href="#暂存区（Stage）到工作区（Working-Directory）" class="headerlink" title="暂存区（Stage）到工作区（Working Directory）"></a>暂存区（Stage）到工作区（Working Directory）</h2><p>如果我们刚刚执行了<code>git reset --soft</code>或者<code>add</code>等的操作，把一些东西加到了我们的暂存区，比如日志文件,我们就要把他们从暂存区拿出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   mysql.log</span><br><span class="line">    </span><br><span class="line">$ git reset -- mysql.log</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">mysql.log</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><ul><li><code>status</code>查看暂存区，里面有一个mysql.log被放进去了</li><li><code>git reset -- mysql.log</code>把<code>mysql.log</code>取出来</li><li><code>status</code>可以看到真的取出来了<br>然后如果不要想这个文件的话再rm掉就好啦,但是如果这些文件每次自动生成都要用这种方式取出暂存区真的好累，我们可以用 <a href="#git忽略不想提交的文件">git忽略不想提交的文件</a></li></ul><h2 id="回滚文件到某个提交"><a href="#回滚文件到某个提交" class="headerlink" title="回滚文件到某个提交"></a>回滚文件到某个提交</h2><p>当我们想要把某个文件任意的回滚到某次提交上，而不改变其他文件的状态我们要怎么做呢？<br>我们有两种情况，一种是，只是想在工作区有修改的文件，直接丢弃掉他现在的修改；第二种是想把这个文件回滚到以前的某一次提交。我们先来说第一种：</p><h3 id="取消文件在工作区的修改"><a href="#取消文件在工作区的修改" class="headerlink" title="取消文件在工作区的修改"></a>取消文件在工作区的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 18:51 &gt; time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   time.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">18:51</span><br><span class="line"></span><br><span class="line">$ git checkout -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br></pre></td></tr></table></figure><ul><li>更新<code>time.txt</code>的内容，可以<code>status</code>看到他发生了变化</li><li><code>git checkout -- time.txt</code> , 取消这次在工作区的修改，如果他已经被<code>add</code>加到了暂存区，那么这个命令就没有用了，他的意思是取消本次在工作区的修改，去上一次保存的地方。如果没有<code>add</code>就回到和版本库一样的状态；如果已经加到了暂存区，又做了修改，那么就回加到暂存区后的状态<h3 id="将文件回滚到任意的版本"><a href="#将文件回滚到任意的版本" class="headerlink" title="将文件回滚到任意的版本"></a>将文件回滚到任意的版本</h3>我们这里说的把文件回滚到以前的某个版本的状态，完整的含义是保持其他文件的内容不变，改变这个文件到以前的某个版本，然后修改到自己满意的样子和做下一次的提交。</li></ul><p>核心命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;options&gt;] [&lt;branch&gt;] -- &lt;file&gt;...</span><br></pre></td></tr></table></figure><p></p><p>我们还是用<code>time.txt</code>这个文件来做试验,先搞三个版本出来，在这里我已经搞好了，来看看：<br>版本1，time.txt内容00:50<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line">    [*]update time to 00:50</span><br></pre></td></tr></table></figure><p></p><p>版本2，time.txt内容18:51<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line">    [*]update time to 18:51</span><br></pre></td></tr></table></figure><p></p><p>版本3，time.txt内容10:41<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 3f22a0639f8d79bd4e329442f181342465dbf0b6</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Tue Dec 18 10:42:29 2018 +0800</span><br><span class="line">    [+]add file time.txt</span><br></pre></td></tr></table></figure><p></p><p>现在的是版本1，我们把版本3检出试试。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 3f22a0639f8d -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>使用<code>checkout</code>+<code>commit id</code>+<code>-- filename</code>的组合，横跨版本2把历史版本3的<code>time.txt</code>搞出来了</li><li>查看状态,time.txt被改变了</li></ul><p>我们来把time.txt恢复到版本1，同样的方法，因为版本1是上一次提交我们可以省略掉版本号<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">00:50</span><br></pre></td></tr></table></figure><p></p><p>看到了吧！只要用<code>git checkout commit_id -- filename</code>的组合，想搞出哪个文件历史版本就搞出哪个。</p><p>到了这里，你可能会很懵比,<code>reset</code>和<code>checkout</code>命令真的好像啊！都可以用来做撤消</p><ul><li><code>checkout</code>语义上是把什么东西取出来，所以此命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</li><li><code>reset</code>语义上是重新设置，所以此命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</li></ul><p>还想不通可以给我发邮件：<a href="mailto:pzqu@qq.com" target="_blank" rel="noopener">pzqu@qq.com</a></p><h2 id="救命的后悔药"><a href="#救命的后悔药" class="headerlink" title="救命的后悔药"></a>救命的后悔药</h2><p>来到这里我已经很清楚的你的现况了，你的代码丢了现在一定非常的着急，不要慌，总是有办法找回他们的。但是前提是要保证你的项目根目录下.git文件夹是完整的，要是手动删除了里面的一些东西那就真完了。还要保证一点，你的代码以前是有过git追踪的，最少<code>add</code>过</p><h3 id="找回你丢失的历史记录"><a href="#找回你丢失的历史记录" class="headerlink" title="找回你丢失的历史记录"></a>找回你丢失的历史记录</h3><p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令，贴个图吧直观点：<br><img src="/git-start3/help1.png" alt="upload successful"></p><ul><li>有没有发现，<code>git reflog</code>里的全部都是和改变目录树有关的，比如<code>commit rebase reset merge</code>，也就是说一定要有改变目录树的操作才恢复的回来</li><li>像add这种操作就不能恢复了吗？那肯定不是，只是要用更麻烦点的方式来恢复</li><li><p><code>git log</code>是一样的，也可以看到所有分支的历史提交，不一样的是看不到已经被删除的 <code>commit</code> 记录和 <code>reset rebase merge</code> 的操作<br>我们可以看到<code>git reflog</code>前面的就是<code>commit id</code>，现在我们就可以用之前介绍过的方法来回滚版本了，<a href="#撤消当前commit">撤消当前commit</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 856a740</span><br><span class="line">HEAD is now at 856a740 [*]update time to 18:51</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff (HEAD -&gt; master)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 18:51</span><br><span class="line"> </span><br><span class="line">$ git reset --hard 35b66ed</span><br><span class="line">HEAD is now at 35b66ed [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit 35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 18:51</span><br></pre></td></tr></table></figure></li><li><p>根据<code>git reflog</code>返回的结果，用<code>git reset --hard commit_id</code>回退到<code>856a740</code>这个版本</p></li><li><code>git log -1</code>看近一行的日志，可以看到目前就在这了</li><li>再根据<code>git reflog</code>的结果，用<code>git reset --hard 35b66ed</code>跑到这次提交</li><li><code>git log -2</code>看到两次提交的日志，我们就这么再穿梭过来了，就是这么爽<br>但是我们如果只是想把此提交给找回来，恢复他，那还是不要用<code>reset</code>的方式，可以用<code>cherry-pick</code>或者<code>merge</code>来做合并</li></ul><h3 id="找回忘记提交的历史记录"><a href="#找回忘记提交的历史记录" class="headerlink" title="找回忘记提交的历史记录"></a>找回忘记提交的历史记录</h3><p>你之前没有commit过的文件，被删除掉了，或者被<code>reset --hard</code>的时候搞没了,这种情况可以说是相当的难搞了，所幸你以前做过<code>add</code>的操作把他放到过暂存区，那我们来试试找回来,先来创建一个灾难现场<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'my lose message'</span> &gt; lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git add lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git reset --hard 35b66ed8</span><br><span class="line">HEAD is now at 35b66ed [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">README.md      need_stash.txt share_file.txt time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>创建一个叫<code>lose_file.txt</code>的文件并写入内容<code>my lose message</code>，并把他加到暂存区</li><li>用<code>git reset --hard 35b66ed8</code>用丢弃一切修改的方式来使现在的工作区恢复到<code>35b66ed8</code>版本，因为还没提交所以也就是恢复到当前的（<code>head</code>）版本。</li><li>我们用<code>status</code>和<code>ls</code>再看，这个叫<code>lose_file.txt</code>的文件真的没了，完蛋了,第一反应用刚刚学到的命令<code>git reflow</code>会发现根本就不好使</li></ul><p>核心命令：<code>git fsck --lost-found</code>,他会通过一些神奇的方式把历史操作过的文件以某种算法算出来加到<code>.git/lost-found</code>文件夹里<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">dangling blob 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">dangling commit fdbb19cf4c5177003ea6610afd35cda117a41109</span><br><span class="line">dangling commit 8be46aa83f0fe90317b0c6b9c201ad994f8caeaf</span><br><span class="line">dangling blob 11400c1d56142615deba941a7577d18f830f4d85</span><br><span class="line">dangling tree 3bd4c055afedc51df0326def49cf85af15994323</span><br><span class="line">dangling commit 3d113a773771c09b7c3bf34b9e974a697e04210a</span><br><span class="line">dangling commit bfdc065df8adc44c8b69fa6826e75c5991e6cad0</span><br><span class="line">dangling tree c96ff73cb25b57ac49666a3e1e45e0abb8913296</span><br><span class="line">dangling blob d6d03143986adf15c806df227389947cf46bc6de</span><br><span class="line">dangling commit 7aa21bc382cdebe6371278d1af1041028b8a2b09</span><br></pre></td></tr></table></figure><p></p><p>这里涉及到git的一些低层的知识，我们可以看到这里有<code>blob、commit、tree</code>类型的数据，还有<code>tag</code>等类型的。他们是什么含义呢？</p><p><img src="/git-start3/losefile.png" alt="upload successful"></p><ul><li><code>blob</code>组件并不会对文件信息进行存储，而是对文件的内容进行记录</li><li><code>commit</code>组件在每次提交之后都会生成，当我们进行<code>commit</code>之后，首先会创建一个<code>commit</code>组件，之后把所有的文件信息创建一个<code>tree</code>组件,所以哪个<code>blob</code>代表什么文件都可以在<code>tree</code> 里找到<br>我们来看看怎么恢复刚刚不见了的<code>lose_file.txt</code>文件，在上面执行完<code>git fsck --lost-found</code>命令，返回的第一行<code>blob</code>我们看看他的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git show 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">my lose message</span><br><span class="line"></span><br><span class="line">git show 7f5965523d2b9e850b39eb46e8e0f7c5755f6719 &gt; lose_file.txt</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">README.md      lose_file.txt  need_stash.txt share_file.txt time.txt</span><br></pre></td></tr></table></figure><ul><li><p>看到没有，就是我们丢失的文件内容，这样就找回来了！<br>我们再来看看<code>commit tree</code>的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p fdbb19cf4c5177003ea6610afd35cda117a41109</span><br><span class="line">tree 673f696143eb74ac5e82a46ca61438b2b2d3bbf4</span><br><span class="line">parent e278392ccbf4361f27dc338c854c8a03daab8c49</span><br><span class="line">parent 7b54a8ae74be7192586568c6e36dc5a813ff47cf</span><br><span class="line">author pzqu &lt;pzqu@example.com&gt; 1544951197 +0800</span><br><span class="line">committer pzqu &lt;pzqu@example.com&gt; 1544951197 +0800</span><br><span class="line"></span><br><span class="line">Merge branch <span class="string">'master'</span> of github.com:pzqu/git_test</span><br><span class="line"></span><br><span class="line">$ git ls-tree 3bd4c055afedc51df0326def49cf85af15994323</span><br><span class="line">100644 blob c44be63b27a3ef835a0386a62ed168c91e680e87share_file.txt</span><br></pre></td></tr></table></figure></li><li><p>用<code>git cat-file -p</code>可以看到commit的内容，可以选择把这个commit合并到我们的分支里，还是<code>reset merge rebase cherry-pick</code>这些命令来合<code>commit</code></p></li><li><code>git ls-tree</code>列出tree下面的文件名和<code>id</code>的记录信息，然后就可以根据这些来恢复文件了</li></ul><p>后记：<br>如果你发现执行<code>git fsck --lost-found</code>的输出找不到你想要的，那么在执行完<code>git fsck --lost-found</code>后会出现一堆文件 在 .git/lost-found 文件夹里,我们不管他。可以用以下命令来输出近期修改的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$  find .git/objects -<span class="built_in">type</span> f | xargs ls -lt | sed 3q</span><br><span class="line">-r--r--r--  1 pzqu  staff    32 12 23 12:19 .git/objects/7f/5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">-r--r--r--  1 pzqu  staff    15 12 23 01:51 .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">-r--r--r--  1 pzqu  staff   162 12 23 00:51 .git/objects/35/b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">my lose message</span><br><span class="line"></span><br><span class="line">$ git cat-file -t b2484b5ab58c5cb6ecd92dacc09b41b78e9b0001</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p b2484b5ab58c5cb6ecd92dacc09b41b78e9b0001</span><br><span class="line">100644 blob f9894f4195f4854cfc3e3c55960200adebbc3ac5README.md</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391need_stash.txt</span><br><span class="line">100644 blob 83f50ec84c00f5935da8089bac192171cfda8621share_file.txt</span><br><span class="line">100644 blob f0664bd6a49e268d3db47c508b08d865bc25f7bbtime.txt</span><br></pre></td></tr></table></figure><ul><li>这里用<code>find .git/objects -type f | xargs ls -lt | sed 3q</code>返回了近3个修改的文件,想要更多就改<code>3q</code>这个数值，比如你想输出100个就用<code>100q</code></li><li><code>git cat-file -t 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</code> 就能看见文件类型 把最后一个/去掉 复制从objects/ 后面的所有东西放在-t后面</li><li><code>git cat-file -p id</code>就能看见文件内容，是不是很爽</li></ul><h1 id="漏提交"><a href="#漏提交" class="headerlink" title="漏提交"></a>漏提交</h1><p>有时候会碰到我们已经commit但是有修改忘记了提交，想把他们放在刚刚的<code>commit</code>里面，这种时候怎么做呢？<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --name-status --pretty=oneline -1</span><br><span class="line">35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD) [*]update time to 00:50</span><br><span class="line">M       time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   lose_file.txt</span><br><span class="line">new file:   test_amend.txt</span><br><span class="line">    </span><br><span class="line">$ git commit --amend --no-edit</span><br><span class="line">[master 31cc277] [*]update time to 00:50</span><br><span class="line"> Date: Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line"> 3 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 lose_file.txt</span><br><span class="line"> create mode 100644 test_amend.txt</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --name-status --pretty=oneline -1</span><br><span class="line">31cc2774f0668b5b7c049a404284b19e9b40dc5d (HEAD -&gt; master) [*]update time to 00:50</span><br><span class="line">A       lose_file.txt</span><br><span class="line">A       test_amend.txt</span><br><span class="line">M       time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>查看文件提交日志只有<code>time.txt</code></li><li>stage里还有新的修改在</li><li>使用<code>git commit --amend --no-edit</code>合并到上一个提交里，如果不加<code>--no-edit</code>参数的话，会提示你来修改commit提示信息(这个命令也可以用在重复编辑<code>commit message</code>)。</li><li>查看日志，合并提交成功！</li></ul><h1 id="tag标签"><a href="#tag标签" class="headerlink" title="tag标签"></a>tag标签</h1><h2 id="创建一个tag"><a href="#创建一个tag" class="headerlink" title="创建一个tag"></a>创建一个tag</h2><p>标签是一个类似于快照的东西，常常用于测试和发布版本。所以我们常常把<code>tag</code>名以版本号来命名，比如：v1.0beat1这样<br>我们怎么创建标签呢？首先先切换到想打标签的分支，然后直接打就可以了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev/pzqu</span><br><span class="line">  master</span><br><span class="line">* release_v1.0</span><br><span class="line"></span><br><span class="line">$ git tag -a release_v1.0 -m <span class="string">"release v1.0"</span></span><br><span class="line"></span><br><span class="line">$ git tag release_v1.1</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">release_v1.0</span><br><span class="line">release_v1.1</span><br><span class="line"></span><br><span class="line">$ git push --tags</span><br><span class="line">Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 158 bytes | 158.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new tag]         release_v1.0 -&gt; release_v1.0</span><br><span class="line"> * [new tag]         release_v1.1 -&gt; release_v1.1</span><br></pre></td></tr></table></figure><p></p><ul><li>切换到想打<code>tag</code>的分支</li><li>创建名为<code>release_v1.0</code>带有信息<code>release v1.0</code>的<code>tag</code></li><li>创建的不带有<code>tag</code>的提交信息的<code>release_v1.1</code></li><li><code>git tag</code>查看<code>tag</code></li><li>推送本地全部<code>tag</code></li></ul><p>也可以推送单个tag<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin release_v1.1</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new tag]         release_v1.1 -&gt; release_v1.1</span><br></pre></td></tr></table></figure><p></p><p>我们来删除tag<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d release_v1.0</span><br><span class="line">Deleted tag <span class="string">'release_v1.0'</span> (was eb5d177)</span><br><span class="line"></span><br><span class="line">$ git push origin :refs/tags/release_v1.0</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> - [deleted]         release_v1.0</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">release_v1.1</span><br></pre></td></tr></table></figure><p></p><ul><li>本地删除名为<code>release_v1.0</code>的<code>tag</code></li><li>远程删除名为<code>release_v1.0</code>的<code>tag</code></li></ul><h2 id="对历史提交打tag"><a href="#对历史提交打tag" class="headerlink" title="对历史提交打tag"></a>对历史提交打tag</h2><p>先看看当前的log<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">31cc277 (HEAD -&gt; release_v1.0, tag: release_v1.1, origin/release_v1.0, master) [*]update time to 00:50</span><br><span class="line">856a740 [*]update time to 18:51</span><br><span class="line">3f22a06 [+]add file time.txt</span><br><span class="line">4558a25 (origin/dev/pzqu, dev/pzqu) [*]test stash</span><br><span class="line">d9e018e [*]merge master to dev/pzqu</span><br></pre></td></tr></table></figure><p></p><p>比方说要对<code>[*]update time to 18:51</code>这次提交打标签，它对应的commit id是<code>856a740</code>，敲入命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v.9 856a740</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">31cc277 (HEAD -&gt; release_v1.0, tag: release_v1.1, origin/release_v1.0, master) [*]update time to 00:50</span><br><span class="line">856a740 (tag: v0.9) [*]update time to 18:51</span><br></pre></td></tr></table></figure><p></p><ul><li>成功打上</li></ul><h1 id="git忽略不想提交的文件"><a href="#git忽略不想提交的文件" class="headerlink" title="git忽略不想提交的文件"></a>git忽略不想提交的文件</h1><p>我们有两种情况，一种是我们根本就不想这些文件出现在git库里比如日志文件；另一种是git远程仓库里有这些文件，就像通用的配置文件，我们必须要在本地修改配置来适应运行环境，这种情况下我们不想每次提交的时候都去跟踪这些文件。</p><h2 id="忽略自动生成的垃圾文件、中间文件、敏感信息文件"><a href="#忽略自动生成的垃圾文件、中间文件、敏感信息文件" class="headerlink" title="忽略自动生成的垃圾文件、中间文件、敏感信息文件"></a>忽略自动生成的垃圾文件、中间文件、敏感信息文件</h2><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>我们要怎么做呢？</p><blockquote><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"*.log"</span> &gt; .gitignore</span><br><span class="line"></span><br><span class="line">$ touch test.log</span><br><span class="line"></span><br><span class="line">$ touch test2.log</span><br><span class="line"></span><br><span class="line">$ ls -a</span><br><span class="line">.              .git           README.md      need_stash.txt test.log       test_amend.txt</span><br><span class="line">..             .gitignore     lose_file.txt  share_file.txt test2.log      time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch release_v1.0</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p></p></blockquote><ul><li>创建并写入忽略规则<code>*.log</code>忽略全部以<code>.log</code>为后缀的文件</li><li>创建了<code>test.log</code>和<code>test2.log</code></li><li><code>status</code>查看，真是工作区是<code>clean</code>，新创建的文件没有被跟踪</li></ul><h2 id="忽略远程存在，本地不想与远程同步的文件"><a href="#忽略远程存在，本地不想与远程同步的文件" class="headerlink" title="忽略远程存在，本地不想与远程同步的文件"></a>忽略远程存在，本地不想与远程同步的文件</h2><h3 id="添加跟踪忽略"><a href="#添加跟踪忽略" class="headerlink" title="添加跟踪忽略"></a>添加跟踪忽略</h3><p>核心命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index —assume-unchanged 文件名</span><br></pre></td></tr></table></figure><p></p><p><img src="/git-start3/ignore1.png" alt="upload successful"></p><ul><li>创建<code>time.txt</code>文件并写入<code>10:41</code>,提交到远程仓库</li><li>使用命令<code>git update-index —assume-unchanged</code>加<code>time.txt</code>加到忽略名单里</li><li>修改<code>time.txt</code>的内容为<code>10:43</code></li><li><code>status</code>查看确实没有被跟踪<br>看远程仓库</li></ul><p><img src="/git-start3/ignore2.png" alt="upload successful"></p><h3 id="取消跟踪忽略"><a href="#取消跟踪忽略" class="headerlink" title="取消跟踪忽略"></a>取消跟踪忽略</h3><p>核心命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index —no-assume-unchanged 文件名</span><br></pre></td></tr></table></figure><p></p><p><img src="/git-start3/ignore3.png" alt="upload successful"></p><ul><li><code>pull</code>同步远程仓库，真的没有更新刚刚被添加跟踪忽略的文件</li><li><code>git update-index —no-assume-unchanged</code>取消跟踪忽略</li><li><code>status</code>查看，出现文件的跟踪</li></ul><h3 id="查看跟踪记录"><a href="#查看跟踪记录" class="headerlink" title="查看跟踪记录"></a>查看跟踪记录</h3><p>如果忘记了哪些文件被自己本地跟踪</p><p><img src="/git-start3/ignore4.png" alt="upload successful"></p><ul><li>使用命令<code>git update-index —assume-unchanged</code>加<code>time.txt</code>加到忽略名单里</li><li>使用<code>git ls-files -v| grep &#39;^h\ &#39;</code>命令可以看到小写h代表本地不跟踪的文件</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>学完本文章，你将学会</p><ul><li>撤消commit,回滚暂存区，回滚工作区、回退远程仓库</li><li>两种方法找回不小心丢失的文件</li><li>提交的时候漏了文件，修改commit的提交信息</li><li>tag操作，创建、创建有描述信息的tag、删除tag、删除远程tag、推送本地单个tag和全部tag</li><li>git忽略自动生成的垃圾文件、中间文件、敏感信息文件；忽略远程存在，本地不想与远程同步的文件并恢复跟踪和查看哪些文件被跟踪</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="下集"><a href="#下集" class="headerlink" title="下集"></a>下集</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><p><a href="https://www.cnblogs.com/hope-markup/p/6683522.html" target="_blank" rel="noopener">关于git reset –hard这个命令的惨痛教训</a></p><p><a href="https://www.cnblogs.com/Calvino/p/5930656.html" target="_blank" rel="noopener">Git 基础再学习之：git checkout – file</a></p><p><a href="https://www.cnblogs.com/instona/p/4243009.html" target="_blank" rel="noopener">如何理解git checkout – file和git reset HEAD – file</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：上一集我们一起入门学习了git的基本概念和git常用的操作，包括提交和同步代码、使用分支、出现代码冲突的解决办法、紧急保存现场和恢复现场的操作。学会以后已经足够我们使用Git参加协作开发了，但是在开发的过程中难免会出错，本文主要介绍版本控制的过程中出错了的场景，以及Git开发的一些技巧，让我们用的更流畅。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>版本控制工具——Git常用操作（上）</title>
    <link href="http://www.qupzhi.com/git-start/"/>
    <id>http://www.qupzhi.com/git-start/</id>
    <published>2018-12-07T15:53:00.000Z</published>
    <updated>2018-12-22T08:13:02.782Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。</p><a id="more"></a><p>本文核心点：</p><ul><li>Git的基本概念</li><li>一个人使用Git时的代码版本控制–（提交、拉代码、分支操作）</li><li>多人合作时的代码版本控制–（合并冲突、暂存代码）</li></ul><h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>git是世界上目前最先进的分布式版本控制系统,致力于团队、个人进行项目版本管理，完美的解决难以比较代码、难以合并代码、难以取消修改、难以在写当前代码的过程中保存未完成的修改去修改线上版本的bug等的痛点。<br>git是一个非常强大的工具，但作为一个git使用者来说，不用完全学习Git的知识点与命令，因为有的命令的使用频率非常的低甚至数年都不会用到，让我们来由浅入深进行学习。</p><h2 id="git的历史"><a href="#git的历史" class="headerlink" title="git的历史"></a>git的历史</h2><p>git是linux的创始人linus，在付费版本控制工具BitMover收回对Linux社区免费使用权利的时候，一怒之下花费两个星期的时间写出来的。（牛笔的人）</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>选择自己的操作系统对应的git版本安装，安装成功后运行<code>git version</code>后，输出git版本则安装正确。<br>git 官方： <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>使用<code>git config</code>命令来配置用户名和邮箱<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "pzqu" </span><br><span class="line">git config --global user.email pzqu@example.com</span><br></pre></td></tr></table></figure><p></p><blockquote><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p></blockquote><p>使用<code>git config user.name</code>和<code>git config user.email</code>来检查是否成功，也可以直接用<code>git config --list</code>来列出全部git配置信息来查看</p><p><img src="/git-start/85838584.png" alt=""></p><h2 id="创建git托管的项目"><a href="#创建git托管的项目" class="headerlink" title="创建git托管的项目"></a>创建git托管的项目</h2><p>假如我们创建一个项目叫make_money，先创建一个文件夹叫make_money，再使用<code>git init</code>命令创建git项目。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:05:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:24]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">make_money</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money [0:07:10]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /Users/pzqu/Documents/code/test/make_money/.git/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money on git:master o [0:07:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -al</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:07 .</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:06 ..</span><br><span class="line">drwxr-xr-x  9 pzqu  staff  288 11  7 00:07 .git</span><br></pre></td></tr></table></figure><p></p><p>创建成功以后，会出现一个叫.git的隐藏文件夹，这个就是你的git仓库，以后所有的git操作历史提交记录信息就全部记录在此了，只要这个文件夹在就可以记住我们的全部git操作</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>在使用git的时候还要清楚暂存区和工作区的含义，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇-工作区和暂存区</a></p><h1 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h1><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><h3 id="新文件与修改"><a href="#新文件与修改" class="headerlink" title="新文件与修改"></a>新文件与修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:37:50]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:42:02]</span></span><br><span class="line">$ touch file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:15]</span></span><br><span class="line">$ git add file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:23]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   file1.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:56:38]</span></span><br><span class="line">$ git commit -m <span class="string">"[+]add new file1.txt"</span></span><br><span class="line">[master 66cc488] [+]add new file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>add 添加修改的内容到索引</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p><code>git add .</code> ：监控工作区的状态树，此命令会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p><p><code>git add -u</code>：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写）</p><p><code>git add -A</code> ：是上面两个功能的合集（git add –all的缩写）</p><p><img src="/git-start/pasted-0.png" alt="upload successful"></p><pre><code>git show 列出最近一次的提交</code></pre><blockquote><p>对于commit：像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:24]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:25]</span></span><br><span class="line">$ git rm file1.txt</span><br><span class="line">rm <span class="string">'file1.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:30]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:32]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">deleted:    file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:40] C:128</span></span><br><span class="line">$ git commit -m <span class="string">"[-]delete file1.txt"</span></span><br><span class="line">[master e278392] [-]delete file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>git rm 删除file1.txt文件</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p>tip1: 如果没有用git rm删除文件，在本地删除文件后，git add一下再提交可以达到同样的效果</p><p>tip2: 要是你加班太晚，头晕不小心删除了不想删除的文件怎么办？见<br><a href="/git-start3/#后悔药" target="view_window">版本控制工具——Git常用操作（下）-后悔药</a></p><h2 id="拉代码"><a href="#拉代码" class="headerlink" title="拉代码"></a>拉代码</h2><h3 id="方法一-pull"><a href="#方法一-pull" class="headerlink" title="方法一 pull"></a>方法一 pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [17:01:13]</span></span><br><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:pzqu/git_test</span><br><span class="line">   5fd4d8f..7b54a8a  master     -&gt; origin/master</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 share_file.txt</span><br></pre></td></tr></table></figure><p>上图命令：</p><ul><li>git pull</li></ul><p>查看本地仓库变化<code>git log</code></p><p><img src="/git-start/git_pull.png" alt="upload successful"></p><p>上图可以看到向远程仓库pull的时候，出现了两个新的commit，<code>commit 7b54a8ae74...</code>的提交信息为<code>Create share_file.txt</code>,另一个<code>commit fdbb19cf4c51770</code>的提交信息为<code>Merge branch &#39;master&#39; of github.com:pzqu/git_test</code>。事实上主线只有一个提交，为什么会出现这种情况? 是因为pull其实会做两个操作</p><ul><li>拉远程仓库代码到本地</li><li>自动与当前分支合并并生成一个合并成功的提交</li></ul><p>注意这里的第二个个步骤如果远程有人和你改了同一个文件就会出现一个冲突，这个时候git会提示你哪些文件有冲突，手动改了再提交一次就可以了。详情见<a href="#合并冲突">合并冲突</a></p><h3 id="方法二-fetch"><a href="#方法二-fetch" class="headerlink" title="方法二 fetch"></a>方法二 fetch</h3><p>我在远程修改了文件，向<code>share_file.txt</code>加了一行内容<code>tom modify</code>，此时拉代码。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:07:21]</span></span><br><span class="line">$ git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:08:43]</span></span><br><span class="line">$ git rebase origin/master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: [+]add new file1.txt</span><br><span class="line">Applying: [-]delete file1.txt</span><br></pre></td></tr></table></figure><p></p><p>上图所示有以下两个操作</p><ul><li>fetch 拉取远端代码到本地</li><li>rebase 把本地代码提交基于远端分支重新replay</li></ul><p>效果如下：</p><p><img src="/git-start/fetch_log.png" alt="upload successful"></p><p>上图是<code>git log</code>所输出的提交内容，刚刚pull的时候忘记把pull自动产生的merge提交到远程，rebase的时候把本地的提交放到了远程提交之后，看起来就是一条直线，比较优雅，也是推荐的方式。</p><p>同样的，如果产生了冲突，详情见<a href="#合并冲突">合并冲突</a></p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>分支是多人协同最经典的地方所在，我们来创建一个分支<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu origin/master</span><br><span class="line">Branch <span class="string">'dev/pzqu'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p></p><ul><li><code>git checkout -b 分支名 其他分支</code>,<code>-b</code>代表创建并切换到新建的分支，<code>分支名</code>代表新创建的分支叫什么名字，这里叫<code>dev/pzqu</code> ，<code>其他分支</code>代表基于哪一个分支来创建，这里基于远程的master分支<code>origin/master</code>，如果省略则代表基于当前分支</li><li><code>git branch</code>展示本地的分支情况，加<code>-a</code>参数可以展示全部的分支，包括远程分支</li><li><code>*</code>在分支前，指明了现在所在的分支是<code>dev/pzqu</code></li></ul><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu2</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu2'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  dev/pzqu</span><br><span class="line">* dev/pzqu2</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">$ git checkout dev/pzqu</span><br><span class="line">Switched to branch <span class="string">'dev/pzqu'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>基于当前分支创建了一个新的分支并自动切换过去<code>dev/pzqu2</code></li><li><code>git checkout 已存在的分支名</code>切换分支回到<code>dev/pzqu</code></li></ul><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br><span class="line">  </span><br><span class="line">$ git branch -D dev/pzqu2</span><br><span class="line">Deleted branch dev/pzqu2 (was 7c9be37).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>位于<code>dev/pzqu</code>，删除了<code>dev/pzqu2</code>分支</li></ul><h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><h3 id="合并同一个分支的冲突（常见）"><a href="#合并同一个分支的冲突（常见）" class="headerlink" title="合并同一个分支的冲突（常见）"></a>合并同一个分支的冲突（常见）</h3><p>为了产生一个冲突，我在另一个地方向远程仓库提交了代码，更改<code>share_file.txt</code>文件，加了一行内容<code>tom add for merge</code>，<br>本地修改同一个文件加了一行<code>pzqu add for merge</code>，并提交到本地，这样一来，本地和远程仓库的同一个文件就不一样了，一会拉代码一定会产生一个冲突。效果如下：</p><p><img src="/git-start/merge1.png" alt="upload successful"></p><ul><li>一般rebase或pull冲突的时候，都会出现提示，然后git status会出现上图图示</li><li>这个时候不可以进行任何分支切换和commit操作，按照他提示进行处理</li><li>git status提示哪个文件是都被修改的，both modified，然后使用编辑器修改该文件，解决冲突</li><li>解决完成后，git add 添加该冲突文件</li><li>git rebase –continue，并更新commit message，完成整个rebase流程<br>我们来看看这个冲突的文件：</li></ul><p><img src="/git-start/merge2.png" alt="upload successful"></p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><p><img src="/git-start/merge3.png" alt="upload successful"></p><p><code>git add</code>再<code>git rebase --continue</code>后完成rebase，效果如下，再<code>push</code>的远程仓库即可</p><p><img src="/git-start/merge4.png" alt="upload successful"></p><h3 id="合并不同分支的代码产生冲突"><a href="#合并不同分支的代码产生冲突" class="headerlink" title="合并不同分支的代码产生冲突"></a>合并不同分支的代码产生冲突</h3><p>关于怎么创建分支与切换分支见<a href="#创建分支和切换分支">创建分支和切换分支</a>,这里只讨论合并时产生的冲突的情况，我们已经基于<code>master</code>分支创建了一个<code>dev/pzqu</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支，加一行<code>master add for merge</code>并提交，文件内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>切换到<code>dev/pzqu</code>分支，向<code>share_file.txt</code>加入一行<code>dev/pzqu add for merge</code>并提交，现在<code>share_file.txt</code>内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>现在两个分支的同一个文件内容不一样了，现在我们在<code>dev/pzqu</code>分支上进行合并：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git merge master</span><br><span class="line">Auto-merging share_file.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> share_file.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:17:31] C:1</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">=======</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</span><br></pre></td></tr></table></figure><p></p><p>上图出现了一个冲突，是我们意料之中的，修改<code>share_file.txt</code>文件，解决此冲突：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line"></span><br><span class="line">$ git add share_file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:22:40]</span></span><br><span class="line">$ git commit -m <span class="string">"[*]merge master to dev/pzqu"</span></span><br><span class="line">[dev/pzqu d9e018e] [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu o [11:23:00]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p></p><p>冲突解决也提交了，看看我们现在的分支内容：</p><p><img src="/git-start/merge_branch_devpzqu.png" alt="upload successful"></p><p>上图我们可以看到：</p><ul><li><p><code>master</code>分支比远程<code>origin/master</code>分支多一次提交，<code>dev/pzqu</code>分支由于是基于<code>origin/master</code>分支，合并了<code>master</code>分支的提交和当前<code>dev/pzqu</code>分支的提交，超出本地<code>master</code>两个提交，致此我们把<code>master</code>合并到<code>dev/pzqu</code>的操作就完成了。</p></li><li><p>通常我们开一个新的开发分支是为了在自己的分支上写代码，方便提交也不会把主线弄乱，现在我们用同样的方法将<code>dev/pzqu</code>合并到<code>master</code>分支，然后把两个分支都提交到远程。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge dev/pzqu</span><br><span class="line">Updating 58f047a..d9e018e</span><br><span class="line">Fast-forward</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line">   7c9be37..d9e018e  master -&gt; master</span><br><span class="line">   </span><br><span class="line">$ git push origin dev/pzqu</span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 887 bytes | 887.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'dev/pzqu'</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/pzqu/git_test/pull/new/dev/pzqu</span><br><span class="line">remote:</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new branch]      dev/pzqu -&gt; dev/pzqu</span><br></pre></td></tr></table></figure><ul><li>切换到<code>master</code>分支</li><li>合并<code>dev/pzqu</code>到<code>master</code>分支</li><li><code>master</code>推到远程仓库</li><li>如果<code>dev/pzqu</code>要保留，就可以推送到远程仓库。</li></ul><p><img src="/git-start/merge_branch_statuslast.png" alt="upload successful"></p><ul><li>现在我们可以看到全部的分支都在一起了，强迫症都舒服了。</li></ul><h2 id="暂存代码保存现场"><a href="#暂存代码保存现场" class="headerlink" title="暂存代码保存现场"></a>暂存代码保存现场</h2><p>这种情况一般是出现在你正在完成一个功能，但是忽然线上发现了一个Bug，必须马上开一个新的分支来修复bug，但是现在的功能没写完不打算提交(commit)，现在怎么办？？不用怕暂存代码来帮助你。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line">modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//省略操作：去创建一个Bug分支，修复他并完成与主线的合并，删除Bug分支。</span><br><span class="line">//省略操作：切回来当前分支继续开发</span><br><span class="line">//下面来恢复现场</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   share_file.txt</span><br></pre></td></tr></table></figure><p></p><ul><li><code>status</code>查看到有2个文件修改没有提交</li><li><code>stash</code>把修改放到暂存区，并生成一个id</li><li><code>stash list</code>列出暂存区所有内容</li><li><code>stash apply</code>重新把暂存区内容放到本地</li></ul><p>这里的<code>stash apply</code>成功的把暂存区的一次暂存恢复到了本地，但是暂存区还有会保存这次暂存，如果想删除这次暂存要用<code>git stash drop</code>来删除；也可以用<code>git stash pop</code>，恢复最后一次暂存的同时把stash内容也删了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (bfdc065df8adc44c8b69fa6826e75c5991e6cad0)</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>好了，暂存区清干净了。</p><pre><code>注意：要放到暂存区的文件一定要先通过git add加到index</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文阅读结束以后，我们学会了</p><ul><li>Git的基本概念，知道git的作用、历史；学会安装配置Git，使用Git创建项目托管以及工作区和暂存区的概念</li><li>学会Git的本地操作，提交、拉代码、创建切换删除分支操作，</li><li>多人合作时的代码版本控制，学会了不同情况下的合并冲突、暂存代码操作</li></ul><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>Git常用操作（下）我计划给大家介绍以下点：</p><ul><li>后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）</li><li>哎呀，提交的时候漏了文件</li><li>tag操作</li><li>git忽略不想提交的文件</li></ul><p>下集传送门：<br><a href="/git-start3" target="view_window">版本控制工具——Git常用操作（下）</a></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://www.qupzhi.com/categories/git/"/>
    
    
      <category term="工具" scheme="http://www.qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="版本控制" scheme="http://www.qupzhi.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git教程" scheme="http://www.qupzhi.com/tags/git%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>mysql备份还原方案xtrabackup</title>
    <link href="http://www.qupzhi.com/mysql-backup-xtrabackup/"/>
    <id>http://www.qupzhi.com/mysql-backup-xtrabackup/</id>
    <published>2018-12-01T02:59:00.000Z</published>
    <updated>2018-12-12T06:51:59.202Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：mysql当数据库过大的时候，使用mysqldump的方式进行备份是一种非常慢的操作，500G的数据就够你备份一天一夜，我发现了一种mysql快速备份的方案，它使用文件存储的方式进行备份，支持全量和增量备份，这里所写为全量方式（如果可以接受备份开始到下次恢复之间的数据丢失时使用）。xtrabackup的备份速度很快，不管有多少的数据，备份速度完全是依赖于磁盘的读写速度，还支持压缩、不打断正在执行的事务、自动实现备份检验（用mysqldump会锁表，要加上可重复读–single-transaction才不会影响线上的程序写表，但是写表后的东西在还原的时候就会丢了，这也是全量备份的痛点）</p><a id="more"></a><ul><li><a href="#特点">特点</a></li><li><a href="#准备mysql备份组件需要的安装包">准备mysql备份组件需要的安装包</a></li><li><a href="#安装备份工具">安装备份工具</a><ul><li><a href="#1-上传并解压">1. 上传并解压</a></li><li><a href="#2-安装rpm包">2. 安装rpm包</a></li><li><a href="#3-检查是否安装成功">3. 检查是否安装成功</a></li></ul></li><li><a href="#开始备份">开始备份</a><ul><li><a href="#1-执行命令开始备份">1. 执行命令开始备份</a></li><li><a href="#2-检查是否备份成功">2. 检查是否备份成功</a></li></ul></li><li><a href="#还原备份">还原备份</a><ul><li><a href="#1-事务日志应用到备份">1. 事务日志应用到备份</a></li><li><a href="#2-恢复数据">2. 恢复数据</a></li><li><a href="#3-设置属主属组为mysql并启动">3. 设置属主属组为mysql并启动</a></li></ul></li><li><a href="#引用">引用</a></li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>(1)备份过程快速、可靠</p><p>(2)备份过程不会打断正在执行的事务</p><p>(3)能够基于压缩等功能节约磁盘空间和流量</p><p>(4)自动实现备份检验</p><p>(5)还原速度快</p><h1 id="准备mysql备份组件需要的安装包"><a href="#准备mysql备份组件需要的安装包" class="headerlink" title="准备mysql备份组件需要的安装包"></a>准备mysql备份组件需要的安装包</h1><p>检查服务器是centos6版本还是centos7+版本。选择安装包<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos6/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</span><br><span class="line">centos7/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el7-x86_64-bundle.tar</span><br></pre></td></tr></table></figure><p></p><p>安装包可以在此下载 ： <a href="https://www.percona.com/downloads/XtraBackup/LATEST/" target="_blank" rel="noopener">https://www.percona.com/downloads/XtraBackup/LATEST/</a></p><h1 id="安装备份工具"><a href="#安装备份工具" class="headerlink" title="安装备份工具"></a>安装备份工具</h1><p><font color="red">以下所有操作如果是在集群下，要在一个主节点上操作，操作一次即可</font>，启动时设置主节点为被同步节点，集群的管理我们以后再讨论。</p><h2 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1. 上传并解压"></a>1. 上传并解压</h2><p>假设当前系统是centos6+,使用<code>Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</code>包，拷贝到系统<code>/tmp/backup_mariadb20181127</code>目录下(没有则创建,日期写当天)，使用<code>tar xvf Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</code>命令解压,你可以得到以下文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pwd</span><br><span class="line">/tmp/backup_mariadb20181127</span><br><span class="line"># ls</span><br><span class="line">Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</span><br><span class="line">percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line">percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  </span><br><span class="line">percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="2-安装rpm包"><a href="#2-安装rpm包" class="headerlink" title="2. 安装rpm包"></a>2. 安装rpm包</h2><p>执行以下命令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  </span><br><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p></p><h2 id="3-检查是否安装成功"><a href="#3-检查是否安装成功" class="headerlink" title="3. 检查是否安装成功"></a>3. 检查是否安装成功</h2><p>按以下显示则安装成功<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -qa | grep percona</span></span><br><span class="line">percona-xtrabackup-test-24-2.4.12-1.el6.x86_64</span><br><span class="line">percona-xtrabackup-24-2.4.12-1.el6.x86_64</span><br><span class="line">percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64</span><br></pre></td></tr></table></figure><p></p><h1 id="开始备份"><a href="#开始备份" class="headerlink" title="开始备份"></a>开始备份</h1><h2 id="1-执行命令开始备份"><a href="#1-执行命令开始备份" class="headerlink" title="1. 执行命令开始备份"></a>1. 执行命令开始备份</h2><p>执行以下命令开始备份，其中<code>/etc/my.cnf</code>为mysql配置文件位置，10.123.2.4为mysql绑定的ip（写当前机器的ip）,user1为用户名，123456Abc为密码，/tmp/backup_mariadb20181127为备份文件所在目录，所有按实际环境填写。此处我们只备份cloud库所以<code>--databases</code>库就不用改动了<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --defaults-file=/etc/my.cnf --host=10.123.2.4 --databases="cloud" --use-memory=500M --user=user1 --password=123456Abc /tmp/backup_mariadb20181127</span><br></pre></td></tr></table></figure><p></p><ul><li>如果只需要备份其中一个或多个数据库，可以加参数<code>--databases=&quot;cloud test&quot;</code>,其中cloud和test是库名</li><li>可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。</li></ul><h2 id="2-检查是否备份成功"><a href="#2-检查是否备份成功" class="headerlink" title="2. 检查是否备份成功"></a>2. 检查是否备份成功</h2><p>最后一行显示completed OK！ 则备份成功，在所执行的目录下（此处是/tmp/backup_mariadb20181127）会出现备份的文件<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">181127 11:56:48 completed OK!</span><br></pre></td></tr></table></figure><p></p><p>可以看到文件结构，我们此处自动生成的备份文件夹名为<code>2018-11-27_11-52-48</code>，是一个以时间命名的文件夹<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">2018-11-27_11-52-48</span><br><span class="line"> Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar  percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm  percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/backup_mariadb20181127</span><br></pre></td></tr></table></figure><p></p><h1 id="还原备份"><a href="#还原备份" class="headerlink" title="还原备份"></a>还原备份</h1><h2 id="1-事务日志应用到备份"><a href="#1-事务日志应用到备份" class="headerlink" title="1. 事务日志应用到备份"></a>1. 事务日志应用到备份</h2><p>备份出的数据并不能直接使用，因为备份出的数据是不一致的，我们还需要将同时备份出的事务日志应用到备份中，才能得到一份完整、一致、可用的数据，xtrabackup称这一步操作为prepare，也就是还原数据前的”准备”工作。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --apply-log 2018-11-27_11-52-48/</span><br></pre></td></tr></table></figure><p></p><p>在事务日志容量很大的情况下，可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。<br>输出最后如下就为正确<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">181127 11:56:10 completed OK!</span><br></pre></td></tr></table></figure><p></p><h2 id="2-恢复数据"><a href="#2-恢复数据" class="headerlink" title="2. 恢复数据"></a>2. 恢复数据</h2><p>方法一、此处使用该方法，适用于备份部分数据库的方法<br>数据目录在<code>/data/mariadb/data</code>，我们备份的数据库为cloud库。<br>进入mysql命令行<code>mysql -A</code>，删除cloud库<code>drop database cloud;</code>(如果无法进入命令行则到数据目录下直接干掉cloud文件夹，集群操作的话必须通过drop或者先停止集群，确定好主从模式)<br>执行命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/mariadb/data</span><br><span class="line">rm ib* -f</span><br><span class="line">rm -f cloud</span><br><span class="line">/etc/init.d/mysqld stop <span class="comment">#关闭数据库</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/backup_mariadb20181127/2018-11-27_11-52-48 <span class="comment">#进入备份目录</span></span><br><span class="line">cp ib* /data/mariadb/data</span><br><span class="line">cp -R cloud /data/mariadb/data</span><br></pre></td></tr></table></figure><p></p><p>方法二、先停止数据库服务<code>/etc/init.d/mysqld stop</code>，且对应的数据目录(此处是<code>/data/mariadb/data</code>)为空,如果不为空，手动删除，一般此方法针对全量备份的方法。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex  --datadir=/data/mariadb/data --copy-back /tmp/backup_mariadb20181127/2018-11-27_11-52-48</span><br></pre></td></tr></table></figure><p></p><p>–copy-back：对应的目录就是我们准备好的可用数据的目录。此处为<code>/tmp/backup_mariadb20181127/2018-11-27_11-52-48</code></p><p>–datadir：指定的目录就是还原后数据要存放的目录，如果my.cnf设置了datadir，可以省略–datadir，执行copyback时会读取my.cnf中的配置，datadir目录必须为空目录,如果不为空，手动删除。</p><h2 id="3-设置属主属组为mysql并启动"><a href="#3-设置属主属组为mysql并启动" class="headerlink" title="3. 设置属主属组为mysql并启动"></a>3. 设置属主属组为mysql并启动</h2><p>此时我们还不能启动mysql，因为我们是使用root用户拷贝的数据，所以数据目录中的数据文件的属主属组仍然为root，我们需要将这些文件的属主属组设置为mysql。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/mariadb/data</span><br><span class="line">chown -R mysql.mysql *</span><br><span class="line">chown -R mysql.mysql /data/mariadb/binlog</span><br><span class="line">/etc/inid.d/mysqld start</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="http://www.cnblogs.com/zhoujinyi/p/4088866.html" target="_blank" rel="noopener">Xtrabackup 安装使用</a><br><a href="https://blog.csdn.net/fanren224/article/details/79693863" target="_blank" rel="noopener">xtrabackup 原理</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：mysql当数据库过大的时候，使用mysqldump的方式进行备份是一种非常慢的操作，500G的数据就够你备份一天一夜，我发现了一种mysql快速备份的方案，它使用文件存储的方式进行备份，支持全量和增量备份，这里所写为全量方式（如果可以接受备份开始到下次恢复之间的数据丢失时使用）。xtrabackup的备份速度很快，不管有多少的数据，备份速度完全是依赖于磁盘的读写速度，还支持压缩、不打断正在执行的事务、自动实现备份检验（用mysqldump会锁表，要加上可重复读–single-transaction才不会影响线上的程序写表，但是写表后的东西在还原的时候就会丢了，这也是全量备份的痛点）&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.qupzhi.com/categories/mysql/"/>
    
    
      <category term="备份mysql数据库" scheme="http://www.qupzhi.com/tags/%E5%A4%87%E4%BB%BDmysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql教程" scheme="http://www.qupzhi.com/tags/mysql%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq管理利器——rabbitmqadmin</title>
    <link href="http://www.qupzhi.com/rabbitmqadmin/"/>
    <id>http://www.qupzhi.com/rabbitmqadmin/</id>
    <published>2018-11-21T05:50:19.000Z</published>
    <updated>2018-12-11T13:03:46.714Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：在运维rabbitmq集群的过程中，发生了队列的严重堆积，我们在可以容忍mq消息丢失的情况下，使用常用的<code>purge_queue queue</code>命令等好长时间都清理不成功，在管理页面上直接purge导致页面卡住不动，最终都没有办法达到清理成功的效果。这个时候发现了一个python的rabbitmq管理工具，非常的好用且迅速，在此记录。</p><a id="more"></a><ul><li><a href="#如何获取rabbitmqadmin">如何获取rabbitmqadmin</a></li><li><a href="#常用命令">常用命令</a><ul><li><a href="#查看">查看</a></li><li><a href="#系统操作">系统操作</a></li><li><a href="#用户管理操作">用户管理操作</a></li><li><a href="#队列操作">队列操作</a></li></ul></li><li><a href="#其他">其他</a><ul><li><a href="#指定输出格式">指定输出格式</a></li><li><a href="#用户角色">用户角色</a></li><li><a href="#rabbitmqctl-命令">rabbitmqctl 命令</a></li></ul></li><li><a href="#参考">参考</a></li></ul><h1 id="如何获取rabbitmqadmin"><a href="#如何获取rabbitmqadmin" class="headerlink" title="如何获取rabbitmqadmin"></a>如何获取rabbitmqadmin</h1><p><strong>方法1.</strong> 直接复制出来<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cp -a /var/lib/rabbitmq/mnesia/rabbit@localhost-plugins-expand/rabbitmq_management-3.3.5/priv/www/cli/rabbitmqadmin /usr/local/bin/rabbitmqadmin</span><br><span class="line">``` </span><br><span class="line">**方法2** 从管理页面获取</span><br><span class="line"></span><br><span class="line">1. 打开`rabbitmq_management`，访问15672管理页面，方法见&lt;a href="https://qupzhi.com/first-blog" target="_blank"&gt;rabbitmq集群的各种运维操作 4.2 打开15672网页管理端，访问mq  &lt;/a&gt;</span><br><span class="line">2. 访问 ip:15672/rabbitmqadmin</span><br><span class="line">下载页面，另存为`rabbitmqadmin.py`,放到此目录：`/usr/local/bin/rabbitmqadmin`，授权`chmod +x /usr/local/bin/rabbitmqadmin`</span><br><span class="line"></span><br><span class="line">多一句废话：可以使用wget直接下载页面上的东西</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看</span></span></span><br><span class="line">```bash</span><br><span class="line">rabbitmqadmin list users                #查看用户列表</span><br><span class="line">rabbitmqadmin list vhosts               #查看vhosts</span><br><span class="line">rabbitmqadmin list connections          ###查看 connections</span><br><span class="line">rabbitmqadmin list exchanges            ##查看 exchanges</span><br><span class="line">rabbitmqadmin list bindings             ##查看 bindings</span><br><span class="line">rabbitmqadmin list permissions          ##查看 permissions</span><br><span class="line">rabbitmqadmin list channels             ##查看 channels</span><br><span class="line">rabbitmqadmin list parameters           ##查看 parameters</span><br><span class="line">rabbitmqadmin list consumers            ##查看consumers</span><br><span class="line">rabbitmqadmin list queues               ##查看queues</span><br><span class="line">rabbitmqadmin list policies             ##查看policies</span><br><span class="line">rabbitmqadmin list nodes                ##查看nodes</span><br><span class="line">rabbitmqadmin show overview             ##查看overview</span><br></pre></td></tr></table></figure><p></p><h2 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h2><h2 id="用户管理操作"><a href="#用户管理操作" class="headerlink" title="用户管理操作"></a>用户管理操作</h2><ol><li><p>新增一个用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  add_user  Username  Password</span><br><span class="line">rabbitmqadmin declare user name=wyl password=password tags=administrator</span><br></pre></td></tr></table></figure></li><li><p>删除一个用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  delete_user  Username</span><br></pre></td></tr></table></figure></li><li><p>修改用户的密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  change_password  Username  Newpassword</span><br></pre></td></tr></table></figure></li><li><p>查看当前用户列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  list_users</span><br><span class="line">rabbitmqadmin list users    # 查看 users</span><br><span class="line">rabbitmqadmin list users name # 查看 users的时候限制字段</span><br></pre></td></tr></table></figure></li><li><p>设置用户角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  User  Tag</span><br></pre></td></tr></table></figure></li></ol><p>User为用户名， Tag为角色名(对应于<code>administrator，monitoring，policymaker，management</code>，或其他自定义名称见<a href="#用户角色">用户角色</a>)。<br>也可以给同一用户设置多个角色，例如<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  hncscwc  monitoring policymaker</span><br></pre></td></tr></table></figure><p></p><h2 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h2><p>添加queue<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin <span class="built_in">declare</span> queue name=<span class="built_in">test</span> durable=<span class="literal">true</span>    <span class="comment">## durable=true 代表持久化打开  declare是宣布的意思</span></span><br><span class="line">rabbitmqadmin --vhost=<span class="built_in">test</span> --username=admin --password=admin  <span class="built_in">declare</span> queue name=<span class="built_in">test</span> durable=<span class="literal">true</span> <span class="comment">#指定vhost添加队列</span></span><br></pre></td></tr></table></figure><p></p><p>查看queues<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list queues</span></span><br><span class="line"><span class="comment">#查看bindings</span></span><br><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list bindings</span></span><br></pre></td></tr></table></figure><p></p><p>添加消息到test queue<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin publish routing_key=<span class="built_in">test</span> payload=<span class="string">"this is a testing"</span>     <span class="comment">##未指定exchange默认 exchange name为空</span></span><br></pre></td></tr></table></figure><p></p><p>再次查看对列发现test有一条消息<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list queues</span></span><br></pre></td></tr></table></figure><p></p><p>从test queue消费一条信息<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin get queue=<span class="built_in">test</span> requeue=<span class="literal">true</span>   <span class="comment">#requeue=true 这条消息消费后还在，反之如果为false消费后消息就不在了。</span></span><br></pre></td></tr></table></figure><p></p><p>删除队列<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin delete queue name=<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>清除队列消息内容<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin purge queue name=队列名</span><br></pre></td></tr></table></figure><p></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="指定输出格式"><a href="#指定输出格式" class="headerlink" title="指定输出格式"></a>指定输出格式</h2><p>使用 -f 可以指定格式<br>有如下几种格式 raw_json, long, pretty_json, kvp, tsv, table, bash 默认为 table,具体自己试</p><h2 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h2><ol><li>超级管理员(administrator)<br>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>监控者(monitoring)<br>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li>策略制定者(policymaker)<br>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。<br>与administrator的对比，administrator能看到这些内容</li><li>普通管理者(management)<br>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</li><li>其他<br>无法登陆管理控制台，通常就是普通的生产者和消费者。<br>了解了这些后，就可以根据需要给不同的用户设置不同的角色，以便按需管理。</li></ol><h2 id="rabbitmqctl-命令"><a href="#rabbitmqctl-命令" class="headerlink" title="rabbitmqctl 命令"></a>rabbitmqctl 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_queues：查看所有队列信息</span><br><span class="line"></span><br><span class="line">rabbitmqctl stop_app：关闭应用（关闭当前启动的节点）</span><br><span class="line"></span><br><span class="line">rabbitmqctl start_app：启动应用，和上述关闭命令配合使用，达到清空队列的目的</span><br><span class="line"></span><br><span class="line">rabbitmqctl reset：从管理数据库中移除所有数据，例如配置过的用户和虚拟宿主, 删除所有持久化的消息（这个命令要在rabbitmqctl stop_app之后使用）</span><br><span class="line"></span><br><span class="line">rabbitmqctl force_reset：作用和rabbitmqctl reset一样，区别是无条件重置节点，不管当前管理数据库状态以及集群的配置。如果数据库或者集群配置发生错误才使用这个最后的手段</span><br><span class="line"></span><br><span class="line">rabbitmqctl status：节点状态</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_user username password：添加用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_users：列出所有用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_user_permissions username：列出用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl change_password username newpassword：修改密码</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_vhost vhostpath：创建虚拟主机</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_vhosts：列出所有虚拟主机</span><br><span class="line"></span><br><span class="line">rabbitmqctl set_permissions -p vhostpath username ".*" ".*" ".*"：设置用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_permissions -p vhostpath：列出虚拟主机上的所有权限 </span><br><span class="line"></span><br><span class="line">rabbitmqctl clear_permissions -p vhostpath username：清除用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息</span><br><span class="line"></span><br><span class="line">rabbitmqctl delete_user username：删除用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl delete_vhost vhostpath：删除虚拟主机</span><br></pre></td></tr></table></figure><p>未完待续-催更 <a href="mailto:pzqu@qq.com" target="_blank" rel="noopener">pzqu@qq.com</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/wylfengyujiancheng/article/details/67063083b" target="_blank" rel="noopener">通过rabbitmqadmin管理rabbitmq,【吴业亮】云计算开发工程师</a></p><p><a href="https://www.cnblogs.com/wuzhiyuan/p/6856985.html" target="_blank" rel="noopener">RabbitMQ学习笔记四：RabbitMQ命令（附疑难问题解决）</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：在运维rabbitmq集群的过程中，发生了队列的严重堆积，我们在可以容忍mq消息丢失的情况下，使用常用的&lt;code&gt;purge_queue queue&lt;/code&gt;命令等好长时间都清理不成功，在管理页面上直接purge导致页面卡住不动，最终都没有办法达到清理成功的效果。这个时候发现了一个python的rabbitmq管理工具，非常的好用且迅速，在此记录。&lt;/p&gt;
    
    </summary>
    
      <category term="rabbitmq" scheme="http://www.qupzhi.com/categories/rabbitmq/"/>
    
    
      <category term="rabbitmq集群" scheme="http://www.qupzhi.com/tags/rabbitmq%E9%9B%86%E7%BE%A4/"/>
    
      <category term="工具" scheme="http://www.qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="rabbitmq工具" scheme="http://www.qupzhi.com/tags/rabbitmq%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq之Federation配置</title>
    <link href="http://www.qupzhi.com/rabbitmq-federation/"/>
    <id>http://www.qupzhi.com/rabbitmq-federation/</id>
    <published>2018-11-18T07:26:31.000Z</published>
    <updated>2018-12-11T13:00:09.881Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：当我们有多个rabbitmq集群的时候，如果想要单向的同步集群的消息，也就是说把新集群当作老集群的镜像集群，实时的同步老集群的消息，在老集群消息被消费的时候不会影响同步到新集群的消息。在外部看上去就像每次写入消息的时候，同时向新老两个集群写入一样,不论mq的跨版本，不论mq的用户。一般我们会将这种情况应用于存在两个不同的系统，但是老数据来源只能向一个队列写入数据，此时为了在新系统上也可以实时同步到老系统队列中的数据的时候。</p><a id="more"></a><ul><li><a href="#federation介绍">Federation介绍</a><ul><li><a href="#特点">特点</a><ul><li><a href="#松耦合性loose-coupling">松耦合性（Loose coupling）</a></li><li><a href="#wan-友好性wan-friendly">WAN 友好性（WAN-friendly）</a></li><li><a href="#扩展性scalability">扩展性（Scalability）</a></li></ul></li><li><a href="#federation能做什么">federation能做什么？</a></li><li><a href="#配置的种类">配置的种类</a></li><li><a href="#身份验证">身份验证</a></li></ul></li><li><a href="#操作步骤说明">操作步骤说明</a><ul><li><a href="#1-在集群的每一个node开启federation插件同步和被同步集群都需要">1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)</a></li><li><a href="#2-登录到同步集群的管理界面httpxxx15672">2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/</a></li><li><a href="#3-创建upstream">3. 创建upstream</a></li><li><a href="#4-创建policy">4. 创建policy</a></li><li><a href="#5-查看状态图">5. 查看状态图</a></li><li><a href="#6-查看连接">6. 查看连接</a></li></ul></li><li><a href="#高级">高级</a></li><li><a href="#参考">参考</a></li></ul><h1 id="Federation介绍"><a href="#Federation介绍" class="headerlink" title="Federation介绍"></a>Federation介绍</h1><blockquote><p>federation 插件的最终目标是，在不同 broker 之间进行消息传递而无需建立集群；该功能在很多场景下非常有用：</p></blockquote><p><strong>注意:当你在一个cluster中使用federation插件，所有在集群中 的nodes都需要安装federation插件</strong></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="松耦合性（Loose-coupling）"><a href="#松耦合性（Loose-coupling）" class="headerlink" title="松耦合性（Loose coupling）"></a>松耦合性（Loose coupling）</h3><ul><li>federation 插件能够在分属不同管理域的 broker 或 cluster 之间传递消息：</li><li>他们可能设置了不同的 user 和 vhost ；</li><li>他们可能运行在不同版本的 RabbitMQ 和 Erlang 上；</li></ul><h3 id="WAN-友好性（WAN-friendly）"><a href="#WAN-友好性（WAN-friendly）" class="headerlink" title="WAN 友好性（WAN-friendly）"></a>WAN 友好性（WAN-friendly）</h3><ul><li>federation 插件基于 AMQP 0-9-1 协议在不同 broker 之间进行通信，并设计成能够容忍不稳定的网络连通情况；</li></ul><h3 id="扩展性（Scalability）"><a href="#扩展性（Scalability）" class="headerlink" title="扩展性（Scalability）"></a>扩展性（Scalability）</h3><ul><li>federation 不需要在 n 个 broker 之间建立 O(n^2) 个连接（尽管这是最简单的使用模式），这也就意味着 federation 在使用时更容易扩展</li></ul><h2 id="federation能做什么？"><a href="#federation能做什么？" class="headerlink" title="federation能做什么？"></a>federation能做什么？</h2><blockquote><p>federation 插件允许你将多个 exchange 或多个 queue 进行 federate ；federated exchange 或 federated queue 能够从一个或多个 upstream 接收到消息；</p></blockquote><p>也就是说，你的队列可以和其他集群的队列建立一种关系，他们之间可以相互的同步数据，可以是我同步给你，也可以是你同步给我，不过这种关系有两个角色一个是上游一个是下游，数据流向是上游流向下流。<br>这里有三个名词，federation 插件允许你将多个 exchange 或多个 queue 进行 federate：</p><ul><li>upstream： 上游，是指位于其他 broker 上的、远端 exchange 和 queue ；</li><li>federated exchange： 到exchange的关系，能够将发给 upstream 的消息路由到本地的某个 queue 中；</li><li>federated queue： 到queue的关系，则允许一个本地消费者接收到来自 upstream queue 的消息；</li></ul><h2 id="配置的种类"><a href="#配置的种类" class="headerlink" title="配置的种类"></a>配置的种类</h2><p>关于 federation upstream 的信息全都保存在 RabbitMQ 的数据库中，其中包括了 user 信息、permission 信息、queue 信息等等；<br>在 federation 中存在 3 种界别的配置：</p><ul><li>Upstreams - 每一个 upstream 用于定义如何与另外的 broker 建立连接；</li><li>Upstream sets - 每一个 upstream set 用于针对一系列使用 federation 功能 upstream 进行了分组；</li><li>Policies - 每一种 policy 会限定（过滤）出一组 exchange ，或者一组 queue ，或者同时针对两者进行限定；policy 最终将作用于一个单独的 upstream 上，或者一个 upstream set 上，并对其他对象发挥作用；</li></ul><p><em>实际上，在最简单的使用情况下，你可以忽略已经存在的upstream设置，因为有一个隐含的默认upstream叫做“all”，他会添加所有的upstream。</em></p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>我们讨论的是免身份验证的方式，如果有身份难的需求请参考官网：<a href="http://www.rabbitmq.com/authentication.html" target="_blank" rel="noopener">http://www.rabbitmq.com/authentication.html</a></p><h1 id="操作步骤说明"><a href="#操作步骤说明" class="headerlink" title="操作步骤说明"></a>操作步骤说明</h1><blockquote><p>parameter 和 policy 可以通过 3 种方式进行设置：<br>通过 rabbitmqctl 脚本；<br>通过 management 插件提供的 HTTP API ；<br>通过 rabbitmq_federation_management 插件提供的 Web UI（更通用的方式,我们也是通过页面来配置就可以了）；注意：基于 Web UI 的方式不能提供全部功能，尤其无法针对 upstream set 进行管理；</p></blockquote><h2 id="1-在集群的每一个node开启federation插件-同步和被同步集群都需要"><a href="#1-在集群的每一个node开启federation插件-同步和被同步集群都需要" class="headerlink" title="1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)"></a>1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)</h2><p>参考命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></table></figure><p></p><h2 id="2-登录到同步集群的管理界面-http-x-x-x-15672"><a href="#2-登录到同步集群的管理界面-http-x-x-x-15672" class="headerlink" title="2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/"></a>2. 登录到同步集群的管理界面::<a href="http://x.x.x.:15672/#/" target="_blank" rel="noopener">http://x.x.x.:15672/#/</a></h2><h2 id="3-创建upstream"><a href="#3-创建upstream" class="headerlink" title="3. 创建upstream"></a>3. 创建upstream</h2><p>tips:在下游，也就是新队列（被同步队列）上操作</p><p><img src="/rabbitmq-federation/upstream.png" alt="upstrem"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin-&gt;Federation Upstreams-&gt;Add a new upstream Name:随意填写 URI:填被同步集群(例如:amqp://user1:xxx@x.x.x.x,xxx为连接密码) Expires:默认填写3600000 单位ms</span><br><span class="line">其余字段可不用填写</span><br></pre></td></tr></table></figure><p><strong>Expires</strong>：是代表缓存时间，如果说网络连通性不好的时候，消息会在上游的队列中缓存的时间，超时丢弃，设置为空则表示，永远缓存不会丢弃数据（但是如果长时候不恢复内存会占用越来越大，建议设置上）<br><strong>Acknowledgement Mode</strong>: 代表消息确认方式，用来防止消息在传输过程中丢失，有三个值，on-confirm、on-publish、no-ack，对传输速度的影响是从慢速到快速，对安全性是不会丢失到可能会丢失。通常使用<code>on-publish</code>，不然<code>on-confirm</code>太慢了。</p><h2 id="4-创建policy"><a href="#4-创建policy" class="headerlink" title="4. 创建policy"></a>4. 创建policy</h2><p>tips:在下游，也就是新队列（被同步队列）上操作<br><img src="/rabbitmq-federation/policy.png" alt="policy"><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin-&gt;Policies-&gt;Add / update a policy</span><br><span class="line">Name:随意填写(sync_data)</span><br><span class="line">Pattern:匹配表达式(例如:^(?!amq.).* 剔除系统队列后的所有队列)</span><br><span class="line">Apply to: 默认选择Exchange and queues Definition:federation-upstream-set = all (选定federation规则)</span><br></pre></td></tr></table></figure><p></p><h2 id="5-查看状态图"><a href="#5-查看状态图" class="headerlink" title="5. 查看状态图"></a>5. 查看状态图</h2><p>现在，所有内置的 exchange 都应该建立了 federation ，因为他们都能匹配上面的 policy，可以通过页面查看状态<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin &gt; Federation Status &gt; Running Links 查看针对每个 exchange 的 federation 连接。</span><br><span class="line">配置成功可以看到匹配的Exchange / Queue， state:running</span><br></pre></td></tr></table></figure><p></p><p>也可以通过下面的命令查看状态图：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl eval 'rabbit_federation_status:status().'</span><br></pre></td></tr></table></figure><p></p><p>也可以通过 management 插件中的 exchange 列表，或者下面的命令输出，确认上述 policy 已经作用到了 exchange 上；<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_exchanges name policy | grep federate-me</span><br></pre></td></tr></table></figure><p></p><p>通常情况下，针对每个 upstream 都会有一条 federation 连接，该 federation 连接对应到一个 exchange 上；例如 3 个 exchange 与 2 个 upstream 分别建立 federation 的情况下，会有 6 条连接。</p><h2 id="6-查看连接"><a href="#6-查看连接" class="headerlink" title="6. 查看连接"></a>6. 查看连接</h2><pre><code>登录到被同步集群（上游）的管理界面::http://x.x.x.:15672/#/ 前往 Connections选项 配置成功可以看到来自同步集群的连接</code></pre><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>更复杂的配置：<a href="https://www.rabbitmq.com/federation-reference.html" target="_blank" rel="noopener">https://www.rabbitmq.com/federation-reference.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.rabbitmq.com/federation.html" target="_blank" rel="noopener">官网</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：当我们有多个rabbitmq集群的时候，如果想要单向的同步集群的消息，也就是说把新集群当作老集群的镜像集群，实时的同步老集群的消息，在老集群消息被消费的时候不会影响同步到新集群的消息。在外部看上去就像每次写入消息的时候，同时向新老两个集群写入一样,不论mq的跨版本，不论mq的用户。一般我们会将这种情况应用于存在两个不同的系统，但是老数据来源只能向一个队列写入数据，此时为了在新系统上也可以实时同步到老系统队列中的数据的时候。&lt;/p&gt;
    
    </summary>
    
      <category term="rabbitmq" scheme="http://www.qupzhi.com/categories/rabbitmq/"/>
    
    
      <category term="rabbitmq集群" scheme="http://www.qupzhi.com/tags/rabbitmq%E9%9B%86%E7%BE%A4/"/>
    
      <category term="rabbitmq教程" scheme="http://www.qupzhi.com/tags/rabbitmq%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ansible_roles</title>
    <link href="http://www.qupzhi.com/ansible-roles/"/>
    <id>http://www.qupzhi.com/ansible-roles/</id>
    <published>2018-09-27T05:12:09.000Z</published>
    <updated>2018-11-19T02:28:41.913Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：本节主要总结ansiblerroles中常用的语法以及高级特性、例如变量、下载、解压、修改文件内容等,便于使用ansible协同开发，做更加庞大的任务。</p><a id="more"></a><ul><li><a href="#常用">常用</a><ul><li><a href="#远程执行脚本">远程执行脚本</a></li><li><a href="#设置某个参数供下文使用">设置某个参数供下文使用</a></li><li><a href="#文件是否存在和变量是否声明">文件是否存在和变量是否声明</a></li><li><a href="#解压">解压</a></li><li><a href="#下载">下载</a></li><li><a href="#修改文件内容直接替换方式">修改文件内容，直接替换方式</a></li><li><a href="#配置文件">配置文件</a></li><li><a href="#执行命令时指定脚本执行目录">执行命令时指定脚本执行目录</a></li></ul></li><li><a href="#高级">高级</a><ul><li><a href="#委托">委托</a></li></ul></li><li><a href="#统一目录结构">统一目录结构</a></li><li><a href="#引用">引用</a></li></ul><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="远程执行脚本"><a href="#远程执行脚本" class="headerlink" title="远程执行脚本"></a>远程执行脚本</h2><ol><li><p>脚本放到template里</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">init</span> <span class="string">rbac</span> <span class="string">rights</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">'init_rbac_privilege.sh'</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">'/tmp/init_rbac_privilege.sh'</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">init</span> <span class="string">rbac</span> <span class="string">rights</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"bash /tmp/init_rbac_privilege.sh"</span></span><br><span class="line"><span class="attr">  run_once:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></li><li><p>脚本放files文件里</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">copy</span> <span class="string">script</span> <span class="string">file</span> <span class="string">to</span> <span class="string">remote</span> <span class="string">server</span></span><br><span class="line"><span class="attr">  copy:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"generate_uuid.py"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">and</span> <span class="string">args</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"python <span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="设置某个参数供下文使用"><a href="#设置某个参数供下文使用" class="headerlink" title="设置某个参数供下文使用"></a>设置某个参数供下文使用</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">path</span></span><br><span class="line"><span class="attr">  set_fact:</span></span><br><span class="line"><span class="attr">    dest_script_file:</span> <span class="string">'/tmp/generate_uuid.py'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">copy</span> <span class="string">script</span> <span class="string">file</span> <span class="string">to</span> <span class="string">remote</span> <span class="string">server</span></span><br><span class="line"><span class="attr">  copy:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"generate_uuid.py"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br></pre></td></tr></table></figure><h2 id="文件是否存在和变量是否声明"><a href="#文件是否存在和变量是否声明" class="headerlink" title="文件是否存在和变量是否声明"></a>文件是否存在和变量是否声明</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- stat:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">file_result</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">and</span> <span class="string">args</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"python <span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span> <span class="template-variable">&#123;&#123; inventory_hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">p_new_host_uuid</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">host_uuid</span> <span class="string">is</span> <span class="string">not</span> <span class="string">defined</span> <span class="string">and</span> <span class="string">file_result.stat.exists</span></span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>解压tar.gz，desc所指定的目录需要提前创建<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Unarchive</span> <span class="string">ceph_report</span> <span class="string">program</span> <span class="string">package</span></span><br><span class="line"><span class="attr">  unarchive:</span></span><br><span class="line"><span class="attr">    remote_src:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"/tmp/ceph_report/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/data/monitorcloud/script/"</span></span><br></pre></td></tr></table></figure><p></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">download</span> <span class="string">ceph_report</span> <span class="string">package</span></span><br><span class="line"><span class="attr">  get_url:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"http://<span class="template-variable">&#123;&#123; tstack_repo_address &#125;&#125;</span>:<span class="template-variable">&#123;&#123; tstack_repo_port &#125;&#125;</span>/tstack/tstack-tars/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/tmp/ceph_report/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0644</span></span><br></pre></td></tr></table></figure><h2 id="修改文件内容，直接替换方式"><a href="#修改文件内容，直接替换方式" class="headerlink" title="修改文件内容，直接替换方式"></a>修改文件内容，直接替换方式</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">insert</span> <span class="string">mons</span> <span class="string">connect</span> <span class="string">message</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">"/data/monitorcloud/script/ceph_report/host_dic"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">EOF</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">"<span class="template-variable">&#123;&#123;item[0]&#125;&#125;</span> <span class="template-variable">&#123;&#123;item[1]&#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_nested:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; groups['mons'] | union( groups['osds'] )&#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">["&#123;&#123;ansible_ssh_pass&#125;&#125;"]</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>ansible中指定配置文件，.j2中可映射ansible变量<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Prepare</span> <span class="string">ceph_report_http</span> <span class="string">program</span> <span class="string">configuration</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"opts.py.j2"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/data/monitorcloud/script/ceph_report/opts.py"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0644</span></span><br></pre></td></tr></table></figure><p></p><h2 id="执行命令时指定脚本执行目录"><a href="#执行命令时指定脚本执行目录" class="headerlink" title="执行命令时指定脚本执行目录"></a>执行命令时指定脚本执行目录</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">execute</span> <span class="string">ceph_report_http</span> <span class="string">install</span> <span class="string">script</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"/usr/bin/python  ceph_report_http.py install"</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="attr">     chdir:</span> <span class="string">'/data/monitorcloud/script/ceph_report/'</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>在当前运行ansible的机器上，委托其他机器运行<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">host</span> <span class="string">record</span> <span class="string">to</span> <span class="string">center</span> <span class="string">server</span> </span><br><span class="line"><span class="attr"> shell:</span> <span class="string">'echo "192.168.1.100 test.xyz.com " &gt;&gt; /etc/hosts'</span></span><br><span class="line"><span class="attr"> delegate_to:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p></p><p>也可以委托ansible服务端运行<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">host</span> <span class="string">record</span> <span class="string">to</span> <span class="string">center</span> <span class="string">server</span> </span><br><span class="line"><span class="attr"> shell:</span> <span class="string">'echo hello'</span></span><br><span class="line"><span class="attr"> delegate_to:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure><p></p><h1 id="统一目录结构"><a href="#统一目录结构" class="headerlink" title="统一目录结构"></a>统一目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── filter_plugins          # 自定义 filter 插件存放目录</span><br><span class="line">├── fooapp                  # Fooapp 片色目录 ( 与 common 角色目录平级)</span><br><span class="line">├── group_vars             </span><br><span class="line">│   ├── group1              # group1 自定义变量文件</span><br><span class="line">│   └── group2              # group2 自定义变量文件</span><br><span class="line">├── host_vars</span><br><span class="line">│   ├── hostname1           # hostname1 自定义变量文件</span><br><span class="line">│   └── hostname2           # hostname1 自定义变量文件</span><br><span class="line">├── library                 # 自定义模块存放目录</span><br><span class="line">├── monitoring              # Monitoring 角色目录 ( 与 common 角色目录平级)</span><br><span class="line">├── roles                   # Role 存放目录</span><br><span class="line">│   └── common              # common 角色目录</span><br><span class="line">│       ├── defaults       </span><br><span class="line">│       │   └── main.yml    # common 角色自定义文件 (优先级低)</span><br><span class="line">│       ├── files</span><br><span class="line">│       │   ├── bar.txt     # common 角色 files 资源文件</span><br><span class="line">│       │   └── foo.sh      # common 角色 files 资源文件</span><br><span class="line">│       ├── handlers</span><br><span class="line">│       │   └── main.yml    # common 角色 handlers 入口文件</span><br><span class="line">│       ├── meta</span><br><span class="line">│       │   └── main.yml    # common 角色 依赖文件</span><br><span class="line">│       ├── tasks</span><br><span class="line">│       │   └── main.yml    # common 角色 task 入口文件</span><br><span class="line">│       ├── template</span><br><span class="line">│       │   └── ntp.conf.j2 # common 角色 template 文件</span><br><span class="line">│       └── vars</span><br><span class="line">│           └── main.yml    # common 角色 变量定义文件</span><br><span class="line">├── site.yaml               # Playbook 统一入口文件</span><br><span class="line">├── stage                   # stage 环境的 inventory 文件</span><br><span class="line">├── webservers.yml          # 特殊 Playbook 文件</span><br><span class="line">└── webtier                 # webtier 角色目录 ( 与 common 角色目录平级)</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>ansible进阶技巧 <a href="https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html</a></p><p>shilei ansible 文档 <a href="https://wiki.shileizcc.com/confluence/display/AN/Ansible" target="_blank" rel="noopener">https://wiki.shileizcc.com/confluence/display/AN/Ansible</a></p><p>骏马金龙 ansible系列文章 <a href="http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible" target="_blank" rel="noopener">http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：本节主要总结ansiblerroles中常用的语法以及高级特性、例如变量、下载、解压、修改文件内容等,便于使用ansible协同开发，做更加庞大的任务。&lt;/p&gt;
    
    </summary>
    
      <category term="ansible" scheme="http://www.qupzhi.com/categories/ansible/"/>
    
    
      <category term="自动化" scheme="http://www.qupzhi.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="部署" scheme="http://www.qupzhi.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="工具" scheme="http://www.qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>进入自动化部署的大门-ansible</title>
    <link href="http://www.qupzhi.com/ansible%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.qupzhi.com/ansible初探/</id>
    <published>2018-08-18T05:59:11.000Z</published>
    <updated>2018-11-19T02:28:49.207Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：ansible是运维与实施人员的福音，其优雅的结构，丰富的模块库，简单的编程方式都让其成为自动化部署的不二语言。现在就让我们了解ansible,并使用ansible来做一些简单的任务</p><a id="more"></a><ul><li><a href="#一基本概念">一、基本概念</a><ul><li><a href="#11-如何安装及安装要求">1.1 如何安装及安装要求</a></li><li><a href="#12-专有名词解释">1.2 专有名词解释</a></li><li><a href="#13-原理图">1.3 原理图</a></li><li><a href="#14-连接机制">1.4 连接机制</a></li><li><a href="#15-常用文件及配置位置">1.5 常用文件及配置位置</a></li></ul></li><li><a href="#二简单的例子">二、简单的例子</a><ul><li><a href="#21-配置被管控机器的连接信息">2.1 配置被管控机器的连接信息</a></li><li><a href="#22-执行命令">2.2 执行命令</a></li></ul></li><li><a href="#23-讨论执行命令的四个模块有什么区别">2.3 讨论执行命令的四个模块有什么区别</a></li><li><a href="#三-完成复杂的ansible操作">三、 完成复杂的ansible操作</a></li><li><a href="#引用">引用</a></li><li><a href="#资源">资源</a></li></ul><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><blockquote><p>Ansible是一款开源软件，可自动执行软件供应，配置管理和应用程序部署。Ansible通过SSH，远程PowerShell或其他远程API连接。—-选自wikipedia</p></blockquote><p>简介：ansible有两种服务器类型，控制机器与节点。控制机器就是安装ansible服务的机器，我们在上面编写和运行ansible的程序代码，并在控制机器上通过ssh远程操作机器（下发上传、执行命令）。当ansible脚本不运行的时候，不会占用任何资源（比如saltstack在运行的时候就会启动进程来监控4505/4506端口），也正由于ansible的这个特点，每次ansible发布更新的时候，只需要更新控制机器就可以了。</p><h2 id="1-1-如何安装及安装要求"><a href="#1-1-如何安装及安装要求" class="headerlink" title="1.1 如何安装及安装要求"></a>1.1 如何安装及安装要求</h2><p>要求：</p><ul><li>控制机是linux系统，需要有python2.6/2.7</li><li>linux系统打开文件数量设置大一些（方法自行百度）</li><li>节点要求，python2.4以上版本</li></ul><p>安装方法（有很多，在此只列出常用的方法，具体安装步骤不做赘述）：</p><ul><li>源码安装 git://github.com/ansible/ansible.git</li><li>yum 方式 / apt 方式 / emerge 方式 或其他linux系统的系统安装方式</li><li>pip 方式</li></ul><h2 id="1-2-专有名词解释"><a href="#1-2-专有名词解释" class="headerlink" title="1.2 专有名词解释"></a>1.2 专有名词解释</h2><table><thead><tr><th>关键字</th><th>释义</th></tr></thead><tbody><tr><td>playbook</td><td>剧本，将要执行的步骤全部放到playbook里面</td></tr><tr><td>modules（通常指core modules）</td><td>核心模块，用于执行某些任务的已有内置插件</td></tr><tr><td>roles</td><td>角色，像演戏一样，剧本中指定在什么时候哪个角色来做什么操作，所以剧本包含角色，角色就有自己的台词，不过ansible里面的角色特殊的地方是，剧本只知识角色是干什么的，具体操作步骤是在角色本身管理（无厘头）</td></tr><tr><td>custom modules</td><td>自定义模块，在核心模块不够用的时候可以自定义编写模块</td></tr><tr><td>plugins</td><td>插件，常用于ansible的日志系统与邮件系统，还有的插件有扩展内置连接方式、扩展变量定义方式、扩展内部循环语法、扩展新的过滤器等</td></tr><tr><td>Inventory</td><td>Ansible 管理主机的清单</td></tr></tbody></table><h2 id="1-3-原理图"><a href="#1-3-原理图" class="headerlink" title="1.3 原理图"></a>1.3 原理图</h2><p><img src="/ansible初探/20180819164218.png" alt="原理图"></p><h2 id="1-4-连接机制"><a href="#1-4-连接机制" class="headerlink" title="1.4 连接机制"></a>1.4 连接机制</h2><p>ansible通常使用的是ssh协议（或者Kerberos、LDAP）来进行连接（在openssh不支持的操作系统或ansible比较老的版本，ansible使用paramiko），ansible支持的连接方式有三种SSH、Local、ZeroMQ，在规模比较大的情况下使用ZeroMQ连接方式对执行速度有显著提高</p><h2 id="1-5-常用文件及配置位置"><a href="#1-5-常用文件及配置位置" class="headerlink" title="1.5 常用文件及配置位置"></a>1.5 常用文件及配置位置</h2><table><thead><tr><th>文件</th><th>位置</th></tr></thead><tbody><tr><td>ansible应用程序的主配置文件</td><td>/etc/ansible/ansible.cfg</td></tr><tr><td>定义管控主机</td><td>/etc/ansible/hosts</td></tr></tbody></table><h1 id="二、简单的例子"><a href="#二、简单的例子" class="headerlink" title="二、简单的例子"></a>二、简单的例子</h1><p>这里我们来实现在所有被管控机器上执行<code>hostname</code>命令输出主机名</p><h2 id="2-1-配置被管控机器的连接信息"><a href="#2-1-配置被管控机器的连接信息" class="headerlink" title="2.1 配置被管控机器的连接信息"></a>2.1 配置被管控机器的连接信息</h2><p><img src="/ansible初探/20180819164958.png" alt="配置被管控机器的连接信息"></p><ul><li>备注1：在<code>/etc/ansible/hosts</code>位置写入一个主机组（分组名为<code>test</code>），以后针对这个分组操作就视为对分组内的所有主机操作。</li><li>备注2：<code>[test:vars]</code> 标签下为<code>test</code>分组的变量，<code>ansible_ssh_user</code>和<code>ansible_ssh_pass</code>是ansible的内置变量，意思为该分组下所有主机的用户和和密码，当前了也可以单独指定某台主机只需要将这两个参数追加到ip的旁边就好。这里三台主机都是同一个用户名和密码，所以像这样配置。</li><li>备注3：默认路径是在<code>/etc/ansible/hosts</code>,如果你不喜欢是可以修改的(修改配置文件<code>/etc/ansible/ansible.cfg</code>的<code>inventory=/etc/ansible/hosts</code>即可)<h2 id="2-2-执行命令"><a href="#2-2-执行命令" class="headerlink" title="2.2 执行命令"></a>2.2 执行命令</h2></li></ul><p>执行命令，输出<code>test</code>分组下的所有主机的主机名，<code>-i</code>指定主机或分组,<code>-m</code>指定使用的模块，<code>-a</code>指定传给模块的参数，这里<code>command</code>模块就是执行linux命令的模块缺省时默认使用该模块，相同作用的还有<code>shell</code>模块、<code>raw</code>模块、<code>script</code>模块（使用场景与部分细节上不同，后面探讨）<br><img src="/ansible初探/20180827230444.png" alt="20180827230444.png"></p><h1 id="2-3-讨论执行命令的四个模块有什么区别"><a href="#2-3-讨论执行命令的四个模块有什么区别" class="headerlink" title="2.3 讨论执行命令的四个模块有什么区别"></a>2.3 讨论执行命令的四个模块有什么区别</h1><p>每次在使用的时候都会有一些迷惑，为什么非要弄四个执行命令的模块出来，一开始决定没有必要，但是到后来才明白存在既合理，这里和大家探讨一下</p><table><thead><tr><th>模块</th><th>解释</th></tr></thead><tbody><tr><td><code>command模块</code></td><td>是为了安全的执行linux命令，所以不支持`”&lt;”, “&gt;”, “</td><td>“, 和 “&amp;”`等符号（没有shell注入风险），如果要一定要使用这些，则使用shell模块</td></tr><tr><td><code>shell模块</code></td><td>通过<code>/bin/sh</code>来执行，其他都和command一样</td></tr><tr><td><code>raw模块</code></td><td>用来执行低版本的linux命令，可以不需要python来执行命令，甚至支持windows命令，带来的问题是很多很特性是不能用的</td></tr><tr><td>script模块</td><td>其原理是先将脚本，复制到远程主机，再在远程主机上执行，所以要指定脚本路径以及操作方法</td></tr></tbody></table><p>结论：要安全用command，要方便用shell，要操作写好的shell脚本或者其他脚本就用script、要是以上操作都跑不了的机器就用raw</p><h1 id="三、-完成复杂的ansible操作"><a href="#三、-完成复杂的ansible操作" class="headerlink" title="三、 完成复杂的ansible操作"></a>三、 完成复杂的ansible操作</h1><p>未完待续–</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Ansible插件扩展 <a href="https://blog.csdn.net/yongchaocsdn/article/details/79271870" target="_blank" rel="noopener">https://blog.csdn.net/yongchaocsdn/article/details/79271870</a></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>插件 <a href="https://github.com/ansible/ansible/tree/stable-2.4/lib/ansible/plugins" target="_blank" rel="noopener">https://github.com/ansible/ansible/tree/stable-2.4/lib/ansible/plugins</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：ansible是运维与实施人员的福音，其优雅的结构，丰富的模块库，简单的编程方式都让其成为自动化部署的不二语言。现在就让我们了解ansible,并使用ansible来做一些简单的任务&lt;/p&gt;
    
    </summary>
    
      <category term="ansible" scheme="http://www.qupzhi.com/categories/ansible/"/>
    
    
      <category term="自动化" scheme="http://www.qupzhi.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="部署" scheme="http://www.qupzhi.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="工具" scheme="http://www.qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>配置像我一样的hexo博客</title>
    <link href="http://www.qupzhi.com/%E9%85%8D%E7%BD%AE%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.qupzhi.com/配置像我一样的hexo博客/</id>
    <published>2018-08-11T17:00:42.000Z</published>
    <updated>2018-12-11T13:01:25.468Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：csdn和博客园虽然用的人多、技术氛围好，但是由于csdn的广告和灌水以及博客园的简陋页面让我决定搭建一套属于自己的博客，此处用到比较火的hexo搭建，而且免费就能获得自己的网站，如果不买域名的话完全够用了<br><a id="more"></a></p><ul><li><a href="#一搭建本地-hexo">一、搭建本地 hexo</a><ul><li><a href="#11-安装nodejs">1.1 安装nodejs</a></li><li><a href="#12-安装git">1.2 安装git</a></li><li><a href="#13-使用npm安装hexo">1.3 使用npm安装Hexo</a></li><li><a href="#14-创建本地服务">1.4 创建本地服务</a></li><li><a href="#15-主题配置">1.5 主题配置</a></li></ul></li><li><a href="#二-配置你的github">二、 配置你的github</a><ul><li><a href="#21-创建一个新项目">2.1 创建一个新项目</a></li><li><a href="#22-填写正确的项目名称">2.2 填写正确的项目名称</a></li><li><a href="#23-配置你的项目">2.3 配置你的项目</a></li></ul></li><li><a href="#三激动人心的博客">三、激动人心的博客</a><ul><li><a href="#31-修改hexo配置文件">3.1 修改hexo配置文件</a></li><li><a href="#32-部署成功">3.2 部署成功</a></li></ul></li><li><a href="#四个性化配置你的博客">四、个性化配置你的博客</a><ul><li><a href="#41-配置博客名博客描述等信息">4.1 配置博客名，博客描述等信息</a></li><li><a href="#42-添加头像">4.2 添加头像</a></li><li><a href="#43-添加日志列表">4.3 添加日志列表</a></li><li><a href="#42-其他">4.2 其他</a></li></ul></li><li><a href="#五配置你的hexo可以插入图片">五、配置你的hexo可以插入图片</a></li><li><a href="#附加速npm">附：加速npm</a></li><li><a href="#引用">引用</a></li></ul><hr><h1 id="一、搭建本地-hexo"><a href="#一、搭建本地-hexo" class="headerlink" title="一、搭建本地 hexo"></a>一、搭建本地 hexo</h1><h2 id="1-1-安装nodejs"><a href="#1-1-安装nodejs" class="headerlink" title="1.1 安装nodejs"></a>1.1 安装nodejs</h2><p>到nodejs官网下载安装 <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></p><h2 id="1-2-安装git"><a href="#1-2-安装git" class="headerlink" title="1.2 安装git"></a>1.2 安装git</h2><p>到git官网下载安装 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h2 id="1-3-使用npm安装Hexo"><a href="#1-3-使用npm安装Hexo" class="headerlink" title="1.3 使用npm安装Hexo"></a>1.3 使用npm安装Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>备注： 如果npm下载比较慢可以跳到 <a href="#附加速npm">附：加速npm</a></p><h2 id="1-4-创建本地服务"><a href="#1-4-创建本地服务" class="headerlink" title="1.4 创建本地服务"></a>1.4 创建本地服务</h2><p>创建一个文件夹，此处为blog，执行以下命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo i blog //init的缩写 blog是项目名</span><br><span class="line"><span class="built_in">cd</span> blog //切换到站点根目录</span><br><span class="line">hexo g //generetor的缩写</span><br><span class="line">hexo s //server的缩写</span><br></pre></td></tr></table></figure><p></p><p><img src="/配置像我一样的hexo博客/20180812012524.png" alt="本地hexo"><br>访问本地服务<code>localhost:4000</code>证明成功,为什么和我的不一样，因为我修改了hexo的主题配置可以跳到 <a href="#四个性化配置你的博客">四、个性化配置你的博客</a><br><img src="/配置像我一样的hexo博客/20180812012807.png" alt="本地hexo"><br>有页面出来证明你的配置已经成功了，原始的主题不是很喜欢，我这里也使用了最火的nexT主题</p><h2 id="1-5-主题配置"><a href="#1-5-主题配置" class="headerlink" title="1.5 主题配置"></a>1.5 主题配置</h2><p>在站点根目录输入<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p></p><p>完成后，打开根目录下的_config.yml， 找到 theme 字段，并将其值更改为 next<br><img src="/配置像我一样的hexo博客/20180812013802.png" alt="本地hexo"><br>next有三种主题，我选择的是双栏 Scheme，找到 <code>站点根目录/themes/next/_congig.yml</code> 文件，再找到<code>schme</code>字段，将其值改为<code>Pisces</code>,其他两种可以参考<a href="#引用">引用</a>里所写的<br><img src="/配置像我一样的hexo博客/20180812014827.png" alt="next主题"></p><p>使配置生效<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  //清除缓存</span><br><span class="line">hexo g  //重新生成代码</span><br><span class="line">hexo s  //部署到本地</span><br></pre></td></tr></table></figure><p></p><p>这样你的会有一套和我一样主题的博客了，如果你不喜欢这套主题，或者想自己来开发一套定制自己的主题参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a>,下面让我们把他推到github上，变成独一无二的网站</p><h1 id="二、-配置你的github"><a href="#二、-配置你的github" class="headerlink" title="二、 配置你的github"></a>二、 配置你的github</h1><h2 id="2-1-创建一个新项目"><a href="#2-1-创建一个新项目" class="headerlink" title="2.1 创建一个新项目"></a>2.1 创建一个新项目</h2><p>如果没有注册github帐号到&gt;<a href="https://github.com/" target="_blank" rel="noopener">官网注册</a><br>点此创建项目（如果你不是程序员建议勾选上图中Initalize this repository with a README选项）：<br><img src="/配置像我一样的hexo博客/20180812020821.png" alt="next主题"></p><h2 id="2-2-填写正确的项目名称"><a href="#2-2-填写正确的项目名称" class="headerlink" title="2.2 填写正确的项目名称"></a>2.2 填写正确的项目名称</h2><p>项目名可以为<code>任意英文.github.io</code>，public设置为公开项目,点击绿色创建按钮</p><p><img src="/配置像我一样的hexo博客/20180812021131.png" alt="next主题"></p><h2 id="2-3-配置你的项目"><a href="#2-3-配置你的项目" class="headerlink" title="2.3 配置你的项目"></a>2.3 配置你的项目</h2><p>在项目里创建一个readme.md即可，这下可以在页面上访问到这个免费的网站了<br>我的网站 <a href="https://pzqu.github.io/" target="_blank" rel="noopener">https://pzqu.github.io/</a></p><h1 id="三、激动人心的博客"><a href="#三、激动人心的博客" class="headerlink" title="三、激动人心的博客"></a>三、激动人心的博客</h1><h2 id="3-1-修改hexo配置文件"><a href="#3-1-修改hexo配置文件" class="headerlink" title="3.1 修改hexo配置文件"></a>3.1 修改hexo配置文件</h2><p>修改根目录的配置文件<code>_config.yml</code>，以下部分如果没有需要手动创建，建议直接拷贝我的，repo为自己刚刚创建的那个项目的git链接（注意冒号与值之间必须有空格）<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/pzqu/pzqu.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p></p><h2 id="3-2-部署成功"><a href="#3-2-部署成功" class="headerlink" title="3.2 部署成功"></a>3.2 部署成功</h2><p>直接执行一套命令,再刷新刚刚的域名即可<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d  //  部署的命令,会生成代码并推送到github上去</span><br></pre></td></tr></table></figure><p></p><h1 id="四、个性化配置你的博客"><a href="#四、个性化配置你的博客" class="headerlink" title="四、个性化配置你的博客"></a>四、个性化配置你的博客</h1><h2 id="4-1-配置博客名，博客描述等信息"><a href="#4-1-配置博客名，博客描述等信息" class="headerlink" title="4.1 配置博客名，博客描述等信息"></a>4.1 配置博客名，博客描述等信息</h2><p>参考官方网站 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration.html</a></p><h2 id="4-2-添加头像"><a href="#4-2-添加头像" class="headerlink" title="4.2 添加头像"></a>4.2 添加头像</h2><p>在主题配置文件里修改<br><code>avatar: images/avatar.gif</code></p><h2 id="4-3-添加日志列表"><a href="#4-3-添加日志列表" class="headerlink" title="4.3 添加日志列表"></a>4.3 添加日志列表</h2><h2 id="4-2-其他"><a href="#4-2-其他" class="headerlink" title="4.2 其他"></a>4.2 其他</h2><p>添加顶部加载条,修改主题配置文件，pace_theme有好几款，自己选一款<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pace: <span class="literal">true</span></span><br><span class="line">pace_theme: pace-theme-flash</span><br></pre></td></tr></table></figure><p></p><p>添加打赏功能，修改主题配置文件，图片可以上传到<code>themes\next\source\images</code><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /images/wxpay.jpg</span><br><span class="line">alipay: /images/alipay.jpg</span><br></pre></td></tr></table></figure><p></p><p>文章阅读量<br>参考 <a href="https://www.jianshu.com/p/702a7aec4d00" target="_blank" rel="noopener">https://www.jianshu.com/p/702a7aec4d00</a></p><p>评论系统<br><a href="http://www.zhaojun.im/hexo-valine/" target="_blank" rel="noopener">http://www.zhaojun.im/hexo-valine/</a></p><p>删除底部强力驱动、统计站点网上自己查<br>添加分享<br>添加评论</p><h1 id="五、配置你的hexo可以插入图片"><a href="#五、配置你的hexo可以插入图片" class="headerlink" title="五、配置你的hexo可以插入图片"></a>五、配置你的hexo可以插入图片</h1><ol><li>把主页配置文件 _config.yml 里的post_asset_folder:这个选项设置为true</li><li>在你的hexo目录下执行<code>npm install hexo-asset-image --save</code></li><li>等待一小段时间后，再运行<code>hexo n &quot;配置像我一样的hexo博客&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>配置像我一样的hexo博客.md</code>文件还有一个同名的文件夹</li><li>最后在<code>配置像我一样的hexo博客.md</code>中想引入图片时，先把图片复制到<code>配置像我一样的hexo博客</code>这个文件夹中，然后只需要在<code>配置像我一样的hexo博客.md</code>中按照markdown的格式引入图片,注意使用相对路径：<br><code>![你想输入的替代文字](配置像我一样的hexo博客/图片名.jpg)</code></li></ol><h1 id="附：加速npm"><a href="#附：加速npm" class="headerlink" title="附：加速npm"></a>附：加速npm</h1><p>配置npm镜像<code>npm config set registry https://registry.npm.taobao.org</code><br>查看npm镜像<code>npm config get registry</code></p><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！</a><br><a href="https://blog.csdn.net/quuqu/article/details/64121812" target="_blank" rel="noopener">npm太慢， 淘宝npm镜像使用方法</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：csdn和博客园虽然用的人多、技术氛围好，但是由于csdn的广告和灌水以及博客园的简陋页面让我决定搭建一套属于自己的博客，此处用到比较火的hexo搭建，而且免费就能获得自己的网站，如果不买域名的话完全够用了&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.qupzhi.com/categories/hexo/"/>
    
    
      <category term="建站教程" scheme="http://www.qupzhi.com/tags/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq集群的各种运维操作</title>
    <link href="http://www.qupzhi.com/first-blog/"/>
    <id>http://www.qupzhi.com/first-blog/</id>
    <published>2018-08-11T16:18:46.000Z</published>
    <updated>2018-12-11T13:00:37.302Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --><p>摘要：在rabbitmq集群操作或者搭建的时候，常常会因为对于集群的不熟练而导致各种异常错误，常见的有绑定了浮动ip没有绑定实体ip导致，页面上操作mq完全没有问题，但是一到程序操作就出现问题，我们一起来学习下，rabbitmq集群的正确操作</p><a id="more"></a><ul><li><a href="#一rabbitmq集群必要条件">一、rabbitmq集群必要条件</a><ul><li><a href="#11-绑定实体ip即ifconfig所能查询到的绑定到网卡上的ip以下是绑定方法">1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</a></li><li><a href="#12-配置域名映射到实体ip">1.2. 配置域名映射到实体ip</a></li></ul></li><li><a href="#二启动停止">二、启动停止</a><ul><li><a href="#21-停止">2.1 停止</a></li><li><a href="#22-启动">2.2 启动</a></li></ul></li><li><a href="#三重建集群">三、重建集群</a><ul><li><a href="#31-使用21方法停止所有机器">3.1 使用2.1方法停止所有机器</a></li><li><a href="#32-移除rabbitmq配置记录与存储文件">3.2 移除rabbitmq配置记录与存储文件</a></li><li><a href="#33-按22方法启动所有机器">3.3 按2.2方法启动所有机器</a></li><li><a href="#34-停止被加入集群节点app">3.4 停止被加入集群节点app</a></li><li><a href="#35-建立集群">3.5 建立集群</a></li><li><a href="#36-启动集群">3.6 启动集群</a></li><li><a href="#37-检查集群状态">3.7 检查集群状态</a></li><li><a href="#38-添加集群配置-见第四">3.8 添加集群配置 （见第四）</a></li></ul></li><li><a href="#四-添加集群配置">四 添加集群配置</a><ul><li><a href="#41-创建用户">4.1 创建用户</a></li><li><a href="#42-打开15672网页管理端访问mq">4.2 打开15672网页管理端，访问mq</a></li><li><a href="#43-在底部导入json后缀的配置文件即可">4.3 在底部导入.json后缀的配置文件即可</a></li></ul></li></ul><hr><blockquote><p>以下操作都以三节点集群为例，机器名标记为机器A、机器B、机器C，如果为双节点忽略机器C，如果为各多节点则与机器C操作相同</p></blockquote><h1 id="一、rabbitmq集群必要条件"><a href="#一、rabbitmq集群必要条件" class="headerlink" title="一、rabbitmq集群必要条件"></a>一、rabbitmq集群必要条件</h1><h2 id="1-1-绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法"><a href="#1-1-绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法" class="headerlink" title="1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法"></a>1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑配置路径 /etc/rabbitmq/rabbitmq-env.conf</span></span><br><span class="line">NODE_IP_ADDRESS=172.16.136.133</span><br></pre></td></tr></table></figure><h2 id="1-2-配置域名映射到实体ip"><a href="#1-2-配置域名映射到实体ip" class="headerlink" title="1.2. 配置域名映射到实体ip"></a>1.2. 配置域名映射到实体ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#配置文件1所在路径 /etc/rabbitmq/rabbitmq.config (如果是集群，每台机器都需要修改这个绑定本机实体ip)</span><br><span class="line">#其中rabbit@master是创建集群时所配置的参数，@后面的参数为主机名，示例中为master</span><br><span class="line">[</span><br><span class="line">    &#123;rabbit, [</span><br><span class="line">    &#123;cluster_nodes, &#123;[&apos;rabbit@master&apos;], disc&#125;&#125;,</span><br><span class="line">    &#123;cluster_partition_handling, ignore&#125;,</span><br><span class="line">    &#123;default_user, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;default_pass, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;tcp_listen_options, [binary,</span><br><span class="line">        &#123;packet, raw&#125;,</span><br><span class="line">        &#123;reuseaddr, true&#125;,</span><br><span class="line">        &#123;backlog, 128&#125;,</span><br><span class="line">        &#123;nodelay, true&#125;,</span><br><span class="line">        &#123;exit_on_close, false&#125;,</span><br><span class="line">        &#123;keepalive, true&#125;]&#125;</span><br><span class="line">    ]&#125;,</span><br><span class="line">    &#123;kernel, [</span><br><span class="line">        &#123;inet_dist_listen_max, 44001&#125;,</span><br><span class="line">        &#123;inet_dist_listen_min, 44001&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#配置文件2 所在路径 /etc/hosts (如果是集群，每台机器都需要修改这个绑定本机实体ip，而且hosts文件的映射不得重复，如果重复linux系统为以最下面一条记录为准)</span><br><span class="line">172.16.136.133 master</span><br><span class="line">172.16.136.134 venus</span><br><span class="line">172.16.136.135 venus2</span><br></pre></td></tr></table></figure><h1 id="二、启动停止"><a href="#二、启动停止" class="headerlink" title="二、启动停止"></a>二、启动停止</h1><h2 id="2-1-停止"><a href="#2-1-停止" class="headerlink" title="2.1 停止"></a>2.1 停止</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器A</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br><span class="line"><span class="comment">#机器B</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br></pre></td></tr></table></figure><h2 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器A</span></span><br><span class="line">service rabbitmq-server start</span><br><span class="line"><span class="comment">#机器B</span></span><br><span class="line">service rabbitmq-server start</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure><h1 id="三、重建集群"><a href="#三、重建集群" class="headerlink" title="三、重建集群"></a>三、重建集群</h1><blockquote><p>注1：此处的mq集群重建是比较快速和有效的方法，面向的是初次安装或者可以接受mq中所存有的数据丢失的情况下，必须先有mq的.json后缀的配置文件或者有把握写入集群中exchange、queue等配置。</p></blockquote><blockquote><p>注2:如果是运行中的mq出现问题，需要在保存数据和配置的情况下恢复集群时，请跳到<a href="/rabbitmq-restart-save-data">rabbitmq集群恢复</a></p></blockquote><h2 id="3-1-使用2-1方法停止所有机器"><a href="#3-1-使用2-1方法停止所有机器" class="headerlink" title="3.1 使用2.1方法停止所有机器"></a>3.1 使用2.1方法停止所有机器</h2><h2 id="3-2-移除rabbitmq配置记录与存储文件"><a href="#3-2-移除rabbitmq配置记录与存储文件" class="headerlink" title="3.2 移除rabbitmq配置记录与存储文件"></a>3.2 移除rabbitmq配置记录与存储文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位于 /var/lib/rabbitmq/mensia</span></span><br><span class="line">mv /var/lib/rabbitmq/mensia /var/lib/rabbitmq/mensia.bak</span><br></pre></td></tr></table></figure><h2 id="3-3-按2-2方法启动所有机器"><a href="#3-3-按2-2方法启动所有机器" class="headerlink" title="3.3 按2.2方法启动所有机器"></a>3.3 按2.2方法启动所有机器</h2><h2 id="3-4-停止被加入集群节点app"><a href="#3-4-停止被加入集群节点app" class="headerlink" title="3.4 停止被加入集群节点app"></a>3.4 停止被加入集群节点app</h2><blockquote><p>比如A、B、C三台机器，将B和C加入到A中去，需要执行以下命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="3-5-建立集群"><a href="#3-5-建立集群" class="headerlink" title="3.5 建立集群"></a>3.5 建立集群</h2><blockquote><p>注意此处master为唯一没有执行<code>rabbitmqctl stop_app</code>的机器<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="3-6-启动集群"><a href="#3-6-启动集群" class="headerlink" title="3.6 启动集群"></a>3.6 启动集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h2 id="3-7-检查集群状态"><a href="#3-7-检查集群状态" class="headerlink" title="3.7 检查集群状态"></a>3.7 检查集群状态</h2><p>在任意一台机器上执行<code>rabbitmqctl cluster_status</code>命令即可检查，输出包含集群中的节点与运行中的节点，兼以主机名标志</p><h2 id="3-8-添加集群配置-（见第四）"><a href="#3-8-添加集群配置-（见第四）" class="headerlink" title="3.8 添加集群配置 （见第四）"></a>3.8 添加集群配置 （见第四）</h2><h1 id="四-添加集群配置"><a href="#四-添加集群配置" class="headerlink" title="四 添加集群配置"></a>四 添加集群配置</h1><h2 id="4-1-创建用户"><a href="#4-1-创建用户" class="headerlink" title="4.1 创建用户"></a>4.1 创建用户</h2><blockquote><p>例子中创建了两个用户<br>添加用户<code>add_user</code>,设置角色<code>set_user_tags</code>,添加rabbitmq虚拟主机<code>add_vhost</code>，设置访问权限<code>set_permissions</code>,以下是详细用法<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建第一个用户</span></span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名 administrator</span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p /  用户名 <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line"><span class="comment"># 创建第二个用户</span></span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名2 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名2 management </span><br><span class="line">/usr/sbin/rabbitmqctl add_vhost sip_ext </span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p sip_ext 用户名2 <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br></pre></td></tr></table></figure><p></p></blockquote><pre><code>备注：RabbitMQ 虚拟主机，RabbitMQ 通过虚拟主机（vhost）来分发消息。拥有自己独立的权限控制，不同的vhost之间是隔离的，单独的。权限控制的基本单位：vhost。用户只能访问与之绑定的vhost。vhost是AMQP中唯一无法通过协议来创建的基元。只能通过rabbitmqctl工具来创建。 </code></pre><h2 id="4-2-打开15672网页管理端，访问mq"><a href="#4-2-打开15672网页管理端，访问mq" class="headerlink" title="4.2 打开15672网页管理端，访问mq"></a>4.2 打开15672网页管理端，访问mq</h2><p><code>/usr/sbin/rabbitmq-plugins enable rabbitmq_management</code><br>备注：如果发现命令执行完毕没有打开此服务，15672端口没有监听，则是由于没有重启mq导致的</p><h2 id="4-3-在底部导入-json后缀的配置文件即可"><a href="#4-3-在底部导入-json后缀的配置文件即可" class="headerlink" title="4.3 在底部导入.json后缀的配置文件即可"></a>4.3 在底部导入.json后缀的配置文件即可</h2><p><img src="/first-blog/rabbitmq.jpg" alt="rabbitmq更新配置"></p><p>如果覆盖了用户需要使用以下命令修改mq用户密码<br><code>/usr/sbin/rabbitmqctl change_password 用户名 密码</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jan 02 2019 14:41:20 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;摘要：在rabbitmq集群操作或者搭建的时候，常常会因为对于集群的不熟练而导致各种异常错误，常见的有绑定了浮动ip没有绑定实体ip导致，页面上操作mq完全没有问题，但是一到程序操作就出现问题，我们一起来学习下，rabbitmq集群的正确操作&lt;/p&gt;
    
    </summary>
    
      <category term="rabbitmq" scheme="http://www.qupzhi.com/categories/rabbitmq/"/>
    
    
      <category term="rabbitmq集群" scheme="http://www.qupzhi.com/tags/rabbitmq%E9%9B%86%E7%BE%A4/"/>
    
      <category term="rabbitmq教程" scheme="http://www.qupzhi.com/tags/rabbitmq%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
