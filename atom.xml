<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程三分钟</title>
  
  <subtitle>微信公众号 coding3min</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qupzhi.com/"/>
  <updated>2019-05-01T14:53:51.275Z</updated>
  <id>https://qupzhi.com/</id>
  
  <author>
    <name>编程三分钟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>添加linux开机启动项</title>
    <link href="https://qupzhi.com/linux-boot-add/"/>
    <id>https://qupzhi.com/linux-boot-add/</id>
    <published>2019-04-28T11:34:00.000Z</published>
    <updated>2019-05-01T14:53:51.275Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：以往的服务通常使用supervisord或者crontab的方式来守护或者定时执行，最近遇到了自己写的服务所依赖到一些组件服务，在开机的没有自动启动的问题，所以这次对添加linux开机自启动的一些方式做一个总结。让自己的服务可以做到无人托管开机自启动，减少运营成本的同时可以防止有人偷偷写入开机启动项，启动一些没有必要的服务。<br><a id="more"></a></p><h1 id="用户自定义开机程序-etc-rc-d-rc-local"><a href="#用户自定义开机程序-etc-rc-d-rc-local" class="headerlink" title="用户自定义开机程序(/etc/rc.d/rc.local)"></a>用户自定义开机程序(/etc/rc.d/rc.local)</h1><p><img src="https://ask.qcloudimg.com/draft/3097464/r9louktbfz.png" alt="rc.local"></p><ul><li>这些就是开机的时候会自动执行的脚本和命令了。</li><li>这个时候就有人问了，我以前写的是<code>/etc/rc.local</code>这个文件也没写过你说的<code>/etc/rc.d/rc.local</code>文件啊。这是因为<code>/etc/rc.local</code>软链接到<code>/etc/rc.d/rc.local</code>，所以写到哪个文件里都是一样的</li><li>写在这个文件里的开机脚本都是默认后台执行的，不需要再加<code>&amp;</code>符号了</li></ul><h1 id="自写脚本登陆自动执行-etc-profile-d-，不是开机自动执行"><a href="#自写脚本登陆自动执行-etc-profile-d-，不是开机自动执行" class="headerlink" title="自写脚本登陆自动执行(/etc/profile.d/)，不是开机自动执行"></a>自写脚本登陆自动执行(/etc/profile.d/)，不是开机自动执行</h1><p><img src="https://ask.qcloudimg.com/draft/3097464/x1cxcmmond.png" alt="/etc/profile.d"></p><ul><li>目录中存放的是一些应用程序所需的启动脚本，其中包括了颜色、语言、less、vim及which等命令的一些附加设置。</li><li>当一个用户登录Linux系统或使用su -命令切换到另一个用户时，也就是Login shell 启动时，首先要确保执行的启动脚本就是 <code>/etc/profile</code> 。（只有<code>Login shell</code>启动时才会运行 <code>/etc/profile</code> 这个脚本，也就是<strong>需要输入账号和密码</strong>的时候，而<code>Non-login shell</code> 不会调用这个脚本）</li><li>这些脚本文件之所以能够 被自动执行，是因为在<code>/etc/profile</code>中使用一个for循环语句来调用这些脚本。而这些脚本文件是用来设置一些变量和运行一些初始化过程的。</li></ul><h1 id="chkconfig命令设置-可设置优先级别"><a href="#chkconfig命令设置-可设置优先级别" class="headerlink" title="chkconfig命令设置 可设置优先级别"></a>chkconfig命令设置 可设置优先级别</h1><h2 id="etc-rc-d-init-d目录"><a href="#etc-rc-d-init-d目录" class="headerlink" title="/etc/rc.d/init.d目录"></a><code>/etc/rc.d/init.d</code>目录</h2><p>为什么要介绍<code>/etc/rc.local/init.d</code>目录是因为要使用chkconfig来管理自动启动的脚本，首先将启动文件cp到 /etc/init.d/或者/etc/rc.d/init.d/（前者是后者的软连接）下才可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_15_centos init.d]# ls</span><br><span class="line">abrt-ccpp  atd               cloud-config      crond      iptables    lvm2-lvmetad  netconsole  ntpd     psacct     restorecond  single</span><br><span class="line">abrtd      auditd            cloud-final       functions  irqbalance  lvm2-monitor  netfs       ntpdate  quota_nld  rsyslog      sshd</span><br><span class="line">abrt-oops  blk-availability  cloud-init        halt       kdump       mdmonitor     network     postfix  rdisc      sandbox      udev-post</span><br><span class="line">acpid      bootlocal         cloud-init-local  ip6tables  killall     messagebus    nfs-rdma    pptpd    rdma       saslauthd    YDService</span><br><span class="line">[root@VM_0_15_centos init.d]# cp pptpd pptpd2</span><br><span class="line">[root@VM_0_15_centos init.d]# service pptpd2 status</span><br><span class="line">pptpd (pid  1324) is running...</span><br><span class="line">[root@VM_0_15_centos init.d]# /etc/rc.d/init.d/pptpd2 status</span><br><span class="line">pptpd (pid  1324) is running...</span><br></pre></td></tr></table></figure><ul><li>此目录下的脚本会被提供给service或者systemctl使用</li><li>一般存在以下命令<code>start、stop、reload、restart、force-reload</code>大多数的情况下，你会使用到<code>start,stop,restart</code>选项</li><li>当然了要使用init.d目录下的脚本，你需要有root权限或sudo权限。每个脚本都将被作为一个命令运行，每个脚本也至少需要755权限。</li><li><code>/etc/init.d</code>指向<code>/etc/rc.d/init.d</code>目录</li></ul><h2 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h2><h3 id="如何添加一个服务"><a href="#如何添加一个服务" class="headerlink" title="如何添加一个服务"></a>如何添加一个服务</h3><p>增加服务的步骤：</p><ol><li>服务脚本必须存放在/etc/ini.d/目录下；</li><li><code>chkconfig --add servicename</code>在chkconfig工具服务列表中增加此服务，此时服务会被在/etc/rc.d/rcN.d中赋予K/S入口了；</li><li><code>chkconfig --level 35 mysqld on</code>修改服务的默认启动等级。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_15_centos init.d]# vim pptpd</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Startup script <span class="keyword">for</span> pptpd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: - 85 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: PPTP server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> processname: pptpd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> config: /etc/pptpd.conf</span></span><br></pre></td></tr></table></figure><ul><li>脚本文件前面务必添加如下三行代码，否侧会提示chkconfig不支持</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh 告诉系统使用的shell,所以的shell脚本都是这样</span></span><br><span class="line"><span class="comment">#chkconfig: 35 20 80 分别代表运行级别，启动优先权，关闭优先权，此行代码必须</span></span><br><span class="line"><span class="comment">#description: http server（自己随便发挥）此行代码必须</span></span><br></pre></td></tr></table></figure><p>chkconfig –add 脚本文件名 操作后就已经添加了<br>使用范例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list        #列出所有的系统服务</span><br><span class="line">chkconfig --add httpd        #增加httpd服务</span><br><span class="line">chkconfig --del httpd        #删除httpd服务</span><br><span class="line">chkconfig --level httpd 2345 on        #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态</span><br><span class="line">chkconfig --list        #列出系统所有的服务启动情况</span><br><span class="line">chkconfig --list mysqld        #列出mysqld服务设置情况</span><br><span class="line">chkconfig --level 35 mysqld on        #设定mysqld在等级3和5为开机运行服务，--level 35表示操作只在等级3和5执行，on表示启动，off表示关闭</span><br><span class="line">chkconfig mysqld on        #设定mysqld在各等级为on，“各等级”包括2、3、4、5等级</span><br></pre></td></tr></table></figure><p></p><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>代表是何等级时可以在开机时自动运行此服务<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</span><br><span class="line">运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</span><br><span class="line">运行级别2：多用户状态(没有联网NFS)</span><br><span class="line">运行级别3：完全的多用户状态(有联网NFS)，登陆后进入控制台命令行模式</span><br><span class="line">运行级别4：系统未使用，保留</span><br><span class="line">运行级别5：X11控制台，登陆后进入图形GUI模式</span><br><span class="line">运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</span><br></pre></td></tr></table></figure><p></p><ul><li>需要说明的是，level选项可以指定要查看的运行级而不一定是当前运行级。对于每个运行级，只能有一个启动脚本或者停止脚本。当切换运行级时，init不会重新启动已经启动的服务，也不会再次去停止已经停止的服务。</li><li>如果默认情况下，服务不应在任何运行级别中启动，则应使用-代替运行级别列表。</li><li>通常自己的服务使用等级35就可以了,最多2345也就是<code>chkconfig servicename on</code></li></ul><h1 id="ntsysv：类图形界面管理模式来设置开机启动-（RedHat特有）"><a href="#ntsysv：类图形界面管理模式来设置开机启动-（RedHat特有）" class="headerlink" title="ntsysv：类图形界面管理模式来设置开机启动 （RedHat特有）"></a>ntsysv：类图形界面管理模式来设置开机启动 （RedHat特有）</h1><p>Linux ntsysv命令用于设置系统的各种服务。</p><blockquote><p>这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，开启，关闭操作系统在每个执行等级中，所要执行的系统服务。</p></blockquote><p>这种方式不算通用，所以我这里就不赘述了，有兴趣可以移步<a href="https://www.cnblogs.com/ihongyan/p/4154508.html" target="_blank" rel="noopener">Linux ntsysv：设置系统服务</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>开机启动项</p><ol><li>添加脚本到或者命令 <code>/etc/rc.d/rc.local</code></li><li>先把脚本放到<code>/etc/rc.d/init.d</code>下，再使用<code>chkconfig servername on</code>命令添加2345运行级别到开机启动项（脚本写的规则见详情）</li><li>ntsysv不常用可以忽略</li></ol><p>使用密码登陆时运行</p><ol><li>把脚本放到<code>/etc/profile.d/</code>下</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.linuxprobe.com/linux-autostart.html" target="_blank" rel="noopener">linux下三种开机自启动服务的方式总结</a></p><p><a href="https://blog.csdn.net/lylload/article/details/79488968" target="_blank" rel="noopener">linux 添加开机启动项的三种方法。</a></p><p><a href="http://www.runoob.com/linux/linux-comm-ntsysv.html" target="_blank" rel="noopener">Linux ntsysv命令</a></p><p><a href="https://blog.csdn.net/u011277123/article/details/72864826" target="_blank" rel="noopener">/etc/profile 文件和/etc/profile.d</a></p><p><a href="https://blog.csdn.net/stone_wzf/article/details/45727595" target="_blank" rel="noopener">chkconfig 服务的添加、顺序</a></p><p><a href="https://zhuanlan.zhihu.com/p/45336481" target="_blank" rel="noopener">Linux 系统开机启动项清理</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：以往的服务通常使用supervisord或者crontab的方式来守护或者定时执行，最近遇到了自己写的服务所依赖到一些组件服务，在开机的没有自动启动的问题，所以这次对添加linux开机自启动的一些方式做一个总结。让自己的服务可以做到无人托管开机自启动，减少运营成本的同时可以防止有人偷偷写入开机启动项，启动一些没有必要的服务。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://qupzhi.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://qupzhi.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>进程启动时间采集（linux篇）</title>
    <link href="https://qupzhi.com/process-start-time-linux/"/>
    <id>https://qupzhi.com/process-start-time-linux/</id>
    <published>2019-04-28T05:18:00.000Z</published>
    <updated>2019-05-01T14:53:31.310Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：这次我们来谈谈如何采集一个进程的启动时间</p><a id="more"></a><ul><li>以下内容使用go语言实现</li></ul><h1 id="linux-进程启动时间采集"><a href="#linux-进程启动时间采集" class="headerlink" title="linux 进程启动时间采集"></a>linux 进程启动时间采集</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>直接读取<code>/proc/{pid}</code> 文件夹的时间戳方式（不准确但效率高），以下是方法一的代码，但是我没有验证过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var stat os.FileInfo</span><br><span class="line">if stat, err = os.Lstat(fmt.Sprintf(&quot;/proc/%v&quot;, pid)); err != nil &#123;</span><br><span class="line">      return nil</span><br><span class="line">&#125;</span><br><span class="line">proc.mtime = stat.ModTime().Unix()</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用<code>(现在的时间-从系统启动到现在的时间) + 进程启动时距离系统启动时的时间间隔</code>得到。</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">update_server/</span><br><span class="line">|-- bin</span><br><span class="line">|   `-- go_build_main</span><br><span class="line">|-- main</span><br><span class="line">|-- pkg</span><br><span class="line">|   `-- darwin_amd64</span><br><span class="line">|       `-- webtest.a</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   `-- main.go</span><br><span class="line">    `-- webtest</span><br><span class="line">        `-- webtest.go</span><br></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;webtest&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">webtest.Init()</span><br><span class="line">fmt.Println(&quot;start time:&quot;,webtest.ProcessStartTime(1726))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package webtest</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;pwd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">Uptime int64 // 系统启动时间戳</span><br><span class="line">scClkTck = int64(C.sysconf(C._SC_CLK_TCK))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Init() &#123;</span><br><span class="line">buf, err := ioutil.ReadFile(&quot;/proc/uptime&quot;)</span><br><span class="line">Uptime = time.Now().Unix()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;read file /proc/uptime faile 1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if fields := strings.Fields(string(buf)); len(fields) == 2 &#123;</span><br><span class="line">start, err := strconv.ParseFloat(fields[0], 10)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">Uptime = time.Now().Unix() - int64(start)//- sys.Uptime</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;read file /proc/uptime faile 2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ProcessStartTime(pid int) (ts time.Time) &#123;</span><br><span class="line">buf, err := ioutil.ReadFile(fmt.Sprintf(&quot;/proc/%v/stat&quot;, pid))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return time.Unix(0, 0)</span><br><span class="line">&#125;</span><br><span class="line">if fields := strings.Fields(string(buf)); len(fields) &gt; 22 &#123;</span><br><span class="line">start, err := strconv.ParseInt(fields[21], 10, 0)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">if scClkTck &gt; 0 &#123;</span><br><span class="line">return time.Unix(Uptime+(start/scClkTck), 0)</span><br><span class="line">&#125;</span><br><span class="line">return time.Unix(Uptime+(start/100), 0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return time.Unix(0, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>/proc/uptime</code>中采集到的值是jiffies单位，用来记录自系统启动以来产生的节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值。一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就是Hz。输出结果</li></ul><p><img src="https://ask.qcloudimg.com/draft/3097464/8e8vggmr8d.png" alt="输出结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>刚刚开始接触go语言有点激动，发现go语言中没有类的概念，一时还不知道go相比python、c++、java而言比较大的优点在哪，比较好的一点就是可以直接编译成二进制可执行程序，不用安装各种库，简单看完了golang的入门教程，大概知道怎么写go语言的代码了，接下来要再把书温习一翻，再多动手写点代码以后体系的总结下。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.cnblogs.com/snowDream-shineDream/p/9294545.html" target="_blank" rel="noopener">go 获得进程启动时间的两种方法</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：这次我们来谈谈如何采集一个进程的启动时间&lt;/p&gt;
    
    </summary>
    
      <category term="监控" scheme="https://qupzhi.com/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="go" scheme="https://qupzhi.com/tags/go/"/>
    
      <category term="linux" scheme="https://qupzhi.com/tags/linux/"/>
    
      <category term="监控" scheme="https://qupzhi.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>如何无网络下免编译的安装程序（RPM包）</title>
    <link href="https://qupzhi.com/rpmbuild-01/"/>
    <id>https://qupzhi.com/rpmbuild-01/</id>
    <published>2019-04-27T16:45:00.000Z</published>
    <updated>2019-05-01T14:54:12.315Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：rpm包是预先在Linux主机上编译好并打包的文件，安装起来非常快捷。不需要再进行繁琐的编译等操作，拿来就能用，区别于yum包管理，rpm可以在不需要网络环境的情况下使用。学习完<a href="https://jeremy-xu.oschina.io/2018/02/centos6%25252525E4%25252525B8%252525258Brpm%25252525E6%2525252589%2525252593%25252525E5%252525258C%2525252585%25252525E5%25252525AE%252525259E%25252525E6%2525252588%2525252598/" target="_blank" rel="noopener">大神的文章</a>还是有一些细节不太清楚，下面我就再对编译RPM包的过程和详细知识点再梳理扩展一下留作备忘。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>redhat包管理器rpm（redhat package manager），因为非常的方便，所以这个方式被广泛的使用现在rpm的英文翻译是一种递归写法（RPM package manager）。RPM是以一种数据库记录的方式来将所需要的套件安装在Linux主机的一套管理程序。也就是说Linux系统中存在一个关于rpm的数据库，它记录了安装的包与包之间的依赖相关性。我们可以在有网的环境下载rpm包，也可以定制化的将自己的软件打成rpm包。</p><h1 id="准备rpm打包环境"><a href="#准备rpm打包环境" class="headerlink" title="准备rpm打包环境"></a>准备rpm打包环境</h1><p>我这里用的操作系统是CentOS6.7，redhat系的其它发行版应该也类似。</p><h2 id="安装rpm-build"><a href="#安装rpm-build" class="headerlink" title="安装rpm-build"></a>安装rpm-build</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y gcc make rpm-build redhat-rpm-config vim lrzsz</span><br></pre></td></tr></table></figure><h3 id="在无网络的机器上装备环境"><a href="#在无网络的机器上装备环境" class="headerlink" title="在无网络的机器上装备环境"></a>在无网络的机器上装备环境</h3><p>需要在无网络的情况下解决一些依赖包的环境可以使用以下命令提前在一台有网络的机器上下载好RPM包再到无网络的机器上安装就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install --downloadonly --downloaddir=&lt;目录&gt;  &lt;packages&gt;</span><br></pre></td></tr></table></figure><h2 id="创建必须的文件夹和文件"><a href="#创建必须的文件夹和文件" class="headerlink" title="创建必须的文件夹和文件"></a>创建必须的文件夹和文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/rpmbuild/&#123;BUILD,RPMS,SOURCES,SPECS,SRPMS&#125;echo &apos;%\_topdir %(echo $HOME)/rpmbuild&apos; &gt; ~/.rpmmacros</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">文件名</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SPECS</td><td style="text-align:left">目录</td><td style="text-align:left">包含rpm的xxx.spec文件(打包的描述文件)</td></tr><tr><td style="text-align:left">SOURCES</td><td style="text-align:left">目录</td><td style="text-align:left">包含源码包(如.tar包)和所有patch补丁、service启动文件等</td></tr><tr><td style="text-align:left">BUILD</td><td style="text-align:left">目录</td><td style="text-align:left">源码包被解压至此, 并在该目录的子目录完成编译</td></tr><tr><td style="text-align:left">BUILDROOT</td><td style="text-align:left">目录</td><td style="text-align:left">存放编译后的文件的临时目录(保存%install阶段安装的文件)</td></tr><tr><td style="text-align:left">RPMS</td><td style="text-align:left">目录</td><td style="text-align:left">经过编译成功后, 打包文件放在这个目录, 包含i386、i686、noarch等次级目录</td></tr><tr><td style="text-align:left">SRPMS</td><td style="text-align:left">目录</td><td style="text-align:left">包含.src.rpm的SPRM包(通常用于审核和升级软件包)</td></tr></tbody></table><h2 id="制作spec文件"><a href="#制作spec文件" class="headerlink" title="制作spec文件"></a>制作spec文件</h2><blockquote><p>找spec模板文件</p></blockquote><p>一般找一个类似的rpm源码包，将其安装，然后参照它写自己软件包的spec文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/rpms</span><br><span class="line">wget -O ~/rpms/python-2.6.6-64.el6.src.rpm http://vault.centos.org/6.7/os/Source/SPackages/python-2.6.6-64.el6.src.rpm</span><br><span class="line">rpm -ivh ~/rpms/python-2.6.6-64.el6.src.rpm</span><br><span class="line">vim ~/rpmbuild/SPECS/python.spec # 参照这个文件来写自己软件包的spec文件</span><br></pre></td></tr></table></figure><h3 id="rpmbuild内置变量"><a href="#rpmbuild内置变量" class="headerlink" title="rpmbuild内置变量"></a>rpmbuild内置变量</h3><p><code>rpmbuild --showrc</code>可查看内置的变量</p><p>常用的几个变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$RPM_BUILD_DIR /$HOME/rpmbuild/BUILD</span><br><span class="line">$RPM_BUILD_ROOT /$HOME/rpmbuild/BUILDROOT</span><br><span class="line">%&#123;_sysconfigdir&#125; /etc</span><br><span class="line">%&#123;_sbindir&#125; /usr/sbin</span><br><span class="line">%&#123;_bindir&#125; /usr/bin</span><br><span class="line">%&#123;_prefix&#125; /usr</span><br><span class="line">%&#123;_localstatedir&#125; /var</span><br><span class="line"></span><br><span class="line">更多的可以查看 --showrc</span><br></pre></td></tr></table></figure><h3 id="rpmbuild-spec规范说明"><a href="#rpmbuild-spec规范说明" class="headerlink" title="rpmbuild spec规范说明"></a>rpmbuild spec规范说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Summary: 软件包的内容概要描述</span><br><span class="line">Name: 软件包的名称(spec文件名与其一致)</span><br><span class="line">Version: 软件的实际版本号，具体和源码包一致</span><br><span class="line">Release: 软件包的发布实际版本号</span><br><span class="line">Url: 软件的主页</span><br><span class="line">License: 软件授权方式(GPL等)</span><br><span class="line">Group: 软件分组，如(Application/System)</span><br><span class="line">Source: 软件的来源</span><br><span class="line">Patch: 补丁patch file依赖的软件，安装的时候需要检查的</span><br><span class="line">BuildRoot: 安装或者编译时使用的&quot;虚拟目录&quot;，一般默认 </span><br><span class="line">BuildRequires: 编译过程中需要的软件</span><br><span class="line">Requires: 依赖的软件, 安装的时候需要检查的</span><br><span class="line">Packager: 软件的打包者</span><br><span class="line">Vendor: 软件发行商或者打包组织信息,如(Apache Software Foundation)</span><br><span class="line"></span><br><span class="line">%description: 软件包描述</span><br><span class="line">%prep: 编译前预处理。如: 1.打补丁; 2. 解压源码等</span><br><span class="line">%setup: 解压源码(一般是位于%prep下的macro, 自动解压源码)</span><br><span class="line">%build: 编译</span><br><span class="line">%install: 安装, 即把一些可执行文件和配置复制到目标目录中。</span><br><span class="line">%clean: 清理一些暂存文件</span><br><span class="line">%files: 定义哪些文件或者目录会放入rpm中</span><br><span class="line">%pre: rpm安装前执行的动作</span><br><span class="line">%post: rpm安装后执行的动作</span><br><span class="line">%preun: 卸载前执行脚本程序(preun)开始执行</span><br><span class="line">%postun: 卸载后执行脚本程序(postun)开始执行</span><br></pre></td></tr></table></figure><p>更多参考: <a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn" target="_blank" rel="noopener">How_to_create_an_RPM_package</a></p><h3 id="rpmbuild-spec-示例"><a href="#rpmbuild-spec-示例" class="headerlink" title="rpmbuild spec 示例"></a>rpmbuild spec 示例</h3><p>示例1 openstack-aodh.spec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%global pypi_name aodh</span><br><span class="line">%&#123;!?upstream_version: %global upstream_version %&#123;version&#125;%&#123;?milestone&#125;&#125;</span><br><span class="line">Name:       openstack-aodh</span><br><span class="line">Version:    2.0.0</span><br><span class="line">Release:    %&#123;es_versions&#125;%&#123;?dist&#125;</span><br><span class="line">Summary:    OpenStack Telemetry Alarming</span><br><span class="line">License:    ASL 2.0</span><br><span class="line">URL:        https://github.com/openstack/aodh.git</span><br><span class="line">BuildArch:  noarch</span><br><span class="line">Source0:    http://tarballs.openstack.org/%&#123;pypi_name&#125;/%&#123;pypi_name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">%description</span><br><span class="line">Aodh is the alarm engine of the Ceilometer project.</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q -n %&#123;pypi_name&#125;-%&#123;upstream_version&#125;</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line">%&#123;__python2&#125; setup.py build</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">%&#123;__python2&#125; setup.py install --skip-buid --root %&#123;buildroot&#125;</span><br><span class="line"></span><br><span class="line">%files -n python-aodh</span><br><span class="line">%&#123;python2_sitelib&#125;/aodh</span><br><span class="line">... </span><br><span class="line">%files common</span><br><span class="line">%doc README.rst</span><br><span class="line">%dir %&#123;_sysconfdir&#125;/aodh</span><br><span class="line">%attr(-, root, aodh) %&#123;_datadir&#125;/aodh/aodh-dist.conf</span><br><span class="line">%config(noreplace) %attr(-, root, aodh) %&#123;_sysconfdir&#125;/aodh/aodh.conf</span><br><span class="line">...</span><br><span class="line">%changelog</span><br></pre></td></tr></table></figure><p>示例2 mariadb.spec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">%define debug_package %&#123;nil&#125;</span><br><span class="line">%define install_dir /usr/local/mariadb</span><br><span class="line"></span><br><span class="line">Name:mariadb</span><br><span class="line">Version:10.1.20</span><br><span class="line">Release:1%&#123;?dist&#125;</span><br><span class="line">Summary:Mariadb client programs and shared libraries and server programs</span><br><span class="line"></span><br><span class="line">Group:Applications/Databases</span><br><span class="line">License:GPLv2 with exceptions</span><br><span class="line">URL:https://mariadb.org/</span><br><span class="line">Source0:mariadb-10.1.20.tar.gz</span><br><span class="line"></span><br><span class="line">BuildRoot: %&#123;_tmppath&#125;/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root</span><br><span class="line">BuildRequires: readline-devel, openssl-devel</span><br><span class="line">BuildRequires: gcc-c++, ncurses-devel, zlib-devel</span><br><span class="line">BuildRequires: libtool, automake, autoconf, gawk</span><br><span class="line">Requires:      grep, automake, autoconf, bash</span><br><span class="line">Autoreq:0</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">MariaDB Server is one of the most popular database servers in the world. It’s made by the original developers of MySQL and guaranteed to stay open source. Notable users include Wikipedia, WordPress.com and Google.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line">cmake . -DMYSQL_UNIX_ADDR=/tmp/mariadb.sock \</span><br><span class="line">        -DEXTRA_CHARSETS=all \</span><br><span class="line">        -DMYSQL_USER=mysql \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX=%&#123;install_dir&#125; \</span><br><span class="line">        -DMYSQL_DATADIR=/data/mariadb  \</span><br><span class="line">        -DWITH_XTRADB_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_FEDERATEDX_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_ARCHIVE_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_MYISAM_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_INNOBASE_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_ARCHIVE_STPRAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_SSL=system \</span><br><span class="line">        -DVITH_ZLIB=system \</span><br><span class="line">        -DWITH_LOBWRAP=0 \</span><br><span class="line">        -DDEFAULT_CHARSET=utf8 \</span><br><span class="line">        -DDEFAULT_COLLATION=utf8_general_ci \</span><br><span class="line">        -DENABLED_LOCAL_INFILE=ON \</span><br><span class="line">        -DWITH_PARTITION_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_PERFSCHEMA_STORAGE_ENGINE=1 \</span><br><span class="line">        -DWITH_READLINE=ON \</span><br><span class="line">        -DWITH_WSREP=ON \</span><br><span class="line">        -DWITH_INNODB_DISALLOW_WRITES=ON \</span><br><span class="line">        -DWITH_TOKUDB=1 \</span><br><span class="line">        -DCMAKE_CXX_COMPILER:FILEPATH=/usr/bin/g++ \</span><br><span class="line">        -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/gcc \</span><br><span class="line">        -DCMAKE_BUILD_TYPE:STRING=RELEASE</span><br><span class="line">make %&#123;?_smp_mflags&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">rm -rf %&#123;buildroot&#125;</span><br><span class="line">make install DESTDIR=%&#123;buildroot&#125;</span><br><span class="line"></span><br><span class="line">%pre</span><br><span class="line">groupadd -r mysql 2&gt; /dev/null</span><br><span class="line">useradd -g mysql -r -M -s /sbin/nologin mysql 2&gt; /dev/null</span><br><span class="line">mkdir -p /data/mariadb/data 2&gt; /dev/null</span><br><span class="line">mkdir -p /data/mariadb/binlog 2&gt; /dev/null</span><br><span class="line">mkdir -p /data/mariadb/undolog 2&gt; /dev/null</span><br><span class="line">mkdir -p /var/run/mariadb/ 2&gt; /dev/null</span><br><span class="line">mkdir -p /var/log/mariadb/ 2&gt; /dev/null</span><br><span class="line">chown -R mysql.mysql /var/run/mariadb/ 2&gt; /dev/null</span><br><span class="line">chown -R mysql.mysql /var/log/mariadb/ 2&gt; /dev/null</span><br><span class="line">chown -R mysql.mysql /data/mariadb 2&gt; /dev/null</span><br><span class="line"></span><br><span class="line">%clean </span><br><span class="line">rm -rf %&#123;buildroot&#125; </span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%defattr(-, root, root, 0755)</span><br><span class="line">%&#123;install_dir&#125;/</span><br><span class="line">%doc</span><br><span class="line"></span><br><span class="line">%changelog</span><br></pre></td></tr></table></figure><p>spec更加详细内容见 <a href="https://blog.csdn.net/XXJ19950917/article/details/81868456" target="_blank" rel="noopener">这里</a></p><h1 id="制作rpm包"><a href="#制作rpm包" class="headerlink" title="制作rpm包"></a>制作rpm包</h1><h2 id="上传必要的source文件"><a href="#上传必要的source文件" class="headerlink" title="上传必要的source文件"></a>上传必要的source文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp $&#123;some_where&#125;/Python-2.7.10.tgz ~/rpmbuild/SOURCES/</span><br></pre></td></tr></table></figure><h2 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a>开始制作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rpmbuild</span><br><span class="line">rpmbuild -bb --target x86_64 SPECS/python27-tstack.spec &gt; rpmbuild.log  &amp;</span><br></pre></td></tr></table></figure><p>一切顺利的话，最终会在~/rpmbuild/RPMS/x86_64/目录下找到编译好的rpm包。</p><h2 id="技巧总结"><a href="#技巧总结" class="headerlink" title="技巧总结"></a>技巧总结</h2><ul><li>不打debug的rpm包:在spec文件中加入<code>%debug\_package %{nil}</code>即可</li><li>禁止自动分析源码添加不应该加入的依赖 在spec文件中加入<code>Autoreq: 0</code>即可</li><li>sepc文件中一些宏的用法 在spec文件中经常出现一些宏，比如<code>%setup</code>、<code>%patch</code>，这两个宏的选项较多，使用时要特别注意，参见这里</li><li>安装卸载rpm包前后的动作 可以通过<code>%pre</code>, <code>%post</code>, <code>%preun</code>, <code>%postun</code>指定rpm包在安装卸载前后的动作，比如在安装前用脚本做一些准备、在安装后用脚本做一些初始化动作、在卸载前用脚本做一些准备、在卸载后用脚本做一些清理动作</li></ul><p>rpmbuild命令的选项 rpmbuild命令有不少选项，参见<a href="http://ftp.rpm.org/max-rpm/rpmbuild.8.html" target="_blank" rel="noopener">这里</a>，用得比较多的有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-bp 只解压源码及应用补丁</span><br><span class="line">-bc 只进行编译</span><br><span class="line">-bi 只进行安装到%&#123;buildroot&#125;</span><br><span class="line">-bb 只生成二进制rpm包</span><br><span class="line">-bs 只生成源码rpm包</span><br><span class="line">-ba 生成二进制rpm包和源码rpm包</span><br><span class="line">--target 指定生成rpm包的平台，默认会生成i686和x86_64的rpm包，但一般我只需要x86_64的rpm包</span><br></pre></td></tr></table></figure><h1 id="RPM-常用参数备忘"><a href="#RPM-常用参数备忘" class="headerlink" title="RPM 常用参数备忘"></a>RPM 常用参数备忘</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh ***.rpm: 安装软件(并且显示安装进度 --install--verbose--hash)</span><br><span class="line">rpm -Uvh ***.rpm: 升级软件(--Update)</span><br><span class="line">rpm -e: 卸载软件</span><br><span class="line">rpm -q [软件名称]: 查询程序是否安装</span><br><span class="line">rpm -qa: 查询已经安装的所有软件(Query All)</span><br><span class="line">rpm -qi [软件名称]: 列出该软件的详细信息</span><br><span class="line">rpm -qf [指定文件名]: 查找指定文件属于哪个RPM软件包(Query Files)</span><br><span class="line">rpm -qc [软件名称]: 列出该软件的所有文件</span><br><span class="line">rpm -qpi [软件名称]: 列出RPM软件包的描述信息(Query Packages install package(s))</span><br><span class="line">rpm -qpl [软件名称]: 列出该软件的所有文件(Query Packages list)</span><br><span class="line">rpm -qRp [软件名称]: 列出该软件的依赖(Query Rely Packages)</span><br><span class="line">rpm -Va [软件名称]: 校验所有的RPM软件包，查找丢失的文件(View List)</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何从python源码包构建rpm"><a href="#如何从python源码包构建rpm" class="headerlink" title="如何从python源码包构建rpm"></a>如何从python源码包构建rpm</h2><p>在python源码目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py bdist_rpm # 即可在当前dist目录下生成rpm包</span><br></pre></td></tr></table></figure><p>定制spec:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python setup.py bdist_rpm --spec-only # 只生成dist/&lt;module&gt;.spec</span><br><span class="line"># 重新编辑 dist/&lt;module&gt;.spec</span><br><span class="line">python setup.py bdist_rpm --spec-file=dist/&lt;module&gt;.spec</span><br></pre></td></tr></table></figure><h2 id="无污染地打rpm包"><a href="#无污染地打rpm包" class="headerlink" title="无污染地打rpm包"></a>无污染地打rpm包</h2><p>方法一、使用mock来进程打包，详细的过程可以见</p><p><a href="https://jeremy-xu.oschina.io/2018/04/centos%25E4%25B8%258B%25E6%2597%25A0%25E6%25B1%25A1%25E6%259F%2593%25E5%259C%25B0%25E6%2589%2593rpm%25E5%258C%2585/" target="_blank" rel="noopener">centos下无污染地打rpm包</a></p><blockquote><p>mock编包一般是做发行版本给别人使用，当然你做的软件要能在别人机器上跑，那么在开发过程中，我们必须模拟一个纯净的用户环境（即是所谓的chroot），mock在编包前先构建一个这样的用户环境，然后里面再使用rpmbuild的机制编包。</p></blockquote><p>总结来说，rpmbuild编出来的包是特例，而mock编出来包在具有共性。mock相当于给rpmbuild增加了一个外壳，包装了一下。</p><p>方法二、虚拟机操作</p><p>建议使用虚拟机操作，不要在自己的电脑上进行这些操作，不然到时候弄一大堆的包在自己电脑上很头疼的，如果没有虚拟机可以使用 <code>vagrant</code>在本地虚拟化出一个os进行操作 具体用法<a href="https://segmentfault.com/a/1190000000264347" target="_blank" rel="noopener">使用 Vagrant 打造跨平台开发环境</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir some-dir</span><br><span class="line"></span><br><span class="line">cd some-dir</span><br><span class="line"></span><br><span class="line">vagrant init centos/6</span><br><span class="line"></span><br><span class="line">vagrant up</span><br><span class="line"></span><br><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure><p>这两种方法各有各的好处，mock感觉有点像dock，只要编译完成后直接删除该mock环境就行，更加的纯洁迅速； 而Vagrant如果没有理解错他就是在本地安装了一个虚拟机，比起mock更重一些，但是可以比较轻松的应对更多的场景，比如说在本地开发的时候代码可以在不同的时候上调试，以后有时间一定要学习下这两种方式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>rpmbuild打包一般步骤</p><ul><li>根据rpmbuild标准，创建打包的目录结构</li><li>将源码和辅助文件放到指定目录</li><li>编写spec文件，放到指定目录</li><li>根据需要构建rpm，或者rpm和srpm等。</li></ul><p>无网络时提前在有网络的机器上下载好依赖包就好啦</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-hk" target="_blank" rel="noopener">How to create an RPM package/zh-hk</a></p><p><a href="https://jeremy-xu.oschina.io/2018/02/centos6%25252525E4%25252525B8%252525258Brpm%25252525E6%2525252589%2525252593%25252525E5%252525258C%2525252585%25252525E5%25252525AE%252525259E%25252525E6%2525252588%2525252598/" target="_blank" rel="noopener">CentOS6下rpm打包实战</a></p><p><a href="http://www.dahouduan.com/2015/06/15/linux-centos-make-rpm/" target="_blank" rel="noopener">Centos 6 制作 rpm 包</a></p><p><a href="https://blog.csdn.net/XXJ19950917/article/details/81664234" target="_blank" rel="noopener">Linux之rpm本地打包</a></p><p><a href="https://blog.csdn.net/u012609847/article/details/41916393" target="_blank" rel="noopener">SRPM包编译成RPM包之rpmbuild和mock</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：rpm包是预先在Linux主机上编译好并打包的文件，安装起来非常快捷。不需要再进行繁琐的编译等操作，拿来就能用，区别于yum包管理，rpm可以在不需要网络环境的情况下使用。学习完&lt;a href=&quot;https://jeremy-xu.oschina.io/2018/02/centos6%25252525E4%25252525B8%252525258Brpm%25252525E6%2525252589%2525252593%25252525E5%252525258C%2525252585%25252525E5%25252525AE%252525259E%25252525E6%2525252588%2525252598/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大神的文章&lt;/a&gt;还是有一些细节不太清楚，下面我就再对编译RPM包的过程和详细知识点再梳理扩展一下留作备忘。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://qupzhi.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://qupzhi.com/tags/linux/"/>
    
      <category term="持续集成" scheme="https://qupzhi.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="CI" scheme="https://qupzhi.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Redis运行优化</title>
    <link href="https://qupzhi.com/redis-better/"/>
    <id>https://qupzhi.com/redis-better/</id>
    <published>2019-04-21T12:18:00.000Z</published>
    <updated>2019-04-23T08:27:12.297Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：redis在运行的过程中如果使用不合适的配置会使其占用内存越来越大，在此我给出我自己的一些优化策略供大家参考，如果你看到我的文章有更好的方法和策略希望也能分享给我，我们一起交流，感激不尽！</p><a id="more"></a><h1 id="代码层级"><a href="#代码层级" class="headerlink" title="代码层级"></a>代码层级</h1><ul><li>去除代码里的scan操作</li><li>给每个key加过期时间</li><li>存储结构用hash</li></ul><h1 id="redis策略"><a href="#redis策略" class="headerlink" title="redis策略"></a>redis策略</h1><ul><li>绑定本机ip部署redis防止远程连接</li><li>maxmemory-policy allkeys-lru :从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放</li><li>maxmemory 12GB 根据实际调整大小</li></ul><h1 id="系统限制"><a href="#系统限制" class="headerlink" title="系统限制"></a>系统限制</h1><ul><li>内核参数 <code>sysctl.conf</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.overcommit_memory=1</span><br></pre></td></tr></table></figure></li></ul><p>Redis的RDB持久化实现是folk一个子进程，然后让子进程将内存镜像dump到RDB文件中。理论上来说是需要跟父进程一样的内存空间，但是由于linux很早就支持的copy-on-write技术，所以实际上并不需要这么多的物理内存的。（vm.overcommit_memory=1表示内核允许分配所有的物理内存，而不管当前的内存状态如何。）</p><ul><li>关闭透明大页功能<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></li></ul><p>(操作系统后台有一个叫做khugepaged的进程，它会一直扫描所有进程占用的内存，在可能的情况下会把4kpage交换为Huge Pages，在这个过程中，对于操作的内存的各种分配活动都需要各种内存锁，直接影响程序的内存访问性能，并且，这个过程对于应用是透明的，在应用层面不可控制,对于专门为4k page优化的程序来说，可能会造成随机的性能下降现象。)</p><h1 id="冷备方式"><a href="#冷备方式" class="headerlink" title="冷备方式"></a>冷备方式</h1><p>redis提供两种方式,他们是 RDB和AOF</p><ul><li><code>RDB</code> 将数据库的快照（snapshot）以二进制的方式保存到磁盘中。</li><li><code>AOF</code> 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><strong>优点</strong>：<br>节省磁盘空间、恢复速度快，就是一个镜像，适合大规模的数据恢复；<br>对数据完整性和一致性要求不高</p><p><strong>缺点</strong>：<br>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是会占用cpu性能。</p><h2 id="优化策略（改redis的配置）："><a href="#优化策略（改redis的配置）：" class="headerlink" title="优化策略（改redis的配置）："></a>优化策略（改redis的配置）：</h2><ul><li>AOF 与 RDB ，使用RDB方式<br>打开命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 指定本地数据库文件名，一般采用默认的 dump.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># save &lt;指定时间间隔&gt; &lt;执行指定次数更新操作&gt;，满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。</span></span><br><span class="line">若不想用RDB方案，可以把 save <span class="string">""</span> 的注释打开，下面三个注释。</span><br><span class="line"><span class="comment"># save ""</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="comment"># 指定本地数据库存放目录，一般也用默认配置</span></span><br><span class="line">dir ./</span><br><span class="line"><span class="comment"># 配置存储至本地数据库时是否压缩数据，默认为yes。</span></span><br><span class="line"><span class="comment"># Redis采用LZF压缩方式，但占用了一点CPU的时间。若关闭该选项，但会导致数据库文件变的巨大。建议开启。</span></span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><ul><li><p>关闭aof：<code>appendonly no</code><br>（appendfsync everysec：每一秒写入aof文件，并完成磁盘同步。<br>appendfsync no 不即时同步，由操作系统控制何时刷写到磁盘上，这种模式速度最快，减少io，数据安全性下降,但是会产生僵尸进程<br>appendfsync always：每个命令都写入aof文件，并完成磁盘同步）</p></li><li><p>为什么不使用AOF?</p><blockquote><p>AOF 是redis的一种持久化方式，用来记录所有的写操作，但是随着时间增加，aof文件会越来越大，所以需要进行重写，将内存中的数据重新以命令的方式写入aof文件。<br>在重写的过程中，由于redis还会有新的写入，为了避免数据丢失，会开辟一块内存用于存放重写期间产生的写入操作，等到重写完毕后会将这块内存中的操作再追加到aof文件中。</p></blockquote></li></ul><p>从原理中可以了解到，如果在重写过程中redis的写入很频繁或写入量很大，就会导致占用大量额外的内存来缓存写操作，导致内存爆涨。</p><p>命令行方式关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-03:6379&gt; config get appendonly</span><br><span class="line">1) <span class="string">"appendonly"</span></span><br><span class="line">2) <span class="string">"yes"</span></span><br><span class="line">redis-03:6379&gt; config <span class="built_in">set</span> appendonly no</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>绑定本机ip部署redis防止远程连接</li><li>aof 与 rdb 比较</li><li>代码层级：去除代码里的scan操作，给每个key加过期时间</li><li>存储结构用hash</li><li>maxmemory-policy allkeys-lru:从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放</li><li>关闭aof：appendonly no<br>（appendfsync everysec：每一秒写入aof文件，并完成磁盘同步。<br>appendfsync no 不即时同步，由操作系统控制何时刷写到磁盘上，这种模式速度最快，减少io，数据安全性下降,但是为产生僵尸进程<br>appendfsync always：每个命令都写入aof文件，并完成磁盘同步）</li><li>内核参数sysctl.conf<br>vm.overcommit_memory=1<br>Redis的RDB持久化实现是folk一个子进程，然后让子进程将内存镜像dump到RDB文件中。理论上来说是需要跟父进程一样的内存空间，但是由于linux很早就支持的copy-on-write技术，所以实际上并不需要这么多的物理内存的。（vm.overcommit_memory=1表示内核允许分配所有的物理内存，而不管当前的内存状态如何。）</li><li>关闭透明大页功能 echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br>(操作系统后台有一个叫做khugepaged的进程，它会一直扫描所有进程占用的内存，在可能的情况下会把4kpage交换为Huge Pages，在这个过程中，对于操作的内存的各种分配活动都需要各种内存锁，直接影响程序的内存访问性能，并且，这个过程对于应用是透明的，在应用层面不可控制,对于专门为4k page优化的程序来说，可能会造成随机的性能下降现象。)</li><li>maxmemory 12GB 根据实际调整大小</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.cnblogs.com/kreo/p/4423362.html" target="_blank" rel="noopener">redis.conf配置详细解析</a></p><p><a href="https://raw.githubusercontent.com/antirez/redis/3.0/redis.conf" target="_blank" rel="noopener">redis官网v3.0配置</a><br><a href="https://redis.io/topics/config" target="_blank" rel="noopener">redis官网配置</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：redis在运行的过程中如果使用不合适的配置会使其占用内存越来越大，在此我给出我自己的一些优化策略供大家参考，如果你看到我的文章有更好的方法和策略希望也能分享给我，我们一起交流，感激不尽！&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="https://qupzhi.com/categories/redis/"/>
    
    
      <category term="redis" scheme="https://qupzhi.com/tags/redis/"/>
    
      <category term="优化" scheme="https://qupzhi.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一起刷算法_动态规划01</title>
    <link href="https://qupzhi.com/leetcode-20190420/"/>
    <id>https://qupzhi.com/leetcode-20190420/</id>
    <published>2019-04-20T16:48:00.000Z</published>
    <updated>2019-04-23T08:27:24.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：本周我利用休息时间刷了两道简单、一道中等的动态规划算法题目，和大家一起分享一下，作为动态规划算法专题的开始。</p><a id="more"></a><p>我的主页 <a href="https://qupzhi.com">https://qupzhi.com</a> ，转载请注明出处。</p><ul><li>以下内容用go语言实现</li></ul><h1 id="动态规划三要素"><a href="#动态规划三要素" class="headerlink" title="动态规划三要素"></a>动态规划三要素</h1><p>三要素</p><ol><li>最优子结构性质，通俗的说法就是问题的最优解包含其子问题的最优解</li><li>边界</li><li>状态转移方程</li></ol><h1 id="重复求区间和"><a href="#重复求区间和" class="headerlink" title="重复求区间和"></a>重复求区间和</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你可以假设数组不可变。</span><br><span class="line">会多次调用 sumRange 方法。</span><br></pre></td></tr></table></figure><p>三种思路：</p><ol><li>直接根据每次传进来的区间进行现场计算</li><li>用一个Map，把每次传进来的区间拼成一个key,二次查询的时候就有了缓存</li><li>直接用一个1D的数组，每个元素存0到当前值之间的和，这样区间和就是两个下标存元素相减就可以了</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum *[]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">NumArray</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> obj NumArray</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">nums[k] = nums[k<span class="number">-1</span>] + v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum = &amp;nums</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span> <span class="title">SumRange</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (*sum)[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (*sum)[j] - (*sum)[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">obj := Constructor(arr)</span><br><span class="line">res := obj.SumRange(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="经典问题爬楼梯"><a href="#经典问题爬楼梯" class="headerlink" title="经典问题爬楼梯"></a>经典问题爬楼梯</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><br><span class="line"></span><br><span class="line">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line"></span><br><span class="line">注意：给定 n 是一个正整数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>因为每次都可以分解为1步和2步，边界就是1步2步，状态转移方程就是<code>f(n) = f(n-1) + f(n-2) (n&gt;=3)</code>,这里提供三种思路</p><ol><li>递归</li><li>字典</li><li>动态规划，每次都用前一次的值推倒后一次的答案</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// f(n) = f(n-1) +  f(n-2) (n&gt;=3)</span></span><br><span class="line"><span class="comment">// f(1) = 1</span></span><br><span class="line"><span class="comment">// f(2) = 2</span></span><br><span class="line"><span class="comment">// 方法一、递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs1</span><span class="params">(n <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> climbStairs1(n<span class="number">-1</span>) + climbStairs1(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二、动归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">res,a,b := <span class="number">0</span>,<span class="number">1</span> ,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">3</span>;i&lt;=n;i++&#123;</span><br><span class="line">res = a + b</span><br><span class="line">a = b</span><br><span class="line">b = res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(climbStairs1(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(climbStairs(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大正方形面积"><a href="#最大正方形面积" class="headerlink" title="最大正方形面积"></a>最大正方形面积</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">221. Maximal Square</span><br><span class="line">Medium</span><br><span class="line"></span><br><span class="line">1165</span><br><span class="line"></span><br><span class="line">29</span><br><span class="line"></span><br><span class="line">Favorite</span><br><span class="line"></span><br><span class="line">Share</span><br><span class="line">Given a 2D binary matrix filled with 0&apos;s and 1&apos;s, find the largest square containing only 1&apos;s and return its area.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>三种思路：</p><ol><li><p>方法一 逐渐增加连续的 ‘1’ 的长度 ，然后用一个函数去看是否构成正方形，构成的话就继续增加边长，直到找到最大的正方形为止<br>时间复杂 O((mn)^2) 空间 O(1)</p></li><li><p>方法二 用一个二维数组的的每个元素都来保存边长<br>每次只要遍历到的点是1，就开始取他的上、左、左上三个值取最小，再加1得到当前点的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[x,y] = min(min(dp[x-1][y],dp[x][y-1]) , dp[x-1][y-1])+1</span><br><span class="line">O(mn) O(mn)</span><br></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input [1,1,0][1,1,0]</span><br><span class="line"></span><br><span class="line">0000</span><br><span class="line">0110</span><br><span class="line">0120</span><br></pre></td></tr></table></figure></li></ol><ul><li>每次遍历总是要知道上一行的数据，所以至少得保留一行</li><li>可以发现，遍历到第三行的时候，第一行已经没有用了！</li><li>每次遍历的时候，假设只保留上一行，比如在第三行，每次走一位，我们要更新当前值，当前位置的马上的覆盖值对于下一次来说就是左上角的值（2*2）</li><li>对于这一次来说就是上，因为当前位置的左边已经更新了所以就是左，那我们当前就出现了左、上、左上三个值了，凑够了。</li><li>初始化就全0，prev=0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[y]=min(dp[y-1],dp[y],prev)</span><br><span class="line">O(mn) O(m)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare</span><span class="params">(matrix [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">    cols := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> rows&gt;<span class="number">0</span>&#123;</span><br><span class="line">    cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cols = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>,rows+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i &lt; <span class="built_in">len</span>(dp);i++&#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>,cols+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">maxlen := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">1</span>;x &lt;= rows; x++&#123;</span><br><span class="line"><span class="keyword">for</span> y:=<span class="number">1</span>;y &lt;= cols;y++&#123;</span><br><span class="line"><span class="keyword">if</span> matrix[x<span class="number">-1</span>][y<span class="number">-1</span>] == <span class="string">'1'</span>&#123;</span><br><span class="line">tmp := min(min(dp[x<span class="number">-1</span>][y],dp[x][y<span class="number">-1</span>]),dp[x<span class="number">-1</span>][y<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">dp[x][y]=tmp</span><br><span class="line">maxlen = max(maxlen,tmp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxlen * maxlen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare2</span><span class="params">(matrix [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">cols := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> rows&gt;<span class="number">0</span>&#123;</span><br><span class="line">cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cols = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>,cols +<span class="number">1</span>)</span><br><span class="line">maxlen,prev := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">1</span>;x &lt;= rows; x++&#123;</span><br><span class="line"><span class="keyword">for</span> y:=<span class="number">1</span>;y &lt;= cols;y++&#123;</span><br><span class="line">tmp := dp[y] <span class="comment">//当前值当下一次的prev</span></span><br><span class="line"><span class="keyword">if</span> matrix[x<span class="number">-1</span>][y<span class="number">-1</span>] == <span class="string">'1'</span>&#123;</span><br><span class="line">dp[y] = min(min(dp[y],dp[y<span class="number">-1</span>]),prev) + <span class="number">1</span> <span class="comment">//分别对应上，左，左上</span></span><br><span class="line">maxlen = max(dp[y],maxlen)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[y] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">prev = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxlen * maxlen</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">t1 :=[][]<span class="keyword">byte</span>&#123;&#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>&#125;,&#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,&#123;<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,&#123;<span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'0'</span>&#125;&#125;</span><br><span class="line">t2 :=[][]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">fmt.Println(maximalSquare(t2))</span><br><span class="line">fmt.Println(maximalSquare2(t1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：本周我利用休息时间刷了两道简单、一道中等的动态规划算法题目，和大家一起分享一下，作为动态规划算法专题的开始。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://qupzhi.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="go" scheme="https://qupzhi.com/tags/go/"/>
    
      <category term="动态规划" scheme="https://qupzhi.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="https://qupzhi.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Clion优雅的完全远程自动同步和远程调试c++</title>
    <link href="https://qupzhi.com/CLion_cplusplus/"/>
    <id>https://qupzhi.com/CLion_cplusplus/</id>
    <published>2019-03-23T16:15:00.000Z</published>
    <updated>2019-03-28T02:20:49.113Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：在linux上用vim写C++的时候，通常用gdb进行调试，不能随心所欲的看代码和跳转代码以及加watch（也有可能是因为我还没有get正确的使用方法）。为此我发现Clion可以做到自动同步本场代码或自己下载远程代码同步到本地，以及调试在远程机器上运行的代码，为此记录下来。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>CLion 是一款专为开发 C 及 C++ 所设计的跨平台 IDE。 它是以 IntelliJ 为基础设计的，包含了许多智能功能来提高开发人员的生产力，从而提升工作效率 。</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>操作系统： macOS / Windows</li><li>IDE: CLion</li><li>源码路径： Node Master</li></ul><h2 id="自动同步"><a href="#自动同步" class="headerlink" title="自动同步"></a>自动同步</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/m5yp1prpd2.png" alt="设置远程链接"></p><ul><li>打开CLion的设置，进入到 Preferences | Build, Execution, Deployment | Deployment</li><li>点加号，添加一个远程配置</li><li>设置为SFTP协议，设置远程ip、port、pass然后点击Test Connection，确认是否连接成功</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/7dbjy7qjbq.png" alt="设置本地与远程的连接映射"></p><ul><li>切换到Mappings</li><li>设置本地的代码根目录Local path</li><li>设置远程的代码根目录 Deployment path</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/pan9mqntc4.png" alt="上传一个文件"></p><ul><li>上传一个文件</li><li>Upload是上传，Download是下载，本地与远程所映射的目录我们在上面设置过了</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/wr4bweudok.png" alt="上传效果"></p><ul><li>上传成功</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/vue27xyw6z.png" alt="查看更新的文件"></p><ul><li>runlvm.sh文件更新成功，现在的时间是3月18 21：42</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/pvzxfvew68.png" alt="设置自己同步"></p><ul><li>在Tool - Deployment - Automatic Upload(always) 设置为自动同步</li><li>自动同步的话可以在每次在本地改动代码的时候自己同步了</li><li>Sync with Deployed to 就是自动下载远程代码到本地</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/lcw6j8a39.png" alt="上传整个项目"></p><ul><li>手动上传整个项目<br><img src="https://ask.qcloudimg.com/http-save/3097464/8z5xoufas9.png" alt="上传成功"></li><li>上传成功，上传了100个文件<br><img src="https://ask.qcloudimg.com/http-save/3097464/0vkn70nyyu.png" alt="查看上传效果"></li><li>查看远程目录，确实成功了</li></ul><p>好了，现在只要在本地有任何的改动都会自动同步到远程了。</p><h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><h3 id="CentOS的依赖依赖"><a href="#CentOS的依赖依赖" class="headerlink" title="CentOS的依赖依赖"></a>CentOS的依赖依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cmake</span><br><span class="line">yum install cmake -y</span><br><span class="line"></span><br><span class="line"># gcc &amp; gdb</span><br><span class="line">yum install gcc-c++ -y</span><br><span class="line">yum install gdb -y</span><br><span class="line"></span><br><span class="line">#gdbserver</span><br><span class="line">yum install gdb-gdbserver -y</span><br></pre></td></tr></table></figure><h3 id="添加GDB-Remote-Debug"><a href="#添加GDB-Remote-Debug" class="headerlink" title="添加GDB Remote Debug"></a>添加GDB Remote Debug</h3><h4 id="本地克利翁配置"><a href="#本地克利翁配置" class="headerlink" title="本地克利翁配置"></a>本地克利翁配置</h4><p><img src="https://ask.qcloudimg.com/http-save/3097464/eneeda2ix8.png" alt="添加远程调试设置"></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/a3zpmnp8n7.png" alt="添加GDB Remote Debug"></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/n0vg56swwd.png" alt="设置gdb remote配置"></p><ul><li>添加一个GDB远程调试的配置 GDB Remote Debug</li><li>设置远程访问参数（target remote args）： tcp:xx.xx.xx.xx:1234</li><li>设置远程路径和本地路径的映射（Path mappings）</li><li>远程调试连接成功后，像本地调试一样，可以设置断点，单步跟踪等</li><li>调试需要本地和远程的代码一致</li></ul><h4 id="两个方法设置远程配置"><a href="#两个方法设置远程配置" class="headerlink" title="两个方法设置远程配置"></a>两个方法设置远程配置</h4><p><strong>方法一、</strong> 远程gdbserver的启动</p><p>远程调试依赖gdbserver的来支持，通过gdbserver的启动的程序，会先等待远程调试的连接，连接成功后再启动进程。</p><p>假设代码的根目录：<code>/data/pzqu/read_phy_disk_use/</code>,执行以下代码以后编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /data/pzqu/read_phy_disk_use/build</span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug</span><br><span class="line">make</span><br><span class="line">gdbserver :1234 ./read_phy_disk_use</span><br></pre></td></tr></table></figure><p>注意：cmake的指定需要-DCMAKE_BUILD_TYPE=Debug来请获取调试</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/852j23091e.png" alt=""></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/bs4njqjxug.png" alt=""></p><p><strong>方法二</strong> 远程gdbserver的动态连接</p><p>gdbserver的还支持动态绑定到已经启动的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver :1234 --attach &lt;PID&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ask.qcloudimg.com/http-save/3097464/61iogksac1.png" alt="attash成功后"></p><h4 id="打断点开始调试"><a href="#打断点开始调试" class="headerlink" title="打断点开始调试"></a>打断点开始调试</h4><p><img src="https://ask.qcloudimg.com/http-save/3097464/gv3yl58273.png" alt="开始调试"></p><ul><li>点击小虫子开始调试</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/p9c16zmxck.png" alt="打断点"></p><ul><li>我们可以看到代码停止到了断点处</li><li>Variables 是可以自己设置的watch</li><li>和正常调试方式一样啦</li></ul><h2 id="用CLion完全的在远程工作"><a href="#用CLion完全的在远程工作" class="headerlink" title="用CLion完全的在远程工作"></a>用CLion完全的在远程工作</h2><p>这是一个非常非常爽的操作，以后就可以完全的用IDE来写代码了，虽然使用命令行显得比较专业，但是使用工具可以有效的提高工作效率，何乐而不为呢？</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/4mh05vqi3m.png" alt="设置Toolchains工具链"></p><ul><li>进入 Preferences | Build, Execution, Deployment | Toolchains</li><li>设置远程连接信息，CLion会自动监测CMake gcc g++ gdb的信息</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/h50rct3myj.png" alt="设置cmake"></p><ul><li>进入Preferences | Build, Execution, Deployment | CMake</li><li>Toolchain 选择我们刚刚设置的</li><li>上面的<code>Automatically reload CMake project on editing</code> 的设置勾上的时候，只要代码有修改就会自动编译</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/j2g4u2lt3f.png" alt="编译成功"></p><ul><li>现在已经配置了远程Toolchains工具链并配置了相应的CMake配置文件</li><li>上图是自动编译和上传到的目录<code>/tmp/tmp.pIdETgMIBR</code>，然后我们只要设置为自动同步目录就成了，如下图<br><img src="https://ask.qcloudimg.com/http-save/3097464/x5fczhw4e2.png" alt="设置为自动同步目录"></li><li>现在已经设置成了自动同步目录，只需在运行/调试配置切换器中选择正确的CMake配置文件，即可以完全远程的方式构建，运行和调试应用程序和测试。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/pqfxqntnbb.png" alt="添加Application"></p><ul><li>添加Application来跑我们的程序<br><img src="https://ask.qcloudimg.com/http-save/3097464/ut0wkrf2rd.png" alt="远程运行"></li><li>远程运行，本地输出结果<br><img src="https://ask.qcloudimg.com/http-save/3097464/zyr4wb886q.png" alt="远程调试"></li><li>远程运行，本地自动调试</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>配置CLion中的同步信息：同步到哪台机器的哪个目录。</li><li>使用 Deployment 让本地和远程可以自动同步和自动下载，手动同步和手动下载代码</li><li>配置GDB remote Debug设置</li><li>使用gdbserver来启动程序进行调试</li><li>使用gdbserver attach依附已经启动的程序进行调试</li><li>完全在本地进行远程代码调试</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>这种方式是不是非常的优雅，这样我们只要不断的添加工具链（Toolchains）就可以在本地应对数不清的远程环境了。</li><li>这种方式应该适用于JetBrain全家桶</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：在linux上用vim写C++的时候，通常用gdb进行调试，不能随心所欲的看代码和跳转代码以及加watch（也有可能是因为我还没有get正确的使用方法）。为此我发现Clion可以做到自动同步本场代码或自己下载远程代码同步到本地，以及调试在远程机器上运行的代码，为此记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="IDE" scheme="https://qupzhi.com/categories/IDE/"/>
    
    
      <category term="工具" scheme="https://qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="C++" scheme="https://qupzhi.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何用cmake编译</title>
    <link href="https://qupzhi.com/how-to-use-cmake/"/>
    <id>https://qupzhi.com/how-to-use-cmake/</id>
    <published>2019-03-13T03:05:00.000Z</published>
    <updated>2019-03-28T02:24:09.589Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库</p><a id="more"></a><h1 id="CentOS的依赖依赖"><a href="#CentOS的依赖依赖" class="headerlink" title="CentOS的依赖依赖"></a>CentOS的依赖依赖</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cmake</span></span><br><span class="line">yum install cmake -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc &amp; gdb</span></span><br><span class="line">yum install gcc-c++ -y</span><br><span class="line">yum install gdb -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">gdbserver</span></span><br><span class="line">yum install gdb-gdbserver -y</span><br></pre></td></tr></table></figure><h1 id="CMake编译原理"><a href="#CMake编译原理" class="headerlink" title="CMake编译原理"></a>CMake编译原理</h1><p>CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。因此CMake的编译基本就两个步骤：</p><ol><li>cmake</li><li>make</li></ol><h1 id="compile-sh"><a href="#compile-sh" class="headerlink" title="compile.sh"></a>compile.sh</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -rdynamic ../include/incl/tfc_base_config_file.cpp ../include/mq/*.cpp local_util.cpp AgentMemRpt.cpp AgentDiskRpt.cpp AgentLoadRpt.cpp AgentIoRpt.cpp AgentNetRpt.cpp AgentCpuRpt.cpp AgentProcessRpt.cpp AgentParentRpt.cpp AgentSysTop_5.cpp BaseFeatureRptMain.cpp -o rpt_main -I../include/incl -I../include/mq -I../include/rapidjson -lpthread -ldl</span><br></pre></td></tr></table></figure><h1 id="CMake说明"><a href="#CMake说明" class="headerlink" title="CMake说明"></a>CMake说明</h1><p>一般把CMakeLists.txt文件放在工程目录下，使用时，先创建一个叫build的文件夹（这个并非必须，因为cmake命令指向CMakeLists.txt所在的目录，例如cmake .. 表示CMakeLists.txt在当前目录的上一级目录。cmake后会生成很多编译的中间文件以及makefile文件，所以一般建议新建一个新的目录，专门用来编译），然后执行下列操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd build </span><br><span class="line">cmake .. </span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>其中cmake .. 在build里生成Makefile，make根据生成makefile文件，编译程序，make应当在有Makefile的目录下，根据Makefile生成可执行文件。</p><h1 id="编写-CMakeList-txt"><a href="#编写-CMakeList-txt" class="headerlink" title="编写 CMakeList.txt"></a>编写 CMakeList.txt</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># 1. 声明要求的cmake最低版本</span><br><span class="line">cmake_minimum_required( VERSION 2.8 )</span><br><span class="line"></span><br><span class="line"># 2. 添加c++11标准支持</span><br><span class="line">#set( CMAKE_CXX_FLAGS &quot;-std=c++11&quot; )</span><br><span class="line"></span><br><span class="line"># 3. 声明一个cmake工程</span><br><span class="line">PROJECT(rpt_main)</span><br><span class="line"></span><br><span class="line">MESSAGE(STATUS &quot;Project: SERVER&quot;) #打印相关消息消息</span><br><span class="line">  </span><br><span class="line"># 4. 头文件</span><br><span class="line">include_directories(</span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/../include/mq </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/../include/incl </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/../include/rapidjson</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 5. 通过设定SRC变量，将源代码路径都给SRC，如果有多个，可以直接在后面继续添加</span><br><span class="line">set(SRC </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/../include/incl/tfc_base_config_file.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/../include/mq/tfc_ipc_sv.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/../include/mq/tfc_net_ipc_mq.cpp</span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/../include/mq/tfc_net_open_mq.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/local_util.cpp</span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentMemRpt.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentDiskRpt.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentLoadRpt.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentIoRpt.cpp</span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentNetRpt.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentCpuRpt.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentProcessRpt.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentParentRpt.cpp</span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/AgentSysTop_5.cpp </span><br><span class="line">$&#123;PROJECT_SOURCE_DIR&#125;/BaseFeatureRptMain.cpp </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 6. 创建共享库/静态库</span><br><span class="line"></span><br><span class="line"># 设置路径（下面生成共享库的路径）</span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 即生成的共享库在工程文件夹下的lib文件夹中</span><br><span class="line"> </span><br><span class="line">set(LIB_NAME rpt_main_lib)</span><br><span class="line"># 创建共享库（把工程内的cpp文件都创建成共享库文件，方便通过头文件来调用）</span><br><span class="line"># 这时候只需要cpp，不需要有主函数 </span><br><span class="line"># $&#123;PROJECT_NAME&#125;是生成的库名 表示生成的共享库文件就叫做 lib工程名.so</span><br><span class="line"># 也可以专门写cmakelists来编译一个没有主函数的程序来生成共享库，供其它程序使用</span><br><span class="line"># SHARED为生成动态库，STATIC为生成静态库</span><br><span class="line">add_library($&#123;LIB_NAME&#125; STATIC $&#123;SRC&#125;)</span><br><span class="line"> </span><br><span class="line"># 7. 链接库文件</span><br><span class="line"># 把刚刚生成的$&#123;LIB_NAME&#125;库和所需的其它库链接起来</span><br><span class="line"># 如果需要链接其他的动态库，-l后接去除lib前缀和.so后缀的名称，以链接</span><br><span class="line"># libpthread.so 为例,-lpthread</span><br><span class="line">target_link_libraries($&#123;LIB_NAME&#125; pthread dl)</span><br><span class="line">   </span><br><span class="line"># 8. 编译主函数，生成可执行文件</span><br><span class="line"># 先设置路径</span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line">   </span><br><span class="line"># 可执行文件生成</span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC&#125;)</span><br><span class="line">   </span><br><span class="line"># 这个可执行文件所需的库（一般就是刚刚生成的工程的库咯）</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; pthread dl $&#123;LIB_NAME&#125;)</span><br></pre></td></tr></table></figure><h1 id="使用-cmake"><a href="#使用-cmake" class="headerlink" title="使用 cmake"></a>使用 cmake</h1><ul><li>进入<code>/home/pzqu/agent/libvirt_base_feature/build</code>目录</li><li>执行命令 <code>cmake ..</code></li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/b3ll7cp1f4.png" alt="cmake .."></p><ul><li>查看生成的目录结构，此目录结构是中间代码，不用提交到git</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@TJSJZVM000456 /home/pzqu/agent/libvirt_base_feature/build]# tree</span><br><span class="line">.</span><br><span class="line">|-- CMakeCache.txt</span><br><span class="line">|-- CMakeFiles</span><br><span class="line">| |-- 2.8.12.2</span><br><span class="line">| | |-- CMakeCCompiler.cmake</span><br><span class="line">| | |-- CMakeCXXCompiler.cmake</span><br><span class="line">| | |-- CMakeDetermineCompilerABI_C.bin</span><br><span class="line">| | |-- CMakeDetermineCompilerABI_CXX.bin</span><br><span class="line">| | |-- CMakeSystem.cmake</span><br><span class="line">| | |-- CompilerIdC</span><br><span class="line">| | | |-- CMakeCCompilerId.c</span><br><span class="line">| | | `-- a.out</span><br><span class="line">| | `-- CompilerIdCXX</span><br><span class="line">| | |-- CMakeCXXCompilerId.cpp</span><br><span class="line">| | `-- a.out</span><br><span class="line">| |-- CMakeDirectoryInformation.cmake</span><br><span class="line">| |-- CMakeOutput.log</span><br><span class="line">| |-- CMakeTmp</span><br><span class="line">| |-- Makefile.cmake</span><br><span class="line">| |-- Makefile2</span><br><span class="line">| |-- TargetDirectories.txt</span><br><span class="line">| |-- cmake.check_cache</span><br><span class="line">| |-- progress.marks</span><br><span class="line">| |-- rpt_main.dir</span><br><span class="line">| | |-- DependInfo.cmake</span><br><span class="line">| | |-- build.make</span><br><span class="line">| | |-- cmake_clean.cmake</span><br><span class="line">| | |-- depend.make</span><br><span class="line">| | |-- flags.make</span><br><span class="line">| | |-- home</span><br><span class="line">| | | `-- pzqu</span><br><span class="line">| | | `-- agent</span><br><span class="line">| | | `-- include</span><br><span class="line">| | | |-- incl</span><br><span class="line">| | | `-- mq</span><br><span class="line">| | |-- link.txt</span><br><span class="line">| | `-- progress.make</span><br><span class="line">| `-- rpt_main_lib.dir</span><br><span class="line">| |-- DependInfo.cmake</span><br><span class="line">| |-- build.make</span><br><span class="line">| |-- cmake_clean.cmake</span><br><span class="line">| |-- cmake_clean_target.cmake</span><br><span class="line">| |-- depend.make</span><br><span class="line">| |-- flags.make</span><br><span class="line">| |-- home</span><br><span class="line">| | `-- pzqu</span><br><span class="line">| | `-- agent</span><br><span class="line">| | `-- include</span><br><span class="line">| | |-- incl</span><br><span class="line">| | `-- mq</span><br><span class="line">| |-- link.txt</span><br><span class="line">| `-- progress.make</span><br><span class="line">|-- Makefile</span><br><span class="line">`-- cmake_install.cmake</span><br></pre></td></tr></table></figure><ul><li>使用make命令编译得到二进制文件</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/t20fiy29so.png" alt="make"></p><ul><li>二进制文件所在目录（CMakeLists.txt文件配置）</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/o314wsfh0m.png" alt="成功生成二进制文件"></p><p>下次教大家如何用Clion自动同步代码到服务器上，并进行debug</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库&lt;/p&gt;
    
    </summary>
    
      <category term="IDE" scheme="https://qupzhi.com/categories/IDE/"/>
    
    
      <category term="C++" scheme="https://qupzhi.com/tags/C/"/>
    
      <category term="cmake" scheme="https://qupzhi.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>linux系统 物理硬盘监控</title>
    <link href="https://qupzhi.com/linux-disk-monitor/"/>
    <id>https://qupzhi.com/linux-disk-monitor/</id>
    <published>2019-03-13T03:03:00.000Z</published>
    <updated>2019-03-28T02:23:00.003Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：监控系统在linux系统上获取物理磁盘IO以及使用情况的原理，让我们一起来探索一下</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文使用语言为c++</span><br></pre></td></tr></table></figure><h1 id="物理磁盘列表和磁盘IO"><a href="#物理磁盘列表和磁盘IO" class="headerlink" title="物理磁盘列表和磁盘IO"></a>物理磁盘列表和磁盘IO</h1><p>第一步要解决的问题是先识别物理磁盘是哪些。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/5ychbg4s21.png" alt="/proc/diskstats"></p><ul><li>上图是<code>/proc/diskstats</code>的文件内容部分截取，我们可以通过读取<code>/proc/diskstats</code>获得物理磁盘列表以确认哪些是物理设备（算云硬盘）以及iops等信息</li><li>1-5列：设备号、编号、设备、读完成次数、合并完成次数</li><li>6-10列：读扇区次数、读操作花费毫秒数、写完成次数、合并写完成次数、写扇区次数</li><li>11-14列：写操作花费的毫秒数、正在处理的输入/输出请求数、输入/输出操作花费的毫秒数、输入/输出操作花费的加权毫秒数。</li></ul><p>那这个文件内如此多的设备哪些是物理硬盘呢？只要达到下面两个限制条件就判定为物理硬盘。</p><ol><li>该行有14列，可以使用<code>sscanf</code>取到设备名</li><li>此行中的设备名组装成<code>/sys/block/设备名/device</code>，然后看此文件夹是否存在，如果存在则是物理磁盘设备</li></ol><ul><li>备注1：判断文件/文件夹是否存在使用函数<code>access(syspath, F_OK)</code>，存在返回0</li><li>备注2：如果设备名为中含有<code>/</code>的话要转换成<code>!</code>,如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while ((slash = strchr(name, &apos;/&apos;))) &#123;</span><br><span class="line"> *slash = &apos;!&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>备注3：目录<code>/sys/block</code>下的所有子目录代表着系统中当前被发现的所有块设备（其中的内容已经变为了指向它们在/sys/devices/中真实设备的符号链接文件）</li></ul><p>到此我们就取到了物理硬盘的iops，接下来我们来看看使用情况和总量是如何拿到的。</p><h1 id="物理磁盘使用情况-和总量"><a href="#物理磁盘使用情况-和总量" class="headerlink" title="物理磁盘使用情况 和总量"></a>物理磁盘使用情况 和总量</h1><h2 id="物理磁盘使用量"><a href="#物理磁盘使用量" class="headerlink" title="物理磁盘使用量"></a>物理磁盘使用量</h2><p>因为我们没有办法直接取到物理硬盘的使用情况，所以我们用一种间接的方式。根据分区和物理硬盘的关系获得物理硬盘的使用情况。比如一个物理硬盘<code>sda</code>分了<code>sda1 sda2</code>等两个分区，又知道<code>sda1</code>的挂载点是<code>/data</code>,<code>sda2</code>的挂载点是<code>/home</code>，通过某种方式查出<code>/data</code>和<code>home</code>的使用情况，加起来就是<code>sda</code>的使用情况了。</p><p>我们可以，然后再通过获取挂载点大小的方式知道这些设备的使用情况。<code>/etc/mtab</code>中不会直接物理硬盘的信息，所以只能通过把属于这个物理硬盘的全部分区加起来才能最后算出我们想要的值。</p><h3 id="使用情况计算逻辑"><a href="#使用情况计算逻辑" class="headerlink" title="使用情况计算逻辑"></a>使用情况计算逻辑</h3><ul><li>通过读<code>/etc/mtab</code>的方式拿到各种设备和它的挂载点。（<code>/etc/mtab</code>文件中不会直接给出物理硬盘的使用情况）</li><li>使用<code>statfs</code>获得所挂载的目录使用情况来确定每个设备的使用情况</li><li>根据分区和物理硬盘的关系获得物理硬盘的使用情况（通常物理磁盘的名称是分区的子串，比如<code>/dev/sda</code>是<code>/dev/sda1</code>的子串）</li></ul><p>tips: 物理磁盘设备的名称列表我们已经在上一节取到了。</p><h4 id="通过-etc-mtab文件拿到各种设备和它的挂载点"><a href="#通过-etc-mtab文件拿到各种设备和它的挂载点" class="headerlink" title="通过/etc/mtab文件拿到各种设备和它的挂载点"></a>通过<code>/etc/mtab</code>文件拿到各种设备和它的挂载点</h4><p>知道了计算逻辑，我们来看看<code>/etc/mtab</code>文件内容的含义</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/wpg7njpudu.png" alt="/etc/mtab"></p><ul><li>上图是<code>/etc/mtab</code>的内容截取，可以读取<code>/etc/mtab</code>文件获取设备名和挂载点</li><li>此文件每行有四列，分别代表的含义是：驱动器、挂载点、文件系统、读写权限</li><li><code>/etc/mtab</code>记载了当前系统已经装载的文件系统，包括一些操作系统虚拟文件，使用<code>/etc/fstab</code>也可以监控，不同的是<code>/etc/mtab</code>文件在<code>mount</code>挂载、<code>umount</code>卸载时都会被更新，时刻跟踪当前系统中的分区挂载情况。</li></ul><p>用到了以下核心c++函数（读取/etc/mtab）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mount_table = setmntent(&quot;/etc/mtab&quot;, &quot;r&quot;); //打开文件系统描述文件的文件名，并且返回可以被使用的文件指针getmntent().</span><br><span class="line">mount_entry = getmntent(mount_table);//函数读取文件系统的下一行来自文件流的描述文件并返回指向结构的指针（即循环读取文件）</span><br><span class="line">device = mount_entry-&gt;mnt_fsname;</span><br><span class="line">mount_point = mount_entry-&gt;mnt_dir;</span><br><span class="line">statfs(mount_point, &amp;s) != 0 //此条件成立时获取成功</span><br><span class="line">endmntent(mount_table);//关闭流和与其相关联的文件系统描述文件。</span><br></pre></td></tr></table></figure><p>具体用法见 <a href="https://blog.csdn.net/lixiaogang_theanswer/article/details/79431318" target="_blank" rel="noopener">linux中getmntent、setmntent 、endmntent 函数的详细用法</a></p><h4 id="通过statfs函数所挂载的目录使用情况-used-total-来确定每个分区的使用情况"><a href="#通过statfs函数所挂载的目录使用情况-used-total-来确定每个分区的使用情况" class="headerlink" title="通过statfs函数所挂载的目录使用情况(used/total)来确定每个分区的使用情况"></a>通过<code>statfs</code>函数所挂载的目录使用情况(used/total)来确定每个分区的使用情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/vfs.h&gt;    /* 或者 &lt;sys/statfs.h&gt; */</span><br><span class="line"></span><br><span class="line">// path: 需要查询信息的文件系统的文件路径名。 如/home</span><br><span class="line">// buf：以下结构体的指针变量，用于储存文件系统相关的信息</span><br><span class="line">int statfs(const char *path, struct statfs *buf); </span><br><span class="line">// fd： 需要查询信息的文件系统的文件描述词。</span><br><span class="line">int fstatfs(int fd, struct statfs *buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct statfs </span><br><span class="line">&#123; </span><br><span class="line">   long    f_type;     /* 文件系统类型  */ </span><br><span class="line">   long    f_bsize;    /* 经过优化的传输块大小  */ </span><br><span class="line">   long    f_blocks;   /* 文件系统数据块总数 */ </span><br><span class="line">   long    f_bfree;    /* 可用块数 */ </span><br><span class="line">   long    f_bavail;   /* 非超级用户可获取的块数 */ </span><br><span class="line">   long    f_files;    /* 文件结点总数 */ </span><br><span class="line">   long    f_ffree;    /* 可用文件结点数 */ </span><br><span class="line">   fsid_t  f_fsid;     /* 文件系统标识 */ </span><br><span class="line">   long    f_namelen;  /* 文件名的最大长度 */ </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回说明：</p><ul><li>成功执行时，返回0。失败返回-1</li><li>statfs结构中可用空间块数有两种f_bfree和 f_bavail，前者是硬盘所有剩余空间，后者为非root用户剩余空间，ext3文件系统给root用户分有5%的独享空间，所以这里是不同的地方。这里要强调的是每块的大小一般是4K（×这句话错误，不一定都是4k，正确做法是:总大小=sfs.f_blocks×f_bsize，即块数×每块的大小，单位是bytes，也就是要/1024/1024/1024才是GB单位）。</li></ul><p>计算分区的使用情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define M (1024*1024)</span><br><span class="line"></span><br><span class="line">    blocks_used = s.f_blocks - s.f_bfree; //使用量</span><br><span class="line"></span><br><span class="line">    blocks_percent_used = 0;</span><br><span class="line"></span><br><span class="line">    if (blocks_used + s.f_bavail) </span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">     blocks_percent_used = blocks_used * 100 / (blocks_used + s.f_bavail); //使用率</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* GNU coreutils 6.10 skips certain mounts, try to be compatible. */</span><br><span class="line"></span><br><span class="line">    if (strcmp(device, &quot;rootfs&quot;) == 0)</span><br><span class="line"></span><br><span class="line">     continue;</span><br><span class="line"></span><br><span class="line">    Record record;</span><br><span class="line"></span><br><span class="line">    record.disk_total_val = CalRound((blocks_used + s.f_bavail) * s.f_bsize, M); //总量</span><br><span class="line"></span><br><span class="line">    record.disk_use_val = CalRound((s.f_blocks - s.f_bfree) * s.f_bsize, M);  //</span><br><span class="line"></span><br><span class="line">    record.use_precent = blocks_percent_used;</span><br></pre></td></tr></table></figure><ul><li>CalRound函数的作用是四舍五入，感兴趣可以拉到文章底部看代码。</li><li>在获取使用量情况失败的时候，可能是因为没有挂载获取其他特殊的情况，我们就默认使用量为0</li><li>备注1：<code>/dev/root</code>设备可以从<code>/proc/cmdline</code>中获取到真实设备名</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/zuy7d1p7ln.png" alt=""></p><ul><li>备注2：<code>rootfs</code>设备要忽略，此为根文件系统（内核启动时所mount的第一个文件系统）</li></ul><h3 id="如果出现lvm格式的逻辑分区怎么计算使用量？"><a href="#如果出现lvm格式的逻辑分区怎么计算使用量？" class="headerlink" title="如果出现lvm格式的逻辑分区怎么计算使用量？"></a>如果出现lvm格式的逻辑分区怎么计算使用量？</h3><p><img src="https://ask.qcloudimg.com/http-save/3097464/yphpw4cbut.png" alt=""></p><p>我们根据上面的逻辑可以取到正常一般情况下的part类型的分区使用量，加到物理硬盘中去；如上图，出现lvm格式分区的时候，<code>/etc/mtab</code>中就没有sda2设备的信息，而且sda2也没有挂载在任意一个文件系统上。这个时候就要拿到sda2下面挂载的三个lvm分区的使用情况。下图是lsblk的输出结果：</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ljbvtesuq1.png" alt=""></p><p>可以看到上图中,有一个逻辑卷（dm-2），同时挂在sda2和sdb1上，这是怎么回事？这就要从lvm的概念开始讲起了。</p><p><strong>什么是lvm分区？</strong></p><blockquote><p><strong>LVM的重点</strong>是可以弹性调整文件系统的容量，并不是如RAID在于对文件的读写性能或是数据的可靠性上。LVM可以将多个物理分区整合在一起，让这些分区看起来就像是一个磁盘一样，而且，还可以在将来添加其他的物理分区或将其从这个LVM管理的磁盘中删除。这样一来，整个硬盘的空间使用上，相当具有弹性。</p></blockquote><p><img src="https://ask.qcloudimg.com/http-save/3097464/5pdonabodl.png" alt="pv vg lv架构"></p><p>这里介绍三个概念：</p><ul><li>PV(physical volume)：物理卷在逻辑卷管理系统最底层，可为整个物理硬盘或实际物理硬盘上的分区。</li><li>VG(volume group)：卷组建立在物理卷上，一卷组中至少要包括一物理卷，卷组建立后可动态的添加卷到卷组中，一个逻辑卷管理系统工程中可有多个卷组。</li><li>LV(logical volume)：逻辑卷建立在卷组基础上，卷组中未分配空间可用于建立新的逻辑卷，逻辑卷建立后可以动态扩展和缩小空间。</li></ul><p>我们知道了这些就够了，怎么计算lvm格式的使用量并规到物理硬盘上呢？</p><p>我们要知道他的写入方式，才能知道算法。<strong>lvm有两种写入方式</strong></p><p>LVM写入方式：</p><ul><li>线性模式（linear）：假如有/dev/sdb1,/dev/sdb2这2个分区加入到VG当中，并且整个VG只有一个LV时，那么所谓的线性模式就是当/dev/sdb1的容量用完之后，/dev/sdb2的分区才会被使用。在此模式下，使用量就按顺序算到所挂的分区上去。</li><li>交错模式（triped）：将一条数据拆分成两部分，分别写入/dev/sdb1与/dev/sdb2，有点像RAID0。这样子，一份数据用两块硬盘来写入，理论上，读写性能会比较好。在此模式下，使用量就按平均到所挂的分区上去，可能会有点细微的差别，但这是相对准确的方式了。</li></ul><p><strong>如何取到lvm类型</strong></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/w8386uvkwa.png" alt=""></p><p>执行lvm相关的命令之前必须要安装lvm2这个软件，不过CentOS和其他比较新的Linux发行版已经默认安装了lvm的所需软件，何况我们这里的目的是监控已经创建lvm分区的linux机器（lsblk看到的），那一定有这些软件，就不用担心这个问题了。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ssp0n12jn9.png" alt=""></p><p>但是比较老的版本没有这些参数，比如</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/1nmo3duwpw.png" alt=""></p><p>那我们用这种方式</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/aa7bknrgo5.png" alt=""></p><p>ps:直接解析<code>/proc/swaps</code>的内容有一样的效果哦</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/omepvslgv8.png" alt=""></p><p>现在我们取到了dm-1设备的使用情况和总量，正常来说可以结合lsblk的结果和对应到磁盘上，但是问题来了，有的lsblk输出结果不带有dm-1这种字样，那怎么办呢？</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/nsu7q3wmfu.png" alt=""></p><p>不用怕，我们可以利用VG和LV的名称找到他们的软链接（符号链接）。再用c++的readlink函数取到符号链接所指向的文件</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/2tynf377fj.png" alt=""></p><p><em><strong><u>ps: 大家可以看到，这里的lvm使用量都是用命令方式来采集的，如果你有读文件或者系统api等更好的方式，希望你可以留言和我交流，非常感谢！</u></strong></em></p><h2 id="物理磁盘总量"><a href="#物理磁盘总量" class="headerlink" title="物理磁盘总量"></a>物理磁盘总量</h2><p>我们可以直接根据磁盘名（比如/dev/sda）来获取磁盘总量,无论是否有lvm分区，以下是核心代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unsigned long long AgentDiskRpt::readDiskTotal(const string &amp;deviceName)</span><br><span class="line">&#123;</span><br><span class="line"> int fd, ret;</span><br><span class="line"> unsigned long long size;</span><br><span class="line"></span><br><span class="line"> fd = open(deviceName.c_str(), O_RDONLY);</span><br><span class="line"></span><br><span class="line"> if (fd == -1)</span><br><span class="line"> &#123;</span><br><span class="line">  close(fd);</span><br><span class="line">  return -1;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = ioctl(fd, BLKGETSIZE64, &amp;size);</span><br><span class="line"></span><br><span class="line"> if (ret == 0) &#123;</span><br><span class="line">  close(fd);</span><br><span class="line">     return CalRound(size,M);</span><br><span class="line"> &#125;</span><br><span class="line"> close(fd);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遇到nas硬盘怎么计算？"><a href="#遇到nas硬盘怎么计算？" class="headerlink" title="遇到nas硬盘怎么计算？"></a>遇到nas硬盘怎么计算？</h3><blockquote><p>NAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。</p></blockquote><p>nas硬盘，采集的时候当作逻辑磁盘，不是物理硬盘，他是共享的，多个用户共享一块nas盘的时候可以共享数据，所以nas盘不应该统计成物理磁盘，我们这里就没有算作，可以算作逻辑分区，直接在<code>/etc/mtab</code>里就能读到啦。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="CalRound函数"><a href="#CalRound函数" class="headerlink" title="CalRound函数"></a>CalRound函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unsigned long long CalRound(unsigned long long value, int base)</span><br><span class="line">&#123;</span><br><span class="line"> unsigned long long ret = 0;</span><br><span class="line"> if (base &lt;= 1)</span><br><span class="line">  return value;</span><br><span class="line"> unsigned long long tmp = base / 2;</span><br><span class="line"> if (tmp &lt;= 0)</span><br><span class="line">  tmp = 1;</span><br><span class="line"> if (value % base &gt;= tmp)</span><br><span class="line">  ret = value / base + 1;</span><br><span class="line"> else</span><br><span class="line">  ret = value / base;</span><br><span class="line"> return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.metsky.com/archives/711.html" target="_blank" rel="noopener">Linux /etc/fstab和etc/mtab有什么区别</a></p><p><a href="https://blog.csdn.net/swj9099/article/details/78890165/" target="_blank" rel="noopener">statfs</a></p><p><a href="https://blog.csdn.net/lixiaogang_theanswer/article/details/79431318" target="_blank" rel="noopener">linux中getmntent、setmntent 、endmntent 函数的详细用法</a></p><p><a href="https://blog.51cto.com/10316297/2105919" target="_blank" rel="noopener">LVM动态逻辑卷理论详解</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：监控系统在linux系统上获取物理磁盘IO以及使用情况的原理，让我们一起来探索一下&lt;/p&gt;
    
    </summary>
    
      <category term="监控" scheme="https://qupzhi.com/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="C++" scheme="https://qupzhi.com/tags/C/"/>
    
      <category term="linux" scheme="https://qupzhi.com/tags/linux/"/>
    
      <category term="监控" scheme="https://qupzhi.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq 原理、集群、基本运维操作、常见故障处理</title>
    <link href="https://qupzhi.com/rabbitmq-learn01/"/>
    <id>https://qupzhi.com/rabbitmq-learn01/</id>
    <published>2019-02-16T14:31:00.000Z</published>
    <updated>2019-03-04T11:14:50.320Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要:本次学习主要针对运维人员，和对rabbitmq不熟悉的开发人员。通过本次学习你将掌握rabbitmq 的基本原理、集群、基本运维操作、常见故障处理</p><p>用时：25 分钟</p><a id="more"></a><h2 id="原理与概念"><a href="#原理与概念" class="headerlink" title="原理与概念"></a>原理与概念</h2><p>用时：9 分钟</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。</p><p>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>RabbitMQ就是当前最主流的消息中间件之一。</p><ul><li>两个（多个）系统间需要通过定时任务来同步某些数据</li><li>异构系统的不同进程间相互调用、通讯的问题</li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue（队列）是RabbitMQ的内部对象，用于存储消息，用下图表示。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/2rmxyd3keu.png" alt=""></p><p>RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/7qb2l35nds.png" alt=""></p><p>多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ndf2dmmehz.png" alt=""></p><h3 id="技术术语"><a href="#技术术语" class="headerlink" title="技术术语"></a>技术术语</h3><ul><li>Broker：简单来说就是消息队列服务器实体。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作权限分离，把不同的系统使用的rabbitmq区分开，共用一个消息队列服务器，但看上去就像各自在用不用的rabbitmq服务器一样。</li><li>Connection:一个网络连接，比如TCP/IP套接字连接。</li><li>channel：消息通道，是建立在真实的TCP连接内的虚拟连接（是我们与RabbitMQ打交道的最重要的一个接口）。仅仅创建了客户端到Broker之间的连接后，客户端还是不能发送消息的,需要为每一个Connection创建Channel，AMQP协议规定只有通过Channel才能执行AMQP的命令。AMQP的命令都是通过信道发送出去的（我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。）。每条信道都会被指派一个唯一ID。在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务,理论上无限制，减少TCP创建和销毁的开销，实现共用TCP的效果。之所以需要Channel，是因为TCP连接的建立和释放都是十分昂贵的，如果一个客户端每一个线程都需要与Broker交互，如果每一个线程都建立一个TCP连接，暂且不考虑TCP连接是否浪费，就算操作系统也无法承受每秒建立如此多的TCP连接。<br>注1：一个生产者或一个消费者与MQ服务器之间只有一条TCP连接<br>注2：RabbitMQ建议客户端线程之间不要共用Channel，至少要保证共用Channel的线程发送消息必须是串行的，但是建议尽量共用Connection。</li><li>Exchange：消息交换机，生产者不是直接将消息投递到Queue中的，实际上是生产者将消息发送到Exchange（交换器，下图中的X），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。<br><img src="https://ask.qcloudimg.com/http-save/3097464/b65ot5xw2u.png" alt="exchange"></li><li>Exchange Types<br>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述），之后会分别进行介绍。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。<br><img src="https://ask.qcloudimg.com/http-save/3097464/47j88fen2g.png" alt="binding"></li><li>Routing Key：路由关键字，生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。<br><img src="https://ask.qcloudimg.com/http-save/3097464/vnt5k2zqlg.png" alt=""><br>在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。</li><li>Prefetch count<br>前面我们讲到如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。<br><img src="https://ask.qcloudimg.com/http-save/3097464/iq9ntw3nvn.png" alt="prefetchCount"></li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/00aas67oy3.png" alt="prefetchCount"></p><h3 id="消息队列的使用过程"><a href="#消息队列的使用过程" class="headerlink" title="消息队列的使用过程"></a>消息队列的使用过程</h3><p>在AMQP模型中，Exchange是接受生产者消息并将消息路由到消息队列的关键组件。ExchangeType和Binding决定了消息的路由规则。所以生产者想要发送消息，首先必须要声明一个Exchange和该Exchange对应的Binding。</p><p>在Rabbit MQ中，声明一个Exchange需要三个参数：ExchangeName，ExchangeType和Durable。ExchangeName是该Exchange的名字，该属性在创建Binding和生产者通过publish推送消息时需要指定。ExchangeType，指Exchange的类型，在RabbitMQ中，有三种类型的Exchange：direct ，fanout和topic，不同的Exchange会表现出不同路由行为。Durable是该Exchange的持久化属性，这个会在消息持久化章节讨论。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/vpppdwmyg2.png" alt="声明一个Exchange"></p><p>声明一个Binding需要提供一个QueueName，ExchangeName和BindingKey。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/vnt5k2zqlg.png" alt="声明一个Binding"></p><p>下面是消息发送的过程</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/v5ihkivlz8.png" alt=""></p><ol><li>建立连接Connection。由producer和consumer创建连接，连接到broker的物理节点上。</li><li>建立消息Channel。Channel是建立在Connection之上的，一个Connection可以建立多个Channel。producer连接Virtual Host 建立Channel，Consumer连接到相应的queue上建立Channel。</li><li>发送消息。由Producer发送消息到Broker中的Exchange中。</li><li>路由转发。生产者Producer在发送消息时，都需要指定一个RoutingKey和Exchange，Exchange收到消息后可以看到消息中指定的RoutingKey，再根据当前Exchange的ExchangeType,按一定的规则将消息转发到相应的queue中去。</li><li>消息接收。Consumer会监听相应的queue，一旦queue中有可以消费的消息，queue就将消息发送给Consumer端。</li><li>消息确认。当Consumer完成某一条消息的处理之后，需要发送一条ACK消息给对应的Queue。Queue收到ACK信息后，才会认为消息处理成功，并将消息从Queue中移除；如果在对应的Channel断开后，Queue没有收到这条消息的ACK信息，该消息将被发送给另外的Channel。至此一个消息的发送接收流程走完了。消息的确认机制提高了通信的可靠性。</li></ol><h3 id="exchange-与-Queue-的路由机制"><a href="#exchange-与-Queue-的路由机制" class="headerlink" title="exchange 与 Queue 的路由机制"></a>exchange 与 Queue 的路由机制</h3><p><img src="https://ask.qcloudimg.com/http-save/3097464/2dad7dbmhd.png" alt="exchange type"></p><p>exchange 将消息发送到哪一个queue是由exchange type 和bing 规则决定的，目前常用的有3种exchange，Direct exchange, Fanout exchange, Topic exchange 。</p><ul><li>Direct exchange 直接转发路由，其实现原理是通过消息中的routkey，与queue 中的routkey 进行比对，若二者匹配，则将消息发送到这个消息队列。通常使用这个。<br><img src="https://ask.qcloudimg.com/http-save/3097464/pvw1l5nz1j.png" alt="Direct"><br>以上图的配置为例，我们以routingKey=”error”发送消息到Exchange，则消息会路由到Queue1（amqp.gen-S9b…，这是由RabbitMQ自动生成的Queue名称）和Queue2（amqp.gen-Agl…）；如果我们以routingKey=”info”或routingKey=”warning”来发送消息，则消息只会路由到Queue2。如果我们以其他routingKey发送消息，则消息不会路由到这两个Queue中。</li><li>Fanout exchange 复制分发路由，该路由不需要routkey，当exchange收到消息后，将消息复制多份转发给与自己绑定的消息队列。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/qrhh0rwx28.png" alt="Fanout"></p><p>上图中，生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。</p><ul><li>topic exchange 通配路由，是direct exchange的通配符模式，消息中的routkey可以写成通配的模式，exchange支持“#”和“*” 的通配。收到消息后，将消息转发给所有符合匹配表达式的queue。<br><img src="https://ask.qcloudimg.com/http-save/3097464/qiitbakkc1.png" alt="topic"><br>以上图中的配置为例，routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。</li></ul><p>需要注意的一点只有queue具有</p><p>保持消息的功能，exchange不能保存消息。</p><ul><li>headers<br>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。<br>该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。</li></ul><h3 id="durability-持久化与非持久化队列"><a href="#durability-持久化与非持久化队列" class="headerlink" title="durability 持久化与非持久化队列"></a>durability 持久化与非持久化队列</h3><p><img src="https://ask.qcloudimg.com/http-save/3097464/7iyjx2zc1d.png" alt="如何识别"></p><ol><li>如何识别？<br>如上图，在Features字段里有一个<code>D</code>,就是持久化队列，英文durable（持久的）</li><li>持久化队列和非持久化队列的区别是什么？<br>持久化队列会被保存在磁盘中，固定并持久的存储，当Rabbit服务重启后，该队列会保持原来的状态在RabbitMQ中被管理，而非持久化队列不会被保存在磁盘中，Rabbit服务重启后队列就会消失。</li><li>如何选择？<br>如果需要队列的完整性，数据在队列中的保存是必须不允许丢失的，那么可以使用持久化。而当需要获取的信息是实时的，或者是随机的信息，不需要信息的精确性或完整性，但是追求获取性能，可以选择非持久化队列。</li></ol><h2 id="分布式集群架构和高可用性"><a href="#分布式集群架构和高可用性" class="headerlink" title="分布式集群架构和高可用性"></a>分布式集群架构和高可用性</h2><p>用时：5 分钟</p><h3 id="设计集群的目的"><a href="#设计集群的目的" class="headerlink" title="设计集群的目的"></a>设计集群的目的</h3><ul><li>允许消费者和生产者在RabbitMQ节点崩溃的情况下继续运行</li><li>通过增加更多的节点来扩展消息通信的吞吐量</li></ul><h3 id="集群配置方式"><a href="#集群配置方式" class="headerlink" title="集群配置方式"></a>集群配置方式</h3><p>RabbitMQ可以通过三种方法来部署分布式集群系统，分别是：cluster,federation,shovel</p><ul><li>cluster:<ol><li>不支持跨网段，用于同一个网段内的局域网</li><li>可以随意的动态增加或者减少</li><li>节点之间需要运行相同版本的RabbitMQ和Erlang</li></ol></li><li>federation:应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器上交换机或队列的消息，可以是单独机器或集群。federation队列类似于单向点对点连接，消息会在联盟队列之间转发任意次，直到被消费者接受。通常使用federation来连接internet上的中间服务器，用作订阅分发消息或工作队列。</li><li>shovel:连接方式与federation的连接方式类似，但它工作在更低层次。可以应用于广域网</li></ul><h4 id="RabbitMQ-cluster-集群同步原理"><a href="#RabbitMQ-cluster-集群同步原理" class="headerlink" title="RabbitMQ cluster 集群同步原理"></a>RabbitMQ cluster 集群同步原理</h4><p><img src="https://ask.qcloudimg.com/http-save/3097464/iy7916utbo.png" alt="rabbitmq cluster"></p><p>上面图中采用三个节点组成了一个RabbitMQ的集群，Exchange A的元数据信息在所有节点上是一致的，而Queue（存放消息的队列）的完整数据则只会存在于它所创建的那个节点上。，其他节点只知道这个queue的metadata信息和一个指向queue的owner node的指针。</p><h5 id="RabbitMQ集群元数据的同步"><a href="#RabbitMQ集群元数据的同步" class="headerlink" title="RabbitMQ集群元数据的同步"></a>RabbitMQ集群元数据的同步</h5><p>RabbitMQ集群会始终同步四种类型的内部元数据（类似索引）：</p><ol><li>队列元数据：队列名称和它的属性；</li><li>交换器元数据：交换器名称、类型和属性；</li><li>绑定元数据：一张简单的表格展示了如何将消息路由到队列；</li><li>vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性；<br>因此，当用户访问其中任何一个RabbitMQ节点时，通过rabbitmqctl查询到的queue／user／exchange/vhost等信息都是相同的。</li></ol><h6 id="为何RabbitMQ集群仅采用元数据同步的方式"><a href="#为何RabbitMQ集群仅采用元数据同步的方式" class="headerlink" title="为何RabbitMQ集群仅采用元数据同步的方式"></a>为何RabbitMQ集群仅采用元数据同步的方式</h6><p>一，存储空间，如果每个集群节点都拥有所有Queue的完全数据拷贝，那么每个节点的存储空间会非常大，集群的消息积压能力会非常弱（无法通过集群节点的扩容提高消息积压能力）；</p><p>二，性能，消息的发布者需要将消息复制到每一个集群节点，对于持久化消息，网络和磁盘同步复制的开销都会明显增加。</p><h4 id="RabbitMQ-cluster-集群的两种模式"><a href="#RabbitMQ-cluster-集群的两种模式" class="headerlink" title="RabbitMQ cluster 集群的两种模式"></a>RabbitMQ cluster 集群的两种模式</h4><ol><li>普通模式：默认的集群模式。</li><li>镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/b7ejh8fgjq.png" alt="普通模式同步方式"></p><p><strong>普通模式</strong>：当消息进入A节点的Queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer，所以consumer应平均连接每一个节点，从中取消息。该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。如果做了队列持久化或消息持久化，那么得等A节点恢复，然后才可被消费，并且在A节点恢复之前其它节点不能再创建A节点已经创建过的持久队列；如果没有持久化的话，消息就会失丢。这种模式更适合非持久化队列，只有该队列是非持久的，客户端才能重新连接到集群里的其他节点，并重新创建队列。假如该队列是持久化的，那么唯一办法是将故障节点恢复起来。</p><p>为什么RabbitMQ不将队列复制到集群里每个节点呢？这与它的集群的设计本意相冲突，集群的设计目的就是增加更多节点时，能线性的增加性能（CPU、内存）和容量（内存、磁盘）。当然RabbitMQ新版本集群也支持队列复制（有个选项可以配置）。比如在有五个节点的集群里，可以指定某个队列的内容在2个节点上进行存储，从而在性能与高可用性之间取得一个平衡（应该就是指镜像模式）。</p><p><strong>镜像模式</strong>：其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用.</p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul><li>RAM node:内存节点将所有的队列、交换机、绑定、用户、权限和vhost的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。</li><li>Disk node:将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启RabbitMQ的时候，丢失系统的配置信息。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/gaauyabn3s.png" alt="如何查看是何种节点"></p><p>如果是内存结点这里就显示为RAM</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>RabbitMQ要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。</li><li>如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作(包括创建队列、交换器、绑定，添加用户、更改权限、添加和删除集群结点)，直到节点恢复。</li><li>解决方案：设置两个磁盘节点，至少有一个是可用的，可以保存元数据的更改。</li></ul><h3 id="Erlang-Cookie"><a href="#Erlang-Cookie" class="headerlink" title="Erlang Cookie"></a>Erlang Cookie</h3><p>Erlang Cookie是保证不同节点可以相互通信的密钥，要保证集群中的不同节点相互通信必须共享相同的Erlang Cookie。具体的目录存放在<code>/var/lib/rabbitmq/.erlang.cookie</code>。</p><h2 id="基本运维操作"><a href="#基本运维操作" class="headerlink" title="基本运维操作"></a>基本运维操作</h2><p>用时：8 分钟</p><h3 id="rabbitmq集群必要条件"><a href="#rabbitmq集群必要条件" class="headerlink" title="rabbitmq集群必要条件"></a>rabbitmq集群必要条件</h3><h4 id="绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法"><a href="#绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法" class="headerlink" title="绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法"></a>绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#编辑配置路径 /etc/rabbitmq/rabbitmq-env.conf</span><br><span class="line">NODE_IP_ADDRESS=172.16.136.133</span><br></pre></td></tr></table></figure><h4 id="配置域名映射到实体ip"><a href="#配置域名映射到实体ip" class="headerlink" title="配置域名映射到实体ip"></a>配置域名映射到实体ip</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#配置文件1所在路径 /etc/rabbitmq/rabbitmq.config (如果是集群，每台机器都需要修改这个绑定本机实体ip)</span><br><span class="line">#其中rabbit@master是创建集群时所配置的参数，@后面的参数为主机名，示例中为master</span><br><span class="line">[</span><br><span class="line">    &#123;rabbit, [</span><br><span class="line">    &#123;cluster_nodes, &#123;[&apos;rabbit@master&apos;], disc&#125;&#125;,</span><br><span class="line">    &#123;cluster_partition_handling, ignore&#125;,</span><br><span class="line">    &#123;default_user, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;default_pass, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;tcp_listen_options, [binary,</span><br><span class="line">        &#123;packet, raw&#125;,</span><br><span class="line">        &#123;reuseaddr, true&#125;,</span><br><span class="line">        &#123;backlog, 128&#125;,</span><br><span class="line">        &#123;nodelay, true&#125;,</span><br><span class="line">        &#123;exit_on_close, false&#125;,</span><br><span class="line">        &#123;keepalive, true&#125;]&#125;</span><br><span class="line">    ]&#125;,</span><br><span class="line">    &#123;kernel, [</span><br><span class="line">        &#123;inet_dist_listen_max, 44001&#125;,</span><br><span class="line">        &#123;inet_dist_listen_min, 44001&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#配置文件2 所在路径 /etc/hosts (如果是集群，每台机器都需要修改这个绑定本机实体ip，而且hosts文件的映射不得重复，如果重复linux系统为以最下面一条记录为准)</span><br><span class="line">172.16.136.133 master</span><br><span class="line">172.16.136.134 venus</span><br><span class="line">172.16.136.135 venus2</span><br></pre></td></tr></table></figure><h3 id="启动停止"><a href="#启动停止" class="headerlink" title="启动停止"></a>启动停止</h3><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#机器A</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器C</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>方式1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#机器A</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器C</span><br><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure><p>方式2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><h3 id="集群重启顺序"><a href="#集群重启顺序" class="headerlink" title="集群重启顺序"></a>集群重启顺序</h3><p>集群重启的顺序是固定的，并且是相反的。 如下所述：</p><p>启动顺序：磁盘节点 =&gt; 内存节点</p><p>关闭顺序：内存节点 =&gt; 磁盘节点</p><p>最后关闭必须是磁盘节点，不然可能回造成集群启动失败、数据丢失等异常情况。</p><h3 id="重建集群"><a href="#重建集群" class="headerlink" title="重建集群"></a>重建集群</h3><blockquote><p>注1：此处的mq集群重建是比较快速和有效的方法，面向的是初次安装或者可以接受mq中所存有的数据丢失的情况下，必须先有mq的.json后缀的配置文件或者有把握写入集群中exchange、queue等配置。</p></blockquote><h4 id="按顺序停止所有机器中的rabbitmq"><a href="#按顺序停止所有机器中的rabbitmq" class="headerlink" title="按顺序停止所有机器中的rabbitmq"></a>按顺序停止所有机器中的rabbitmq</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#机器A</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器C</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br></pre></td></tr></table></figure><h4 id="移除rabbitmq配置记录与存储文件"><a href="#移除rabbitmq配置记录与存储文件" class="headerlink" title="移除rabbitmq配置记录与存储文件"></a>移除rabbitmq配置记录与存储文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#位于 /var/lib/rabbitmq/mensia</span><br><span class="line">mv /var/lib/rabbitmq/mensia /var/lib/rabbitmq/mensia.bak</span><br></pre></td></tr></table></figure><h4 id="按顺序启动所有机器中的rabbitmq"><a href="#按顺序启动所有机器中的rabbitmq" class="headerlink" title="按顺序启动所有机器中的rabbitmq"></a>按顺序启动所有机器中的rabbitmq</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#机器C</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器A</span><br><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure><h4 id="停止被加入集群节点app"><a href="#停止被加入集群节点app" class="headerlink" title="停止被加入集群节点app"></a>停止被加入集群节点app</h4><blockquote><p>比如A、B、C三台机器，将B和C加入到A中去，需要执行以下命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#机器B</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">#机器C</span><br><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><h4 id="建立集群"><a href="#建立集群" class="headerlink" title="建立集群"></a>建立集群</h4><blockquote><p>注意此处master为唯一没有执行<code>rabbitmqctl stop_app</code>的机器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#机器B</span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br><span class="line">#机器C</span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br></pre></td></tr></table></figure><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#机器B</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">#机器C</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h4 id="检查集群状态"><a href="#检查集群状态" class="headerlink" title="检查集群状态"></a>检查集群状态</h4><p>在任意一台机器上执行<code>rabbitmqctl cluster_status</code>命令即可检查，输出包含集群中的节点与运行中的节点，兼以主机名标志</p><h4 id="添加集群配置"><a href="#添加集群配置" class="headerlink" title="添加集群配置"></a>添加集群配置</h4><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><blockquote><p>例子中创建了两个用户</p></blockquote><p>添加用户<code>add_user</code>,设置角色<code>set_user_tags</code>,添加rabbitmq虚拟主机<code>add_vhost</code>，设置访问权限<code>set_permissions</code>,以下是详细用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建第一个用户</span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名 administrator</span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p /  用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"># 创建第二个用户</span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名2 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名2 management </span><br><span class="line">/usr/sbin/rabbitmqctl add_vhost sip_ext </span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p sip_ext 用户名2 &apos;.*&apos; &apos;.*&apos; &apos;.*&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">备注：RabbitMQ 虚拟主机，RabbitMQ 通过虚拟主机（vhost）来分发消息。拥有自己独立的权限控制，不同的vhost之间是隔离的，单独的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限控制的基本单位：vhost。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户只能访问与之绑定的vhost。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vhost是AMQP中唯一无法通过协议来创建的基元。只能通过rabbitmqctl工具来创建。</span><br></pre></td></tr></table></figure><h5 id="打开15672网页管理端，访问mq"><a href="#打开15672网页管理端，访问mq" class="headerlink" title="打开15672网页管理端，访问mq"></a>打开15672网页管理端，访问mq</h5><p><code>/usr/sbin/rabbitmq-plugins enable rabbitmq_management</code></p><p>备注：如果发现命令执行完毕没有打开此服务，15672端口没有监听，则是由于没有重启mq导致的</p><h5 id="在底部导入-json后缀的配置文件即可"><a href="#在底部导入-json后缀的配置文件即可" class="headerlink" title="在底部导入.json后缀的配置文件即可"></a>在底部导入.json后缀的配置文件即可</h5><p><a href="http://localhost:4000/first-blog/rabbitmq.jpg" target="_blank" rel="noopener">http://localhost:4000/first-blog/rabbitmq.jpg</a></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/8izjwkkyiy.png" alt=""></p><p>如果覆盖了用户需要使用以下命令修改mq用户密码</p><p><code>/usr/sbin/rabbitmqctl change_password 用户名 密码</code></p><h3 id="修改节点类型"><a href="#修改节点类型" class="headerlink" title="修改节点类型"></a>修改节点类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line">rabbitmqctl change_cluster_node_type dist</span><br><span class="line"></span><br><span class="line">rabbitmqctl change_cluster_node_type ram</span><br><span class="line"></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://ask.qcloudimg.com/http-save/3097464/nnpdnkn0vi.png" alt="常用命令"></p><h2 id="常见故障"><a href="#常见故障" class="headerlink" title="常见故障"></a>常见故障</h2><p>用时：3 分钟</p><ul><li>集群状态异常<ol><li><code>rabbitmqctl cluster_status</code>检查集群健康状态，不正常节点重新加入集群</li><li>分析是否节点挂掉，手动启动节点。</li><li>保证网络连通正常</li></ol></li><li>队列阻塞、数据堆积<ol><li>保证网络连通正常</li><li>保证消费者正常消费，消费速度大于生产速度</li><li>保证服务器TCP连接限制合理</li></ol></li><li>脑裂<ol><li>按正确顺序重启集群</li><li>保证网络连通正常</li><li>保证磁盘空间、cpu、内存足够</li></ol></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.2cto.com/kf/201804/736770.html" target="_blank" rel="noopener">RabbitMQ简介、信道（channel）</a></p><p><a href="https://www.cnblogs.com/diegodu/p/4971586.html" target="_blank" rel="noopener">RabbitMQ基础概念详细介绍</a></p><p><a href="https://www.cnblogs.com/luxiaoxun/p/3918054.html" target="_blank" rel="noopener">RabbitMQ的几种典型使用场景</a></p><p><a href="https://blog.csdn.net/qq_33314107/article/details/80172042" target="_blank" rel="noopener">AMQP介绍</a></p><p><a href="https://blog.csdn.net/WoogeYu/article/details/51119101" target="_blank" rel="noopener">RabbitMQ分布式集群架构</a></p><p><a href="https://juejin.im/post/5b586b125188257bcb59005e#heading-1" target="_blank" rel="noopener">RabbitMQ系列（六）你不知道的RabbitMQ集群架构全解</a></p><p><a href="https://www.jianshu.com/p/6376936845ff" target="_blank" rel="noopener">消息中间件—RabbitMQ（集群原理与搭建篇)</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要:本次学习主要针对运维人员，和对rabbitmq不熟悉的开发人员。通过本次学习你将掌握rabbitmq 的基本原理、集群、基本运维操作、常见故障处理&lt;/p&gt;&lt;p&gt;用时：25 分钟&lt;/p&gt;
    
    </summary>
    
      <category term="rabbitmq" scheme="https://qupzhi.com/categories/rabbitmq/"/>
    
    
      <category term="rabbitmq" scheme="https://qupzhi.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Git合并不同url的项目</title>
    <link href="https://qupzhi.com/git-merge-remote-url/"/>
    <id>https://qupzhi.com/git-merge-remote-url/</id>
    <published>2019-01-23T06:17:00.000Z</published>
    <updated>2019-03-10T03:53:59.128Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：为了让项目能实现Git+Gerrit+Jenkin的持续集成，我们把项目从Git上迁移到了Gerrit上，发现有的同事在老Git提交代码，因为Gerrit做了同步，在Gerrit上有新提交的时候就会刷新老git，这样就会把他提交的代码冲掉。这个时候我就必须要在两个相似项目之间合并提交了。</p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p><img src="https://ask.qcloudimg.com/http-save/3097464/q3kgc08gho.png" alt="将老Git url加到我们新Git的本地"></p><ul><li>使用命令<code>git remote add [shortname] [url]</code>将老Git url加到我们新Git的本地</li><li>这里我把他取名为gitoa_web（随便取）</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/n3s2iemons.png" alt="查看"></p><ul><li>使用命令<code>git remot -v</code>查看远程仓库的情况</li><li>可以看到此处我们有三个远程仓库分别名为<code>gerrit</code>、 <code>gitoa_web</code>、<code>origin</code></li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/igqp6cgec6.png" alt="同步代码"></p><ul><li>使用命令<code>git fetch gitoa_web</code>刷新远程仓库到本地</li><li>字符串 <code>gitoa_web</code> 指代对应的仓库地址了.比如说,要抓取所有 <code>gitoa_web</code> 有的,但本地仓库没有的信息,可以用</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/s6togtxnim.png" alt="合并项目"></p><ul><li>使用命令<code>git merge gitoa_web/master</code>合并项目</li><li><code>gitoa_web</code>是指代仓库，<code>master</code>指代分支，当然如果有需要也可以合并别的分支过来<br><img src="https://ask.qcloudimg.com/http-save/3097464/en9j6iqfl.png" alt="报错"></li><li>发现不同email地址错误不能成功提交</li><li>因为这个<code>commit</code>不是我的</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/efy8b6q2gw.png" alt="修正错误"></p><ul><li>把email地址更新成我的</li><li>再提交就成功了</li></ul><h2 id="保留原有的commit用户"><a href="#保留原有的commit用户" class="headerlink" title="保留原有的commit用户"></a>保留原有的commit用户</h2><p>在上一节我们</p><ul><li>先使用命令<code>git remote add [shortname] [url]</code>将老Git url加到我们新Git的本地</li><li>使用命令<code>git fetch gitoa_web</code>刷新远程仓库到本地</li><li>最后使用命令<code>git merge gitoa_web/master</code>将老项目合并到新项目上再提交</li></ul><p>这种在新项目的master上，合并老项目的方式会存在问题（就是如果不是自己的<code>commit</code>会过不了<code>push</code>），后来我遇到了项目进行迁移的需求，经过测试只要反过来，位于老的项目上，<code>push</code>到新的项目就不会出现这样的问题了。</p><p>如下</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/da174rd4kk.png" alt="已有代码推于已有项目"></p><ul><li><code>git clone 老项目</code></li><li><code>git remote add gerrit 新项目git链接</code></li><li><code>cd 项目名</code> 此时我们就位于已有代码</li><li><code>git push gerrit master</code>此时就是把已有代码推于已有项目</li></ul><p>思考：为什么会出现这样的问题呢？</p><ul><li>因为在新的项目上合并老项目的代码，对于新项目来说是新的代码提交，所以只允许你一个人来提交</li><li>如果在老项目上，给新项目推代码这种顺序就是已有代码推到已有仓库</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>知识点：</p><ol><li><code>git merge</code>还可以合并其他项目的到本项目</li><li><code>git fetch 仓库名</code>可以指定同步哪个仓库</li><li><code>git remot -v</code>查看本地有哪些远程仓库的情况，包含各个仓库url</li></ol><p>本次我们对以下命令加深了理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote                                    #不带参数，列出已经存在的远程分支</span><br><span class="line">git remote -v                                 #(-v是–verbose 的简写,取首字母)列出详细信息，在每一个名字后面列出其远程url</span><br><span class="line">git remote add [shortname] [url]              #添加远程仓库</span><br><span class="line">git fetch origin                              #字符串 origin 指代对应的仓库地址了.比如说,要抓取所有 origin 有的,但本地仓库没有的信息,可以用</span><br></pre></td></tr></table></figure><p>ps: 这里<code>git remote add</code>以后，我认为还能用<code>cherry-pick</code>来加不同仓库的<code>commit</code>过来，有兴趣的朋友可以自己尝试。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p><a href="https://qupzhi.com/git-start2/#more">Git常用命令</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：为了让项目能实现Git+Gerrit+Jenkin的持续集成，我们把项目从Git上迁移到了Gerrit上，发现有的同事在老Git提交代码，因为Gerrit做了同步，在Gerrit上有新提交的时候就会刷新老git，这样就会把他提交的代码冲掉。这个时候我就必须要在两个相似项目之间合并提交了。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://qupzhi.com/categories/git/"/>
    
    
      <category term="工具" scheme="https://qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="版本控制" scheme="https://qupzhi.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git教程" scheme="https://qupzhi.com/tags/git%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络虚拟化技术——虚拟专用网 VPN</title>
    <link href="https://qupzhi.com/VPN/"/>
    <id>https://qupzhi.com/VPN/</id>
    <published>2019-01-21T11:00:00.000Z</published>
    <updated>2019-03-23T16:19:32.542Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：在虚拟化技术中，网络是必不可少的一个，它从上到下贯穿全局；它建网快速方便、容易对网络维护和管理、高可用、租户隔离等优点是企业管理、节约成本的秘诀，是网络安全的守门员。我们这一章说VPN，利用公用网络架设专用网络，实现在远程也可以安全的访问内部网络，可以理解为虚拟出来的企业内部专线，是一种安全性很高的技术。当然了，私人可以使用他来做科学上网的工具。</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p></blockquote><h1 id="常见的vpn协议"><a href="#常见的vpn协议" class="headerlink" title="常见的vpn协议"></a>常见的vpn协议</h1><p>VPN的隧道协议主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在<a href="https://baike.baidu.com/item/OSI/5520" target="_blank" rel="noopener">OSI</a>模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="远程访问虚拟网（AccessVPN）"><a href="#远程访问虚拟网（AccessVPN）" class="headerlink" title="远程访问虚拟网（AccessVPN）"></a>远程访问虚拟网（AccessVPN）</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/iqa9rmt2ro.jpeg" alt="外网vpn访问公司内网"></p><p>利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。原理是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。这中间为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。</p><p>有了数据加密，就可以认为数据是在一条<strong>专用的数据链路</strong>上进行安全传输，就如同专门架设了一个专用网络一样，但<strong>实际上</strong>VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其<strong>实质上</strong>就是利用加密技术在公网上封装出一个数据通讯隧道。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/yxq28hh8i0.png" alt="vpn访问外网"></p><p>另一个场景就是我们比较常见的，由于我国<a href="https://zh.wikipedia.org/wiki/%25E4%25B8%25AD%25E8%258F%25AF%25E4%25BA%25BA%25E6%25B0%2591%25E5%2585%25B1%25E5%2592%258C%25E5%259C%258B%25E7%25B6%25B2%25E7%25B5%25A1%25E5%25AF%25A9%25E6%259F%25A5" target="_blank" rel="noopener">对海外网络的限制及屏蔽</a>,很多时候个人用户、外资公司、学术单位想要连回海外网站就要自行架设VPN或采用付费的VPN服务。</p><h2 id="企业内部虚拟网（IntranetVPN）"><a href="#企业内部虚拟网（IntranetVPN）" class="headerlink" title="企业内部虚拟网（IntranetVPN）"></a>企业内部虚拟网（IntranetVPN）</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/80ft38ci9g.jpeg" alt="企业内部虚拟网"></p><p>Intranet VPN服务即企业的总部与分支机构间通过VPN虚拟网进行网络连接。随着企业的跨地区、国际化经营，这是绝大多数大、中型企业所必需的。如果要进行企业内部各分支机构的互联，使用Intranet VPN是很好的方式。这种VPN是通过<strong>公用因特网或者第三方专用网</strong>进行连接的，有条件的企业可以采用光纤作为传输介质。它的特点就是容易建立连接、连接速度快，最大特点就是它为各分支机构提供了整个网络的访问权限。</p><p>IntranetVPN通过一个使用专用连接的共享基础设施，连接企业总部、远程办事处和分支机构。企业拥有与专用网络的相同政策，包括安全、服务质量(QoS)、可管理性和可靠性。</p><h2 id="企业扩展虚拟网（ExtranetVPN）"><a href="#企业扩展虚拟网（ExtranetVPN）" class="headerlink" title="企业扩展虚拟网（ExtranetVPN）"></a>企业扩展虚拟网（ExtranetVPN）</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/3sgnujfzvy.jpeg" alt=""></p><p>Extranet VPN服务即企业间发生收购、兼并或企业间建立战略联盟后，使不同企业网通过公网来构筑的虚拟网。如果是需要提供B2B电子商务之间的安全访问服务，则可以考虑选用Extranet VPN。上图中下面那个人就代表客户、合作伙伴。</p><blockquote><p>随着信息时代的到来，各个企业越来越重视各种信息的处理。希望可以提供给客户最快捷方便的信息服务，通过各种方式了解客户的需要各个企业之间的合作关系也越来越多，信息交换日益频繁。因特网为这样的一种发展趋势提供了良好的基础，而如何利用因特网进行有效的信息管理，是企业发展中不可避免的一个关键问题。利用VPN技术可以组建安全的Extranet，既可以向客户、合作伙伴提供有效的信息服务，又可以保证自身的内部网络的安全。<br>Extranet VPN通过一个使用专用连接的共享基础设施，将客户、供应商、合作伙伴或兴趣群体连接到企业内部网。企业拥有与专用网络的相同政策，包括安全、服务质量(QoS)、可管理性和可靠性。<br>Extranet VPN服务对用户的吸引力在于:能容易地对外部网进行部署和管理，外部网的连接可以使用与部署内部网和远端访问VPN相同的架构和协议进行部署。主要的不同是接入许可，外部网的用户被许可只有一次机会连接到其合作人的网络，并且只拥有部分网络资源访问权限，这要求企业用户对各外部用户进行相应访问权限的设定。</p></blockquote><h1 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>VPN能够让移动员工、远程员工、商务合作伙伴和其他人利用本地可用的高速宽带网连接（如DSL、有线电视或者WiFi网络）连接到企业网络。</li><li>设计良好的宽带VPN是模块化的和可升级的。这种能力意味着企业不用增加额外的基础设施就可以提供大量的容量和应用。</li><li>VPN能提供高水平的安全，使用高级的加密和身份识别协议保护数据避免受到窥探，阻止数据窃贼和其他非授权用户接触这种数据。</li><li>完全控制，虚拟专用网使用户可以利用ISP的设施和服务，同时又完全掌握着自己网络的控制权。用户只利用ISP提供的网络资源，对于其它的安全设置、网络管理变化可由自己管理。在企业内部也可以自己建立虚拟专用网。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>企业不能直接控制基于互联网的VPN的可靠性和性能。机构必须依靠提供VPN的互联网服务提供商保证服务的运行。这个因素使企业与互联网服务提供商签署一个服务级协议非常重要，要签署一个保证各种性能指标的协议。</li><li>企业创建和部署VPN线路并不容易。这种技术需要高水平地理解网络和安全问题，需要认真的规划和配置。因此，应该大多数选择互联网服务提供商负责运行VPN。</li><li>不同厂商的VPN产品和解决方案总是不兼容的，因为许多厂商不愿意或者不能遵守VPN技术标准。因此，混合使用不同厂商的产品可能会出现技术问题。另一方面，使用一家供应商的设备可能会提高成本。</li><li>当使用无线设备时，VPN有安全风险。在接入点之间漫游特别容易出问题。当用户在接入点之间漫游的时候，任何使用高级加密技术的解决方案都可能被攻破。</li></ul><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ul><li>VPN服务器：在大型局域网中，可以通过在网络中心搭建VPN服务器的方法实现VPN。（vpn服务上使用openvpn easy-rsa或其他方式 ）</li><li>软件VPN：可以通过专用的软件实现VPN。</li><li>硬件VPN：可以通过专用的硬件实现VPN。</li><li>集成VPN：某些硬件设备，如交换机、路由器、防火墙等，都含有VPN功能，但是一般拥有VPN功能的硬件设备通常都比没有这一功能的要贵。</li></ul><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><blockquote><p>L2TP协议和PPTP协议在数据传输过程中都存在一定安全隐患，基于IPSec协议的VPN技术可有效防止黑客入侵，保护用户的通信信息。因此，对于保密性要求较高的重要部门，建议选择使用基于IPSec协议实现的VPN，保证通信安全。</p></blockquote><h1 id="腾讯公有云产品-与-VPN"><a href="#腾讯公有云产品-与-VPN" class="headerlink" title="腾讯公有云产品 与 VPN"></a>腾讯公有云产品 与 VPN</h1><p><img src="https://ask.qcloudimg.com/http-save/3097464/y6rrquemwj.svg" alt="弹性混合云"></p><p>上图是腾讯云使用vpn连接私有云和公有云实现的弹性混合云服务，可以根据业务压力大小弹性伸缩。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/lklz746jud.svg" alt="云上灾备"></p><p>通过 VPN 连接同步云端和本地数据中心的数据，实现云上容灾，保证业务数据安全。</p><h1 id="法律上"><a href="#法律上" class="headerlink" title="法律上"></a>法律上</h1><ul><li>按我国法律规定不能以盈利为目的搭建vpn来连接internet</li><li>使用vpn上外网不能违背中国社会主义的法律或者违规道德规范</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://zh.wikipedia.org/wiki/%25E8%2599%259B%25E6%2593%25AC%25E7%25A7%2581%25E4%25BA%25BA%25E7%25B6%25B2%25E8%25B7%25AF" target="_blank" rel="noopener">wiki 虛擬私人網路</a></p><p><a href="https://baike.baidu.com/item/%25E8%2599%259A%25E6%258B%259F%25E4%25B8%2593%25E7%2594%25A8%25E7%25BD%2591%25E7%25BB%259C/8747869?fromtitle=VPN&amp;fromid=382304&amp;fr=aladdin#2" target="_blank" rel="noopener">百度百科 虚拟专用网络</a></p><p><a href="https://baijiahao.baidu.com/s?id=1617357848025009719&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">虚拟专用网络(VPN)的安全性</a></p><p><a href="http://www.rfwireless-world.com/Terminology/Intranet-VPN-vs-Extranet-VPN.html" target="_blank" rel="noopener">Difference between Intranet VPN and Extranet VPN | Intranet VPN vs Extranet VPN</a></p><p><a href="http://netsecurity.51cto.com/art/201009/225085.htm" target="_blank" rel="noopener">简析三种VPN服务类型</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：在虚拟化技术中，网络是必不可少的一个，它从上到下贯穿全局；它建网快速方便、容易对网络维护和管理、高可用、租户隔离等优点是企业管理、节约成本的秘诀，是网络安全的守门员。我们这一章说VPN，利用公用网络架设专用网络，实现在远程也可以安全的访问内部网络，可以理解为虚拟出来的企业内部专线，是一种安全性很高的技术。当然了，私人可以使用他来做科学上网的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://qupzhi.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="vpn" scheme="https://qupzhi.com/tags/vpn/"/>
    
      <category term="虚拟网络" scheme="https://qupzhi.com/tags/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络" scheme="https://qupzhi.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>qq邮箱高频率邮件来源自动屏蔽的信任办法</title>
    <link href="https://qupzhi.com/qqmail-filter/"/>
    <id>https://qupzhi.com/qqmail-filter/</id>
    <published>2019-01-18T05:46:00.000Z</published>
    <updated>2019-01-18T05:51:19.084Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：我们在使用QQ邮箱作为告警接收邮箱的时候，用了一段时间发现，告警邮箱再也没办法发出来了，非常的困惑，检查了全部的网络策略、dns、smtp服务器配置都没有问题，原来是qq邮箱的自动策略，在此记录。</p><a id="more"></a><h1 id="python-测试smtp脚本"><a href="#python-测试smtp脚本" class="headerlink" title="python 测试smtp脚本"></a>python 测试smtp脚本</h1><p>我们使用python的测试smtp脚本，无密码时使用，有密码时去掉注释<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr(( \</span><br><span class="line">        Header(name, <span class="string">'utf-8'</span>).encode(), \</span><br><span class="line">        addr.encode(<span class="string">'utf-8'</span>) <span class="keyword">if</span> isinstance(addr, unicode) <span class="keyword">else</span> addr))</span><br><span class="line"></span><br><span class="line">from_addr = <span class="string">'root@mymail.com'</span></span><br><span class="line">to_addr = [<span class="string">'xxxx@163.com'</span>,<span class="string">'xxx.qq.com'</span>] </span><br><span class="line"><span class="comment">#password = ''</span></span><br><span class="line">smtp_server = <span class="string">'mymail'</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">'hello, send by Python...'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">u'monitorcloud &lt;%s&gt;'</span> % from_addr)</span><br><span class="line">msg[<span class="string">'To'</span>] = _format_addr(<span class="string">u'管理员 &lt;%s&gt;'</span> % to_addr)</span><br><span class="line">msg[<span class="string">'Subject'</span>] = Header(<span class="string">u'来自SMTP的问候……'</span>, <span class="string">'utf-8'</span>).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#server.starttls()</span></span><br><span class="line"><span class="comment">#server.login(from_addr, password)</span></span><br><span class="line">server.sendmail(from_addr, to_addr, msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure><p></p><h1 id="发送情景"><a href="#发送情景" class="headerlink" title="发送情景"></a>发送情景</h1><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f72ea19a9a74?w=2552&amp;h=930&amp;f=png&amp;s=1092939" alt="发送到163邮箱"></p><ul><li>发送到163邮箱是成功的</li><li>但是发送到qq邮箱不行了</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f752c9eb74d3?w=2838&amp;h=268&amp;f=png&amp;s=244975" alt="maillog"></p><ul><li>查/var/log/maillog 发现有如上报错信息</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f73e2c8c9ccd?w=2576&amp;h=896&amp;f=png&amp;s=630368" alt="qqfilter"></p><ul><li>查QQ邮箱没有收到邮件</li><li>有如上拦截信息</li></ul><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f76b9333d01c?w=2984&amp;h=2036&amp;f=png&amp;s=1709222" alt="反垃圾"></p><ul><li>进入反垃圾设置地址白名单和域名白名单</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f7c026c9c2d2?w=1180&amp;h=946&amp;f=png&amp;s=254506" alt="域名白名单"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f7d025cab767?w=1194&amp;h=630&amp;f=png&amp;s=230034" alt="地址白名单"></p><h1 id="测试成功"><a href="#测试成功" class="headerlink" title="测试成功"></a>测试成功</h1><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f7df3696020c?w=2536&amp;h=1130&amp;f=png&amp;s=695138" alt="qq邮箱收件结果"></p><h1 id="附SMTP错误码"><a href="#附SMTP错误码" class="headerlink" title="附SMTP错误码"></a>附SMTP错误码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">·The server rejected the message: 554 DT:SPM smtp2 Cannot send message 451 MI:SFQ 0,smtp9,DcCowLD735x2fG1MgWLhAA--.11609S2 1282243</span><br><span class="line">邮件服务器拒绝发送邮件，判断为发送垃圾邮件。建议您检查邮件内容，是否包含一些比较敏感的内容。</span><br><span class="line">·Cannot send message data: 550 5.4.5 Daily sending quota exceeded. q31sm4299413ybk.1</span><br><span class="line">不能发送邮件，每日发送额度用完。建议您控制此邮箱每天的发送量，今天发送量已经用完，需要明天才能继续发送。</span><br><span class="line">·Recipient rejected: &lt;xxx@yahoo.com&gt;: 553 5.7.1 &lt; xx@xx.com &gt;: Sender address rejected: not owned by user xx@xx.com</span><br><span class="line">发送邮箱地址被拒绝。建议您换个邮箱发送。</span><br><span class="line">·Recipient rejected: &lt;xxx@yahoo.co.uk&gt;: 550 Your mailbox is full？</span><br><span class="line">您的邮箱空间已满不能再发送邮件。建议您整理邮箱中的邮件。</span><br><span class="line">·Cannot send message: 451 sorry, server closed？</span><br><span class="line">不能发送，服务器已经关闭。建议您稍候再尝试邮件发送操作 。</span><br><span class="line">·Recipient rejected: &lt;xxx@yahoo.com&gt;: 500 Error: bad syntax</span><br><span class="line">收件人地址格式不正确。请核实收件人地址是否正确。</span><br><span class="line">·421 Service not available, closing transmission channel (This may be a reply to any <span class="built_in">command</span> <span class="keyword">if</span> the service knows it must shut down)</span><br><span class="line">服务暂时不可用！建议您稍候再尝试发送。</span><br><span class="line">·450 Requested mail action not taken: mailbox unavailable (E.g., mailbox busy)</span><br><span class="line">邮件发送请求没有发生：邮箱不可用（例如，邮箱忙）！建议您稍候再尝试！</span><br><span class="line">·451 Requested action aborted: <span class="built_in">local</span> error <span class="keyword">in</span> processing</span><br><span class="line">请求的邮件操作被中止：本地进程错误。建议您重新启动邮件营销助手来尝试发送</span><br><span class="line">·550 Requested action not taken: mailbox unavailable (E.g., mailbox not found, no access)？</span><br><span class="line">请求的操作未被执行：邮箱不可用（例如，邮箱未找到，不能访问）。建议您稍候再尝试。</span><br><span class="line">·552 Requested mail action aborted: exceeded storage allocation</span><br><span class="line">请求的邮件操作中止：超出存储分配。建议您整理邮箱中的邮件。</span><br><span class="line">· 553 Requested action not taken: mailbox name not allowed (E.g., mailbox syntax incorrect)</span><br><span class="line">请求的操作未被执行：不允许的邮箱名称（例如，邮箱的语法不正确的）；</span><br><span class="line">·550 5.3.4 Requested action not taken; This account is currently blocked from sending messages. If you don<span class="string">'t think you'</span>ve violated the Windows Live Terms of Use, please contact customer support</span><br><span class="line">请求不采取行动，这是目前从帐户发送的邮件被阻止。如果您不认为您已经违反了Windows Live的使用条款，请联系其客户支持。</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/a11085013/article/details/10528121" target="_blank" rel="noopener">常见SMTP发送失败原因列表</a><br><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832745198026a685614e7462fb57dbf733cc9f3ad000" target="_blank" rel="noopener">SMTP发送邮件</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：我们在使用QQ邮箱作为告警接收邮箱的时候，用了一段时间发现，告警邮箱再也没办法发出来了，非常的困惑，检查了全部的网络策略、dns、smtp服务器配置都没有问题，原来是qq邮箱的自动策略，在此记录。&lt;/p&gt;
    
    </summary>
    
      <category term="qq邮箱策略" scheme="https://qupzhi.com/categories/qq%E9%82%AE%E7%AE%B1%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="smtp" scheme="https://qupzhi.com/tags/smtp/"/>
    
      <category term="qq邮箱" scheme="https://qupzhi.com/tags/qq%E9%82%AE%E7%AE%B1/"/>
    
      <category term="python" scheme="https://qupzhi.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>如何用RSS订阅？</title>
    <link href="https://qupzhi.com/how_to_subscribe_RSS/"/>
    <id>https://qupzhi.com/how_to_subscribe_RSS/</id>
    <published>2019-01-12T07:36:00.000Z</published>
    <updated>2019-01-21T11:11:08.932Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：我们常常会有订阅别人文章的需求，有更新的时候希望能有提醒的功能，RSS就是这样一个订阅的方式。很多网站上看到RSS的入口，点进去以后总是显示一堆的XML代码，我们来看看怎么使用这个功能。在本次的学习过后你将学会使用RSS来订阅别人的网站，而且你还能学会给不能用RSS网站的创建订阅，比如学校的教务网站发布重要的通知、新闻通知、公司网站通知、包括好看的电视剧更新就都能被你订阅了。</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。<br>Really Simple Syndication“简易信息聚合”就是RSS的英文原意。把新闻标题、摘要（Feed）、内容按照用户的要求，“送”到用户的桌面就是RSS的目的。RSS一词有时候大体上意为社会性书签，包括各种RSS的不同格式。例如，Blogspace对使用网摘于一集成器内之动作标为RSS info和RSS reader。虽然它的第一个句子就包含明确的Atom格式：“RSS和Atom文件能够用简单的格式从网站更新消息至你的计算机！”</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>可以有选择地浏览您感兴趣的以及与您的工作相关的新闻。</li><li>通过使用 RSS，您可以把需要的信息从不需要的信息（兜售信息，垃圾邮件等）中分离出来。</li><li>通过使用 RSS，您可以创建自己的新闻频道，并将之发布到因特网。</li><li>使用客户端，可以在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。</li></ul><h1 id="如何订阅"><a href="#如何订阅" class="headerlink" title="如何订阅"></a>如何订阅</h1><h2 id="浏览器方式"><a href="#浏览器方式" class="headerlink" title="浏览器方式"></a>浏览器方式</h2><p>这里介绍chrome的扩展程序，其他的浏览器大同小异。</p><ol><li>打开<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">Chrome网上商店</a>,并按装feeder插件</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/4cwq1yx9bw.png" alt="Chrome网上商店"></p><ol><li>安装完成后会自动提示注册一个账号，按照提示注册完成登录即可。</li><li>完成插件安装之后，在浏览博客或者其他网站时，点击RSS订阅图标，就可以正常订阅成功。</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/81z2j064qu.png" alt="RSS按钮"></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ikutrx9x73.png" alt="点击订阅"></p><ol><li>当有文章更新的时候，就会在浏览器右上角提示,打开后就可以看到全部订阅者了</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/n711xwqvvb.png" alt="chrome浏览器右上角提示"></p><ol><li>可以在<a href="https://feeder.co/reader" target="_blank" rel="noopener">reader</a>看到比较舒服的阅读方式，也可以直接右上角打开文章来看<br><img src="https://ask.qcloudimg.com/http-save/3097464/zd7rgqhacx.png" alt="优雅的阅读"></li><li>在feeder的设置页面可以针对每个订阅者设置,可以选择刷新周期，提示方式（不过Email提示是要收费的），还可以导出你的订阅让好友来导入</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/jx4wlaq7hk.png" alt="配置"></p><h2 id="客户端方式"><a href="#客户端方式" class="headerlink" title="客户端方式"></a>客户端方式</h2><h3 id="阅读器推荐"><a href="#阅读器推荐" class="headerlink" title="阅读器推荐"></a>阅读器推荐</h3><p>因为我觉得浏览器端的就够我用了，就没用过客户端的，下面是网上摘录的客户端阅读器</p><ul><li>irreade<br>最好用，支持多平台。</li><li>NewsGator Online<br>一个免费的在线 RSS 阅读器。包含 Outlook 同步，通过 Media Center Edition 查看电视内容，以及 blog 和标题的发布。</li><li>RssReade<br>基于 Windows 的免费 RSS 阅读器。支持 RSS versions 0.9x、1.0 以及 2.0 和 Atom 0.1, 0.2 以及 0.3。</li><li>FeedDemon<br>基于 Windows 的 RSS 阅读器。使用很简便，界面很有条理。可以免费下载！</li><li>blogbot<br>一个针对 Outlook 或 Internet Explorer 的 RSS 阅读器插件。针对 Internet Explorer 的简化版是免费的。</li></ul><h3 id="我已经有一个-RSS-阅读器了，接下来怎么做呢？"><a href="#我已经有一个-RSS-阅读器了，接下来怎么做呢？" class="headerlink" title="我已经有一个 RSS 阅读器了，接下来怎么做呢？"></a>我已经有一个 RSS 阅读器了，接下来怎么做呢？</h3><p>点击您希望阅读的 RSS feed 旁边的橙色小图标 或 ，把浏览器窗口的 URL 拷贝粘贴到您的 RSS 阅读器即可。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>事实上我们根本不用关心RSS的语法是什么，因为多的是自动RSS的工具，如果使用的开源blog通常也会提供RSS自动生成的插件，以下是2.0版本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">rss</span> <span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">channel</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>pzqu的自言自语<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span>&gt;</span>https://qupzhi.com<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>我的描述<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>如何用RSS订阅？<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span>&gt;</span>https://qupzhi.com/how_to_subscribe_RSS<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>摘要.....<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span>...略<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">channel</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">rss</span>&gt;</span></span><br></pre></td></tr></table></figure><p>感兴趣的同学可以看看<a href="http://www.rssboard.org/rss-2-0-1" target="_blank" rel="noopener">官网</a>,不同的版本语法可能略有差异。</p><h1 id="如何让你的网站支持RSS"><a href="#如何让你的网站支持RSS" class="headerlink" title="如何让你的网站支持RSS"></a>如何让你的网站支持RSS</h1><p>建议使用一些直接就支持自动生成RSS的开源blog，像WordPress、Blogger、Radio、Hexo，这里提供一个自动给网站生成RSS的方法，有了这种神器以后任何东西你都可以订阅了，比如电影网站，新闻网站，公司网站，学校通知。</p><ul><li>注意科学上网<br><a href="http://www.feed43.com" target="_blank" rel="noopener">http://www.feed43.com</a>提取HTML中关键内容进入创建页面，输入你想生成RSS的网址，这样可以拿到这个网站的HTML</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/i1un2urb77.png" alt="输入你想生成RSS的网址"></p><h2 id="找到内容所在-HTML-字段规律。不同的文章会有相同的代码段落，比如我这里-为了好看我格式化了下"><a href="#找到内容所在-HTML-字段规律。不同的文章会有相同的代码段落，比如我这里-为了好看我格式化了下" class="headerlink" title="找到内容所在 HTML 字段规律。不同的文章会有相同的代码段落，比如我这里(为了好看我格式化了下)"></a>找到内容所在 HTML 字段规律。不同的文章会有相同的代码段落，比如我这里(为了好看我格式化了下)</h2><p><strong>标题和url</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;</span><br><span class="line">    &lt;a class=&quot;post-title-link&quot; href=&quot;https://qupzhi.com/mariadb-better/&quot; itemprop=&quot;url&quot;&gt;</span><br><span class="line">        mariadb 内存占用优化</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><strong>创建时间</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">title</span>=<span class="string">"创建于"</span> <span class="attr">itemprop</span>=<span class="string">"dateCreated datePublished"</span> <span class="attr">datetime</span>=<span class="string">"2019-01-09T22:25:00+08:00"</span>&gt;</span></span><br><span class="line">    2019-01-09</span><br><span class="line"><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>摘要</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body"</span> <span class="attr">itemprop</span>=<span class="string">"articleBody"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        摘要：我们在使用mariadb的时候发现有时候不能启动起来，在使用过程中mariadb占用的内存很大，在这里学习下mariadb与内存相关的配置项，对mariadb进行调优。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>我们取到了标题、创建时间、摘要等比较关键的东西</li></ul><h2 id="精简提取规则代码"><a href="#精简提取规则代码" class="headerlink" title="精简提取规则代码"></a>精简提取规则代码</h2><p>定义规则找到网页中你想要看的项目的列表代码(也就是文章的代码)，将你想要的字段用&#123;%&#125;代替为参数，不需要的可以用&#123;*&#125;代替，点击Extract，改到满意为止。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/g0ykq5na2b.png" alt="输入规则"></p><p>这里的规则让我试到头疼，但是慢慢试就是能试出来的要注意</p><ul><li>一行一个规则比较清晰，这个系统也支持</li><li>每行结束加一个&#123;*&#125;来忽略规则间不要的东西，如果有空格回车的也加上</li><li>一个规则试好了再试另一个规则</li><li>可以借助<a href="http://www.bejson.com/jshtml_format/" target="_blank" rel="noopener">HTML格式化工具</a></li></ul><p><strong>我的匹配结果</strong></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ccv3f6jjo9.png" alt="我的匹配结果"></p><p>如上图所示，每一篇文章的标题、链接、摘要、时间都已经成功抓取了。</p><h2 id="完善RSS源格式"><a href="#完善RSS源格式" class="headerlink" title="完善RSS源格式"></a>完善RSS源格式</h2><p>我们要完善好源格式，才能正确的输出源，在上面的语法那一节我们也说过了，一个完整的源要有网站title，link，description还要有每个文章的tile,link,time,description。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/mvj8nl1hns.png" alt="网站"></p><p>来看文章的要怎么填</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/flbly0vpja.png" alt="变量"></p><p>变化的字段用 &#123;%+数字&#125; 的形式标示出来,也就是上面我的匹配结果里展示的内容，不同的 &#123;%+数字&#125; 之间可以填写随意的文字、符号过渡，如下</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/gkcak955h0.png" alt="文章"></p><p>ok的话点Preview就可以生成了</p><p>看看结果</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/twrpg9yd72.png" alt="结果"></p><h2 id="获得你的RSS-URL"><a href="#获得你的RSS-URL" class="headerlink" title="获得你的RSS URL"></a>获得你的RSS URL</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/uc4h1o5ylr.png" alt="我的RSS URL"></p><ul><li>Feed URL就是你的RSS地址了，你可以放在任何地方</li><li>Edit URL就是以后用来编辑你RSS的页面了</li><li>下面可以把这个url的好记一些<br>好了，这个url放到文章你的rss订阅器里就可以订阅了</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/q0dhs7s55x.png" alt=""></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/pgqmtke7w8.png" alt=""></p><ul><li>你可以免费使用 Feed43 做 RSS 源</li><li>免费版不限制创建多少个rss源但是会有广告，每个源最大只能有250KB，更新后6小时才能刷新一次，最多100篇文章，匹配规则在30个内。</li><li>其实大部分都够用了，这个是<a href="https://feed43.com/upgrade.html#personal" target="_blank" rel="noopener">付费页面</a></li></ul><h2 id="提供RSS"><a href="#提供RSS" class="headerlink" title="提供RSS"></a>提供RSS</h2><p>在希望向外界提供 RSS的页面放一个RSS的图标，然后向这个按钮添加一个指向 RSS 文件的链接。代码应该类似这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://qupzhi.com/atom.xml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://user-gold-cdn.xitu.io/2019/1/11/1683b8918abb8f90?w=36&amp;h=14&amp;f=gif&amp;s=1036"</span> <span class="attr">width</span>=<span class="string">"36"</span> <span class="attr">height</span>=<span class="string">"14"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="附Hexo匹配规则"><a href="#附Hexo匹配规则" class="headerlink" title="附Hexo匹配规则"></a>附Hexo匹配规则</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"post-title-link"</span> <span class="attr">href</span>=<span class="string">"&#123;%&#125;"</span> <span class="attr">itemprop</span>=<span class="string">"url"</span>&gt;</span>&#123;%&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#123;*&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">title</span>=<span class="string">"创建于"</span> <span class="attr">itemprop</span>=<span class="string">"dateCreated datePublished"</span> <span class="attr">datetime</span>=<span class="string">"&#123;*&#125;"</span>&gt;</span>&#123;%&#125;<span class="tag">&lt;/<span class="name">time</span>&gt;</span>&#123;*&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body"</span> <span class="attr">itemprop</span>=<span class="string">"articleBody"</span>&gt;</span>&#123;*&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;%&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#123;*&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>找到一个非常非常好用的，rss源基本所有主要的网站都能用了<br><a href="https://docs.rsshub.app" target="_blank" rel="noopener">rsshub</a></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://zh.wikipedia.org/wiki/RSS" target="_blank" rel="noopener">wiki RSS</a></p><p><a href="http://www.runoob.com/rss/rss-tutorial.html" target="_blank" rel="noopener">RSS 教程</a></p><p><a href="https://ihaoming.top/archives/644dacb3.html" target="_blank" rel="noopener">使用RSS订阅</a></p><p><a href="https://baijiahao.baidu.com/s?id=1617627976106767760&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">自动生成RSS</a></p><p><a href="https://sspai.com/post/34320" target="_blank" rel="noopener">利用 Feed43，将任意网页制作成 RSS 订阅源 | 一日一技</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：我们常常会有订阅别人文章的需求，有更新的时候希望能有提醒的功能，RSS就是这样一个订阅的方式。很多网站上看到RSS的入口，点进去以后总是显示一堆的XML代码，我们来看看怎么使用这个功能。在本次的学习过后你将学会使用RSS来订阅别人的网站，而且你还能学会给不能用RSS网站的创建订阅，比如学校的教务网站发布重要的通知、新闻通知、公司网站通知、包括好看的电视剧更新就都能被你订阅了。&lt;/p&gt;
    
    </summary>
    
      <category term="RSS" scheme="https://qupzhi.com/categories/RSS/"/>
    
    
      <category term="工具" scheme="https://qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="RSS" scheme="https://qupzhi.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>mariadb 内存占用优化</title>
    <link href="https://qupzhi.com/mariadb-better/"/>
    <id>https://qupzhi.com/mariadb-better/</id>
    <published>2019-01-09T14:25:00.000Z</published>
    <updated>2019-01-10T03:34:41.758Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：我们在使用mariadb的时候发现有时候不能启动起来，在使用过程中mariadb占用的内存很大，在这里学习下mariadb与内存相关的配置项，对mariadb进行调优。</p><a id="more"></a><h1 id="查询最高内存占用"><a href="#查询最高内存占用" class="headerlink" title="查询最高内存占用"></a>查询最高内存占用</h1><p>使用以下命令可以知道mysql的配置使用多少 RAM<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT ( @@key_buffer_size</span><br><span class="line">+ @@query_cache_size</span><br><span class="line">+ @@innodb_buffer_pool_size</span><br><span class="line">+ @@innodb_additional_mem_pool_size</span><br><span class="line">+ @@innodb_log_buffer_size</span><br><span class="line">+ @@max_connections * ( @@read_buffer_size</span><br><span class="line">+ @@read_rnd_buffer_size</span><br><span class="line">+ @@sort_buffer_size</span><br><span class="line">+ @@join_buffer_size</span><br><span class="line">+ @@binlog_cache_size</span><br><span class="line">+ @@thread_stack</span><br><span class="line">+ @@tmp_table_size</span><br><span class="line">)</span><br><span class="line">) / (1024 * 1024 * 1024) AS MAX_MEMORY_GB;</span><br></pre></td></tr></table></figure><p></p><p>可以使用<a href="http://www.mysqlcalculator.com/" target="_blank" rel="noopener">mysql计算器</a>来计算内存使用</p><p>下面是理论，可以直接到<a href="#mariadb 推荐配置">推荐配置</a></p><h1 id="如何调整配置"><a href="#如何调整配置" class="headerlink" title="如何调整配置"></a>如何调整配置</h1><h2 id="key-buffer-size（MyISAM索引用）"><a href="#key-buffer-size（MyISAM索引用）" class="headerlink" title="key_buffer_size（MyISAM索引用）"></a>key_buffer_size（MyISAM索引用）</h2><blockquote><p>指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。为了最小化磁盘的 I/O ， MyISAM 存储引擎的表使用键高速缓存来缓存索引，这个键高速缓存的大小则通过 key-buffer-size 参数来设置。如果应用系统中使用的表以 MyISAM 存储引擎为主，则应该适当增加该参数的值，以便尽可能的缓存索引，提高访问的速度。</p></blockquote><h3 id="怎么设"><a href="#怎么设" class="headerlink" title="怎么设"></a>怎么设</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'key_read%'</span>;</span><br><span class="line"></span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Key_read_requests | 27813678764 |</span><br><span class="line">| Key_reads | 6798830 |</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。</li><li>比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'%created_tmp_disk_tables%'</span>;</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。</li><li>对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M）</li></ul><p><strong>另一个参考如下</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'key_blocks_u%'</span>;</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Key_blocks_unused | 0 |</span><br><span class="line">| Key_blocks_used | 413543 |</span><br><span class="line">+------------------------+-------------+</span><br></pre></td></tr></table></figure><p></p><p>Key_blocks_unused表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置：</p><ul><li>可以根据此工式来动态的调整<code>Key_blocks_used / (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><ul><li>查询存储引擎</li></ul><h2 id="innodb-buffer-pool-size-（innodb索引用）"><a href="#innodb-buffer-pool-size-（innodb索引用）" class="headerlink" title="innodb_buffer_pool_size （innodb索引用）"></a>innodb_buffer_pool_size （innodb索引用）</h2><blockquote><p>这个参数和MyISAM的<code>key_buffer_size</code>有相似之处，但也是有差别的。这个参数主要缓存innodb表的索引，数据，插入数据时的缓冲。为Innodb加速优化首要参数。<br>该参数分配内存的原则：这个参数默认分配只有8M，可以说是非常小的一个值。</p><ul><li>如果是专用的DB服务器，且以InnoDB引擎为主的场景，通常可设置物理内存的50%，这个参数不能动态更改，所以分配需多考虑。分配过大，会使Swap占用过多，致使Mysql的查询特慢。</li><li>如果是非专用DB服务器，可以先尝试设置成内存的1/4，如果有问题再调整</li></ul></blockquote><h2 id="query-cache-size（查询缓存）"><a href="#query-cache-size（查询缓存）" class="headerlink" title="query_cache_size（查询缓存）"></a>query_cache_size（查询缓存）</h2><blockquote><p>缓存机制简单的说就是缓存sql文本及查询结果，如果运行相同的sql，服务器直接从缓存中取到结果，而不需要再去解析和执行sql。如果表更改了，那么使用这个表的所有缓冲查询将不再有效，查询缓存值的相关条目被清空。更改指的是表中任何数据或是结构的改变，包括INSERT、UPDATE、DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE等，也包括那些映射到改变了的表的使用MERGE表的查询。显然，这对于频繁更新的表，查询缓存是不适合的，而对于一些不常改变数据且有大量相同sql查询的表，查询缓存会节约很大的性能。</p><ul><li>注意：如果你查询的表更新比较频繁，而且很少有相同的查询，最好不要使用查询缓存。因为这样会消耗很大的系统性能还没有任何的效果</li></ul></blockquote><h3 id="要不要打开？"><a href="#要不要打开？" class="headerlink" title="要不要打开？"></a>要不要打开？</h3><p>先设置成这样跑一段时间<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_size=128M </span><br><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure><p></p><p>看看命中结果来进行进一步的判断<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'%Qcache%'</span>;</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Qcache_free_blocks      | 669       |</span><br><span class="line">| Qcache_free_memory      | 132519160 |</span><br><span class="line">| Qcache_hits             | 1158      |</span><br><span class="line">| Qcache_inserts          | 284824    |</span><br><span class="line">| Qcache_lowmem_prunes    | 2741      |</span><br><span class="line">| Qcache_not_cached       | 1755767   |</span><br><span class="line">| Qcache_queries_in_cache | 579       |</span><br><span class="line">| Qcache_total_blocks     | 1853      |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>Qcache_free_blocks:表示查询缓存中目前还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能在一定的时间进行整理。<br>Qcache_free_memory:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。<br>Qcache_hits:表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。<br>Qcache_inserts: 表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数，次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。<br>Qcache_lowmem_prunes:该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。<br>Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。<br>Qcache_queries_in_cache:当前缓存中缓存的查询数量。<br>Qcache_total_blocks:当前缓存的block数量。</p></blockquote><ul><li><p>我们可以看到现网命中1158，未缓存的有1755767次，说明我们这个系统命中的太少了，表变动比较多，不什么开启这个功能</p><h3 id="涉及参数"><a href="#涉及参数" class="headerlink" title="涉及参数"></a>涉及参数</h3></li><li><p>query_cache_limit：允许 Cache 的单条 Query 结果集的最大容量，默认是1MB，超过此参数设置的 Query 结果集将不会被 Cache</p></li><li>query_cache_min_res_unit：设置 Query Cache 中每次分配内存的最小空间大小，也就是每个 Query 的 Cache 最小占用的内存空间大小</li><li>query_cache_size：设置 Query Cache 所使用的内存大小，默认值为0，大小必须是1024的整数倍，如果不是整数倍，MySQL 会自动调整降低最小量以达到1024的倍数</li><li>query_cache_type：控制 Query Cache 功能的开关，可以设置为0(OFF),1(ON)和2(DEMAND)三种，意义分别如下：<br>0(OFF)：关闭 Query Cache 功能，任何情况下都不会使用 Query Cache<br>1(ON)：开启 Query Cache 功能，但是当 SELECT 语句中使用的 SQL_NO_CACHE 提示后，将不使用Query Cache<br>2(DEMAND)：开启 Query Cache 功能，但是只有当 SELECT 语句中使用了 SQL_CACHE 提示后，才使用 Query Cache</li><li>query_cache_wlock_invalidate：控制当有写锁定发生在表上的时刻是否先失效该表相关的 Query Cache，如果设置为 1(TRUE)，则在写锁定的同时将失效该表相关的所有 Query Cache，如果设置为0(FALSE)则在锁定时刻仍然允许读取该表相关的 Query Cache。</li></ul><h2 id="innodb-additional-mem-pool-size（InnoDB内部目录大小）"><a href="#innodb-additional-mem-pool-size（InnoDB内部目录大小）" class="headerlink" title="innodb_additional_mem_pool_size（InnoDB内部目录大小）"></a>innodb_additional_mem_pool_size（InnoDB内部目录大小）</h2><p>InnoDB 字典信息缓存主要用来存放 InnoDB 存储引擎的字典信息以及一些 internal 的共享数据结构信息，也就是存放Innodb的内部目录，所以其大小也与系统中所使用的 InnoDB 存储引擎表的数量有较大关系。</p><p>这个值不用分配太大，通常设置16Ｍ够用了，默认8M，如果设置的内存大小不够，InnoDB 会自动申请更多的内存，并在 MySQL 的 Error Log 中记录警告信息。</p><h2 id="innodb-log-buffer-size-（日志缓冲）"><a href="#innodb-log-buffer-size-（日志缓冲）" class="headerlink" title="innodb_log_buffer_size （日志缓冲）"></a>innodb_log_buffer_size （日志缓冲）</h2><p>表示InnoDB写入到磁盘上的日志文件时使用的缓冲区的字节数，默认值为16M。一个大的日志缓冲区允许大量的事务在提交之前不用写日志到磁盘，所以如果有更新，插入或删除许多行的事务，则使日志缓冲区更大一些可以节省磁盘IO</p><p>通常最大设为64M足够</p><h2 id="max-connections-最大并发连接"><a href="#max-connections-最大并发连接" class="headerlink" title="max_connections (最大并发连接)"></a>max_connections (最大并发连接)</h2><p>MySQL的max_connections参数用来设置最大连接（用户）数。每个连接MySQL的用户均算作一个连接，max_connections的默认值为100。</p><ul><li>这个参数实际起作用的最大值（实际最大可连接数）为16384，即该参数最大值不能超过16384，即使超过也以16384为准；</li><li>增加max_connections参数的值，不会占用太多系统资源。系统资源（CPU、内存）的占用主要取决于查询的密度、效率等；</li><li>该参数设置过小的最明显特征是出现”Too many connections”错误</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'%max_connect%'</span>;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| extra_max_connections | 1     |</span><br><span class="line">| max_connect_errors    | 100   |</span><br><span class="line">| max_connections       | 2048  |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like <span class="string">'Threads%'</span>;</span><br><span class="line">+-------------------+---------+</span><br><span class="line">| Variable_name     | Value   |</span><br><span class="line">+-------------------+---------+</span><br><span class="line">| Threads_cached    | 0       |</span><br><span class="line">| Threads_connected | 1       |</span><br><span class="line">| Threads_created   | 9626717 |</span><br><span class="line">| Threads_running   | 1       |</span><br><span class="line">+-------------------+---------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到此时的并发数也就是Threads_connected=1，还远远达不到2048</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'open_files_limit'</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| open_files_limit | 65535 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>max_connections 还取决于操作系统对单进程允许打开最大文件数的限制<br>也就是说如果操作系统限制单个进程最大可以打开100个文件<br>那么 max_connections 设置为200也没什么用<br>MySQL 的 open_files_limit 参数值是在MySQL启动时记录的操作系统对单进程打开最大文件数限制的值<br>可以使用 show variables like ‘open_files_limit’; 查看 open_files_limit 值<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n</span><br><span class="line">65535</span><br></pre></td></tr></table></figure><p></p><p>或者直接在 Linux 下通过ulimit -n命令查看操作系统对单进程打开最大文件数限制 ( 默认为1024 )</p><h1 id="connection级内存参数-线程独享"><a href="#connection级内存参数-线程独享" class="headerlink" title="connection级内存参数(线程独享)"></a>connection级内存参数(线程独享)</h1><p>connection级参数，是在每个connection第一次需要使用这个buffer的时候，一次性分配设置的内存。</p><h2 id="排序性能"><a href="#排序性能" class="headerlink" title="排序性能"></a>排序性能</h2><p>mysql对于排序,使用了两个变量来控制sort_buffer_size和 max_length_for_sort_data, 不象oracle使用SGA控制. 这种方式的缺点是要单独控制,容易出现排序性能问题.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS like <span class="string">'%sort%'</span>;</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">| Variable_name             | Value  |</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">| Sort_merge_passes         | 0      |</span><br><span class="line">| Sort_priority_queue_sorts | 1409   |</span><br><span class="line">| Sort_range                | 0      |</span><br><span class="line">| Sort_rows                 | 843479 |</span><br><span class="line">| Sort_scan                 | 13053  |</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>如果发现<code>Sort_merge_passes</code>的值比较大，你可以考虑增加<code>sort_buffer_size</code> 来加速ORDER BY 或者GROUP BY 操作,不能通过查询或者索引优化的。我们这为0，那就没必要设置那么大。</li></ul><h2 id="读取缓存"><a href="#读取缓存" class="headerlink" title="读取缓存"></a>读取缓存</h2><p>read_buffer_size = 128K(默认128K)为需要全表扫描的MYISAM数据表线程指定缓存<br>read_rnd_buffer_size = 4M：(默认256K)首先，该变量可以被任何存储引擎使用，当从一个已经排序的键值表中读取行时，会先从该缓冲区中获取而不再从磁盘上获取。</p><h2 id="大事务binlog"><a href="#大事务binlog" class="headerlink" title="大事务binlog"></a>大事务binlog</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">'binlog_cache%'</span>;</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Variable_name         | Value    |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Binlog_cache_disk_use | 220840   |</span><br><span class="line">| Binlog_cache_use      | 67604667 |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p>Binlog_cache_disk_use表示因为我们binlog_cache_size设计的内存不足导致缓存二进制日志用到了临时文件的次数</p></li><li><p>Binlog_cache_use 表示 用binlog_cache_size缓存的次数</p></li><li><p>当对应的Binlog_cache_disk_use 值比较大的时候 我们可以考虑适当的调高 binlog_cache_size 对应的值</p></li><li><p>如上图，现网是32K，我们加到64K</p></li></ul><h2 id="join语句内存影响"><a href="#join语句内存影响" class="headerlink" title="join语句内存影响"></a>join语句内存影响</h2><p>如果应用中，很少出现join语句，则可以不用太在乎join_buffer_size参数的设置大小。</p><p>如果join语句不是很少的话，个人建议可以适当增大join_buffer_size到1MB左右，如果内存充足可以设置为2MB。</p><h2 id="线程内存影响"><a href="#线程内存影响" class="headerlink" title="线程内存影响"></a>线程内存影响</h2><p>Thread_stack：每个连接线程被创建时，MySQL给它分配的内存大小。当MySQL创建一个新的连接线程时，需要给它分配一定大小的内存堆栈空间，以便存放客户端的请求的Query及自身的各种状态和处理信息。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'%threads%'</span>;</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Variable_name           | Value   |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Delayed_insert_threads  | 0       |</span><br><span class="line">| Slow_launch_threads     | 0       |</span><br><span class="line">| Threadpool_idle_threads | 0       |</span><br><span class="line">| Threadpool_threads      | 0       |</span><br><span class="line">| Threads_cached          | 0       |</span><br><span class="line">| Threads_connected       | 1       |</span><br><span class="line">| Threads_created         | 9649301 |</span><br><span class="line">| Threads_running         | 1       |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like <span class="string">'connections'</span>;</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Variable_name | Value   |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Connections   | 9649311 |</span><br><span class="line">+---------------+---------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><p>如上：系统启动到现在共接受到客户端的连接9649311次，共创建了9649301个连接线程，当前有1个连接线程处于和客户端连接的状态。而在Thread Cache池中共缓存了0个连接线程(Threads_cached)。</p><p>Thread Cache 命中率：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread_Cache_Hit = (Connections - Threads_created) / Connections * 100%;</span><br></pre></td></tr></table></figure><p></p><p>一般在系统稳定运行一段时间后，Thread Cache命中率应该保持在90%左右才算正常。</p><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><p>tmp_table_size 控制内存临时表的最大值,超过限值后就往硬盘写，写的位置由变量 tmpdir 决定<br>max_heap_table_size 用户可以创建的内存表(memory table)的大小.这个值用来计算内存表的最大行数值。<br>Order By 或者Group By操作多的话，加大这两个值，默认16M<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'Created_tmp_%'</span>;</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Created_tmp_disk_tables | 0     |</span><br><span class="line">| Created_tmp_files       | 626   |</span><br><span class="line">| Created_tmp_tables      | 3     |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>如上图，写入硬盘的为0，3次中间表，说明我们的默认值足够用了</li></ul><h1 id="mariadb-推荐配置"><a href="#mariadb-推荐配置" class="headerlink" title="mariadb 推荐配置"></a>mariadb 推荐配置</h1><ul><li>注意这里只推荐innodb引擎</li><li>内存配置只关注有注释的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">user=mysql</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># global settings</span></span><br><span class="line">table_cache=65535</span><br><span class="line">table_definition_cache=65535</span><br><span class="line"></span><br><span class="line">max_allowed_packet=4M</span><br><span class="line">net_buffer_length=1M</span><br><span class="line">bulk_insert_buffer_size=16M</span><br><span class="line"></span><br><span class="line">query_cache_type=0<span class="comment">#是否使用查询缓冲,0关闭</span></span><br><span class="line">query_cache_size=0<span class="comment">#0关闭，因为改表操作多，命中低，开启消耗cpu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shared</span></span><br><span class="line">key_buffer_size=8M<span class="comment">#保持8M MyISAM索引用</span></span><br><span class="line">innodb_buffer_pool_size=4G        <span class="comment">#DB专用mem*50%，非DB专用mem*15%到25%</span></span><br><span class="line">myisam_sort_buffer_size=32M</span><br><span class="line">max_heap_table_size=16M<span class="comment">#最大中间表大小</span></span><br><span class="line">tmp_table_size=16M<span class="comment">#中间表大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># per-thread</span></span><br><span class="line">sort_buffer_size=256K<span class="comment">#加速排序缓存大小</span></span><br><span class="line">read_buffer_size=128k<span class="comment">#为需要全表扫描的MYISAM数据表线程指定缓存</span></span><br><span class="line">read_rnd_buffer_size=4M<span class="comment">#已排序的表读取时缓存，如果比较大内存就到6M</span></span><br><span class="line">join_buffer_size=1M<span class="comment">#join语句多时加大，1-2M</span></span><br><span class="line">thread_stack=256k<span class="comment">#线程空间，256K or 512K</span></span><br><span class="line">binlog_cache_size=64K<span class="comment">#大事务binlog</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># big-tables</span></span><br><span class="line">innodb_file_per_table = 1</span><br><span class="line">skip-external-locking</span><br><span class="line">max_connections=2048<span class="comment">#最大连接数</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line"><span class="comment"># slow_query_log</span></span><br><span class="line">slow_query_log_file = /var/<span class="built_in">log</span>/mysql-slow.log</span><br><span class="line">long_query_time = 30</span><br><span class="line">group_concat_max_len=65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># according to tuning-primer.sh</span></span><br><span class="line">thread_cache_size = 8</span><br><span class="line">thread_concurrency = 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># set variables</span></span><br><span class="line">concurrent_insert=2</span><br></pre></td></tr></table></figure><h1 id="运行时修改"><a href="#运行时修改" class="headerlink" title="运行时修改"></a>运行时修改</h1><p>使用以下命令来修改变量<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global &#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br><span class="line"><span class="built_in">set</span> @@&#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br><span class="line"><span class="built_in">set</span> @@global.&#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br></pre></td></tr></table></figure><p></p><p>试验<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @@global.innodb_buffer_pool_size=4294967296;</span><br><span class="line">ERROR 1238 (HY000): Variable 'innodb_buffer_pool_size' is a read only variable</span><br><span class="line">mysql&gt; set @@global.thread_stack=262144;</span><br><span class="line">ERROR 1238 (HY000): Variable 'thread_stack' is a read only variable</span><br><span class="line">mysql&gt; set @@global.binlog_cache_size=65536;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@join_buffer_size=1048576;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@read_rnd_buffer_size=4194304;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@sort_buffer_size=262144;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@read_buffer_size=131072;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global key_buffer_size=8388608;</span><br><span class="line">Query OK, 0 rows affected (0.39 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>我们可以看到<code>innodb_buffer_pool_size</code>和<code>thread_stack</code>报错了，他们只能改配置文件，在运行时是只读的。<br>以下直接复制使用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@global.binlog_cache_size=<span class="number">65536</span>;</span><br><span class="line"><span class="keyword">set</span> @@join_buffer_size=<span class="number">1048576</span>;</span><br><span class="line"><span class="keyword">set</span> @@read_rnd_buffer_size=<span class="number">4194304</span>;</span><br><span class="line"><span class="keyword">set</span> @@sort_buffer_size=<span class="number">262144</span>;</span><br><span class="line"><span class="keyword">set</span> @@read_buffer_size=<span class="number">131072</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> key_buffer_size=<span class="number">8388608</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/dc666/article/details/78901341" target="_blank" rel="noopener">记一次Mysql占用内存过高的优化过程</a><br><a href="https://blog.csdn.net/rainysia/article/details/8767946" target="_blank" rel="noopener">mysql 优化技巧心得一(key_buffer_size设置)</a><br><a href="https://snippetinfo.net/mobile/media/1596" target="_blank" rel="noopener">mysql内存计算</a><br><a href="http://www.mysqlcalculator.com/" target="_blank" rel="noopener">mysql计算器</a><br><a href="https://mariadb.com/kb/en/library/documentation/" target="_blank" rel="noopener">mariadb官网</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：我们在使用mariadb的时候发现有时候不能启动起来，在使用过程中mariadb占用的内存很大，在这里学习下mariadb与内存相关的配置项，对mariadb进行调优。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://qupzhi.com/categories/mysql/"/>
    
    
      <category term="mysql调优" scheme="https://qupzhi.com/tags/mysql%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>vimdiff</title>
    <link href="https://qupzhi.com/vimdiff/"/>
    <id>https://qupzhi.com/vimdiff/</id>
    <published>2019-01-01T12:23:00.000Z</published>
    <updated>2019-01-02T06:37:31.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：我们在windows平台上用过beyond compare来进行文件比较，在linux平台上也有类似的东西，还是免费的。那就是vimdiff，它是vim的diff模式，依赖于diff命令。在文件比较方便比diff要强大的多，它有简单明了的界面以及对比结果一目了然的特点，容易对多处差异进行对比和合并。</p><a id="more"></a><h1 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h1><p>保证安装了vim和diff命令<br>使用以下方法启动<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1 file2    <span class="comment">#垂直</span></span><br><span class="line">vimdiff -o file1 file2 <span class="comment">#水平</span></span><br></pre></td></tr></table></figure><p></p><h1 id="切换视角"><a href="#切换视角" class="headerlink" title="切换视角"></a>切换视角</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-w w <span class="comment">#在不同窗口间跳转</span></span><br><span class="line">Ctrl-w K <span class="comment">#把当前窗口移到最上边</span></span><br><span class="line">Ctrl-w H <span class="comment">#把当前窗口移到最左边</span></span><br><span class="line">Ctrl-w J <span class="comment">#把当前窗口移到最下边</span></span><br><span class="line">Ctrl-w L <span class="comment">#把当前窗口移到最右边</span></span><br></pre></td></tr></table></figure><p>其中K和J两个操作会把窗口改成水平分割方式。</p><h1 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h1><p><img src="/vimdiff/vimdiff_show1.png" alt="upload successful"></p><ul><li>只在某一文件中存在的行的背景色被设置为蓝色，而在另一文件中的对应位置被显示为绿色。</li><li>两个文件中都存在，但是包含差异的行显示为粉色背景，引起差异的文字用红色背景加以突出。</li><li><p><code>+-- 7 lines: #include &lt;stdio.h&gt;-------------------</code> 表示折叠的行 可以用<code>zo</code>（open）可以把折叠的行打开,使用<code>zc</code>(close)可以把折叠的行关闭</p></li><li><p><code>-------------------------------------------</code> 表示删除的行</p></li><li>上下文的展开和查看：比较和合并文件的时候经常需要结合上下文来确定最终要采取的操作。Vimdiff 缺省是会把不同之处上下各 6 行的文本都显示出来以供参考。其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数，可以这样设置(设置上下文为3行)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> diffopt=context:3</span><br></pre></td></tr></table></figure></li></ul><h1 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h1><p>可以使用快捷键在各个差异点之间快速移动。</p><ul><li><code>]c</code> 跳转到下一个差异点</li><li><code>[c</code> 跳转到上一个差异点</li><li><code>2]c</code>如果在命令前加上数字的话，可以跳过一个或数个差异点，从而实现跳的更远。比如如果在位于第一个差异点的行输入<code>2]c</code>，将越过下一个差异点，跳转到第三个差异点。</li></ul><h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><p>用到的命令：</p><ul><li><p><code>dp</code> （diff “put”）<br>如果希望把另一个文件的内容复制到当前行中，可以使用命令</p></li><li><p><code>do</code> (diff “get”，之所以不用dg，是因为dg已经被另一个命令占用了)</p></li><li><p><code>:diffupdate</code> 在修改一个或两个文件之后，vimdiff会试图自动来重新比较文件，来实时反映比较结果。但是也会有处理失败的情况，这个时候需要手工来刷新比较结果</p></li><li><p><code>&lt;ESC&gt;, u</code> 如果希望撤销修改，可以和平常用vim编辑一样，直接但是要注意一定要将<strong>光标移动到需要撤销修改的文件窗口</strong>中。</p></li></ul><p>备注： 如果有多个窗口的话只要在<code>dp</code>、<code>do</code>命令前加数字代表把当前行复制到哪个窗口中或者把哪个窗口中的复制到当前窗口</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://my.oschina.net/alphajay/blog/108834" target="_blank" rel="noopener">vimdiff的常用命令</a><br><a href="https://www.cnblogs.com/motoyang/p/6091281.html" target="_blank" rel="noopener">技巧：Vimdiff 使用</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：我们在windows平台上用过beyond compare来进行文件比较，在linux平台上也有类似的东西，还是免费的。那就是vimdiff，它是vim的diff模式，依赖于diff命令。在文件比较方便比diff要强大的多，它有简单明了的界面以及对比结果一目了然的特点，容易对多处差异进行对比和合并。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://qupzhi.com/categories/linux/"/>
    
    
      <category term="工具" scheme="https://qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="linux" scheme="https://qupzhi.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用腾讯云服务器搭建vpn</title>
    <link href="https://qupzhi.com/create_vpn/"/>
    <id>https://qupzhi.com/create_vpn/</id>
    <published>2018-12-27T05:42:00.000Z</published>
    <updated>2019-03-23T16:21:42.253Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：最近腾讯云发了优惠券那就给自己搭建一个vpn吧，便于随时上外网。</p><a id="more"></a><h1 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h1><p>腾讯云centos7.2 64位</p><h1 id="服务器上配置"><a href="#服务器上配置" class="headerlink" title="服务器上配置"></a>服务器上配置</h1><p>首先查看系统是否支持pptpd服务：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe ppp-compress-18 &amp;&amp; <span class="built_in">echo</span> yes</span><br></pre></td></tr></table></figure><p></p><p>安装ppp , pptpd，iptables<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ppp pptpd iptables</span><br><span class="line">systemctl mask firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p></p><p>修改配制<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pptpd.conf    <span class="comment">#找到配制文件中默认的值，去掉注释即可</span></span><br><span class="line">localip 192.168.0.2-238,192.168.0.245</span><br><span class="line">remoteip 192.168.1.2-238,192.168.1.245</span><br></pre></td></tr></table></figure><p></p><ul><li>需要注意的是：remoteip最好不用和VPN client本身所在的局域网的ip冲突。<br>修改DNS</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/options.pptpd      <span class="comment">#末尾添加dns</span></span><br><span class="line">ms-dns  8.8.8.8</span><br><span class="line">ms-dns  114.114.114.114</span><br></pre></td></tr></table></figure><p>添加vpn账户<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/chap-secrets</span><br><span class="line"><span class="comment"># client        server  secret                  IP addresses</span></span><br><span class="line">  user          pptpd   passwd                  *</span><br></pre></td></tr></table></figure><p></p><p>开启路由转发<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1 <span class="comment">#添加在配制文件的末尾即可</span></span><br><span class="line">sysctl -p    <span class="comment">#运行这个命令会输出上面添加的那一行信息，意思是使内核修改生效</span></span><br></pre></td></tr></table></figure><p></p><p>在防火墙上开启nat转发<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE  <span class="comment">#IP和网口根据实际情况修改即可</span></span><br></pre></td></tr></table></figure><p></p><p>开启服务<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service iptables save <span class="comment">#正常来说要做这个来使iptables生效</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line">systemctl restart pptpd</span><br></pre></td></tr></table></figure><p></p><p>检查是否成功<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -anlpt  | grep pptp</span><br><span class="line">tcp        0      0 0.0.0.0:1723            0.0.0.0:*               LISTEN      27202/pptpd</span><br></pre></td></tr></table></figure><p></p><p>如果不能访问的话，看系统日志位置</p><h1 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h1><p>加一个入站规则</p><p><img src="/create_vpn/ser.png" alt="upload successful"></p><h1 id="手机上连接"><a href="#手机上连接" class="headerlink" title="手机上连接"></a>手机上连接</h1><p><img src="/create_vpn/phone_vpn.png" alt="upload successful"></p><ul><li>手机上找到vpn</li><li>新建，pptp协议</li><li>服务器ip: 你的服务器ip</li><li>用户名：你刚刚设置的用户名<code>/etc/ppp/chap-secrets下</code></li><li>密码: 你刚刚设置的密码<code>/etc/ppp/chap-secrets下</code></li></ul><h1 id="mac上连接"><a href="#mac上连接" class="headerlink" title="mac上连接"></a>mac上连接</h1><p>我发现新的MacOS不支持PPTP协议，先用shimo，等试用期到了再看要不要加L2TP</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：最近腾讯云发了优惠券那就给自己搭建一个vpn吧，便于随时上外网。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://qupzhi.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="vpn" scheme="https://qupzhi.com/tags/vpn/"/>
    
      <category term="PPTP" scheme="https://qupzhi.com/tags/PPTP/"/>
    
      <category term="虚拟网络" scheme="https://qupzhi.com/tags/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>base64</title>
    <link href="https://qupzhi.com/base64/"/>
    <id>https://qupzhi.com/base64/</id>
    <published>2018-12-23T09:59:00.000Z</published>
    <updated>2018-12-23T11:09:12.705Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎来到我的博客, 请输入密码来访问这篇文章." />    <label for="pass">欢迎来到我的博客, 请输入密码来访问这篇文章.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19uN28dpRdEAj8qMkzKyvZlVgWA58PWJRPYAuj9jCbZO1olSOioLU7ZcDYRD3y1ZkehVUMhgHmWqxL25fL6wxAG7fO14BF/X3nO7/N7ezYV0OGJXFuNK7cyLg3moTNhYPDtGqsw4oNjA95256xjtrdLPSjCqb1wjeX5FdJB49NuGQ/WJR2bCKvjo5VSMjhCixEsTl3n+4iuIzw/rUtZuee2YA7GjVlIkuY3vr6QCRYoD5ILDH8S8OE5W271RDb+MtegfkIR/0Hc4btYvM14j7MvjOSb0+437aOCD6kGUKE2i76be+rgN+2C0bywbXWYKbbRoeSZ9VJCy36brcCU+S2ek8f28pezEanhW67GkOrLcNim66jVfD0PXH34+1akJVQK3GODsBooScbM86HMMb95PofQc7ddngDgs/GhWcqB55TL9fsmgq6rec8nXyEPANXhrtkV/leOGD4rv4WI2DXTsddQDKXkseOgXATHp7sV1q0YDBeJ6fA8jYRo6Zo0TztEyCiqct9RjsILgxPWlIT5o5f9W86/FCLDihfiySt2By+PBIOqbM17xRPlF4TmMdF0oH7scAuPSBZ2sI/wH+ziro/RkSn7AgSpj6qpWZ/K07qi5BFQoeXfdF1lCx3LCwoz7WIHWaTBBZLkJgA4qR+zJxGoTAyzuaAorWhK6QvlTATOTZWRd1eiuNX0OeAE7XAJxmnuDR9TRIfklJGnLC+JXwoBc48WLu2nN4r+2rM8YJ8oXooliE6M9i2dp4L2Xa2VvcWl9/YbKGwTM3pgSgFg7ZUuzvsNt1bdOmcDBy4rJ5fcjGS1CPvLz9wq162GfxmUT7m9WpbULr0Y369T/pmTcaSyROtme8p5WSNqLYkVIR1dQxpOdr6+aiEuaQeZDGrd4En+Ah4I5swhefLay69YkFYLUpNPt2+VrGt0c3/5xnz1YjfEuk3C+TsJz1rqzIV5h8GvIUtpmUN0lT4tp/InudXJYL5sd+1Grsz/uLqgsju7HNw5UPif7i1J6iTJ0FBkRlH6Q5uChsucXkIQ1+kLJojl5yzgHRG8CHXSYvMCaQ2OBaddVBPJN0JrpwEwODXqWDHbwBjLxAAxFE03DGPghpiw+MU0DBXvTM0iwzZ0uN2BZfXkWliVblxJiKk68jvJZfiwVysPDvp/22XxmKxmWG4BNs6JPe/snaahDbeQ0yrqa5hH7lpmP0q4E8inhMaWMkCLaFlWJ3VkG8bIHtTEU5I/x61BMgwbpY+05e+N6D4qkZTMDcRlaYO6fKuLq1ES3itb7YElQWgLKdP+56zfrbashoWBQjlGNjk5InZwL2XNbQduPYUJY5qprJDFK0mhJdniA7xfds/enJ5LrNdKF7X/zfRFTpw6e+sppvHHzJVlKM0DQSNEuAxxWe49DIEXr9ZPElRNLgvcu2LkaE+MR/WbFyCuwvpK/XikIxyhOr7R9VHXgrns5CCJPlR8RVIfSi17vRHHawKIMyk3aZv2qpan/CNoiiLSEFA+4qy5AA0XthzyOavGUiACa+nUiy1m0XUNVaHQQykdXwrcVcjQycLAjPNyrfhhwNoQ5f2NXPknKZmG0V+1U/9TP3TJ1zDPyynUeJXRaUMzw8OpG9xn+HYmMlOLXB/tOZB80jiFkZYjy/DVtxbzO4d5zT2XOPq3VfTvEk8xByO9wPE+1fbWdXpjturpO7ORuwEgHZMyJ8iLSENueNE4bLv86X55wgrAFD5m60rm5WCHrr9Q/lpx1nD+gn+QCf9M2RiInDfZEOL3QUfnl/9AlhWBuabeZ2jnzTi3ETTG5tgxQVrNAVGvtUjGoE3ixt/ZQ7LEdS7If5/1smwunBOuRgfJ9qc+mnkl8LvFTwor0ebkP/g3OtxRCHWr8IKwCaiI/dot14GhOu3F9WelwP4pZELn1lLu4c5ukWQ0tFwqn1Xc6aUGAJ5ooz8TpulR0aBtgYmFNNxW3+d67J9y48VBsqs0ZPFqA/wIGmMXO+wCua2EtKaVX3G55eXSwIPMTy+9Jv0dTwqD0a5k5hxRor75ftUMum6NoJnyo0m/crzCFvFicSeMeWT403GxF89FOs+90UGZYTJKap4S8eommnOeLQ28C35ydX5M8PpHz+RUhPZwvzuHQAKdvNUq8nIUfGwLab2H0JTYh0ry6MzpXu72aoeJX5xzpnMSrz8Gwy/x5tnCuoy6KCJApu8jBU8DVgVqG0QuG9M4xf2HzOmf4sHHMCpWbDbdxBac+Pn2DUw2axN5TRx1e7MMR1P3qZxpGnJp5wSGz31Vjzfo7ClBwHb/GiN3lNy3S07YarwW1xHvPB0jj3b7okK6svumz/SaXKZ+FoKbj3cDEke3NHPVgM3kJRyoLuaR/Te6a/UdTFXL5zha34L3DJgMsEu11Mcs/ve8i91c3X/WLGD/PB8ddyP+BoxphGFP4Lx+Pd0ZOTozCD6iD2NVqTkxuYlmBmCHGJZC3cpVxw/6GrK9//jnSZDITKVt/0U79VzOiB1SVz3Lw+fms4kR8BrWoSbyXK3RseglriumsZj/XHxNHjpm8UzpGtTtFiT1CNOwjJoBoa+b14YLxZ30hVKCR5v38DlKiIzrgtFGRqaKkKKXuZ+owj/5y06QdBNfWf3uUTtxQxgBxY1F5ob4inoXXwagsmRXsyDpHQFjhyfLxDHWN6JcgxwqAegt14TgTjZIUAS7Yp5ghMv/vUxWDpgZQMKHHYGivToQdIdFbJC3nm8YtaNEywIFzCap5yzPD222OOn8hX6nQDHDYkK5QV5/STshWWDKjRzT5X5see27OHK41hD2QL8tHTYnNi2HSCBblQAbbI8Dvu9wvcIwBi9TEbEzATF91T3ILgqgRzB/7V10ky52BFuAmLQOCtWfvXlfBdpwkXGoPOzl8dH+EcPef1+mO+kjKpaaOTzzQDBZAsU2zZ7FzyykaQj6riWsDyuXSSSf6Px5/AatvKVNzdytyqaBVjj0ktm0kQ+jbVLVasylwMSKkQRosTtHxl9Lrv1pO8KX2nBSlabjkDbrj5YIT+ICFXWwJyAFtp/j8uTS1BQWGAL+vFwgh3jlE8oKPXeSzcdVZr10DAPUEMI46vWRpCn6m/rpFk3yH/vmfeQBSOZKC49Tv3Zx8ix50vzRLJzFsEKUS9aLG0nx8goVxlXC6yQEVOnf+0h3miAQutLt+g30/dnQegR6cZA7VXz7OeDg+V2CUEnTY/6vKAqB8NHIORPadjfqXGO5kbZAOs2fdP0KsXqN5OazgF+xxdJFjbsShlzFFOivXhUDpVDP/JaVnSGPVyzGyB3Rmy0lW5cFB/UeQXoVLChCs6iTdljqZW1sxVnZLu4h1i41DKVQ01BD8AEPpRJpgc4L1F8mC+YU5CvLXKJOVOjMIXuT4qGVWJmwxVMvN4TRM9wERsqFyVa/aCdCtQaNdl3GlOi9PEggpXAb+vZWwIHKPmdCjz1McKIB99VAaYTWWuGjsxFuoOLmzsCaeJyzNtozuMeyk4frSyWY5uIKY0XwJ0hiLOkvGzPlC2PdT8KIEx+1PbYKkColMlot4ImeUMoI8Ro0jLQCYCyMJGDpInrT0TanypwwgxOktGFp+2zd70jHM2sTWQL3HOuE6Ck5rFZOXl+0oeOoRE3puQ/MearXra7ec4Lnw2jK7RPb4SOoMkp4lBD2HyCMyGfUTBx21qvhWUj2UnWwAFd5mVnvObnDkI74QV2DuKKxBEszcLpIvk90p9gVAcAed7Qp5vVftfyz984WmGYfKf9+J66wwnrkFS21C7XB7Nt2LiYZB/5xT/VBUJg3WIUgus47QIbEI+L+qFzbrhaaPFm2wpx4w5Xf7DPGxwb5OQrq3JNONVrJfBrhwy6I7vb+X1Zs9PauP17VsrRLzl/9uyBULlRS2e4P/A2FODiKE4ecmt4NvWn7OmAdwXfJ0XV4CyU8MDoZs1b9bjY8zS9pFHfIpUszpqZulgAQv56/96/U9/T/XTvrY3pRllR1e+GVQUBrTc409Lx/G3ROTz3FF4j5imSByVhi03hKqR3yOUe6Z6Ea8U7OYnUiiCUTHpM3q3bUl8Zrz2TrRcex4JAzzkCuQF9VQ8ka8QJYSGGSxTTbOWDyyGqLwsSq9yIy1w68Jlh8GxJH+F15aozNn7hgXtolDdhMvqNp8UrdNjHipxg/CCMzEuw+fUj4wAZELyhiq2LdIq7M27tRxp1r+opZoUdUWIUsHGhMl0gsthHySdsMAC19U6nfRD0jSXpYWrJTkPufvGwA/carxTptFbAHOustbs+CDDW1XJbOmaRPSEhQC2WKDlFvSaVRU7UEJgYSRZMyrjXhM1ziHxgAmO0l+lzq+W7eF5ygCMvSW+TtE1cIkdWwrEBHVWjSfIvw9nCAJo+l91xzIsf2kFbjoiIxAP05B39VWzkLbQ788WKeThWyjMmQ2RmJn/U3lEK1V92qqEMxCN7fE0FIhTb/Oeza/+PMClCKS+mwPTXDnDvYZy3ogjOGX14iaGl5HpXVPIEGyIytpL6a9NdEDWfLes0T7/ag7yU6rVdfbb08/TXIgD4C7DOgoQFNAJg7WVq4YTJdpC+fZL/IJTIUiKoHGj1CXh25VzfzceceDF6ik8IXrJKsFQ4I2Rrb+b0mCEuEVHKTj/hxCbZy+x2uAFA6PZjXTPADVZr6tcgIG9/bBSMQxmuhoAibhQojFWa69aZdopah7kMzLswZDc9ybh7d+i3qGLHXaiKwMOqBeROqvTCRX4JAl6Rmd821xZBFPaOy95cQNn3Q4WOP3cT/KjNj1XxJyOhfQk9JuEk7sdAt8e7AZRWc/f6FN0ui8ws18hJzDq/MJSbpY7W2zBAKCgYDjHdONwMQbUjW2PIJevHSpfAULjUf2g48s9Aj8JCR2WvpXSwAKkMqvyMFWL8cKMWPVJEx7Dco6bIx3L5iQb8MUSG/ehVIA+jf0QFGrWIAdjhIx5JvGlvrzaOxDhzLzEs7j1AbZjEfDVd0XWr8Vq9sXs8TYj6wOMybsINS0EQTPMhD2n37q1AqiQFZGQ83F/wjaz5aCV+CPrFMjbyJk/4eFH19CDN0H6FrKNtv/JEp+GpS8ww2fBdhMlO16/PdSYR29JLJYrWMRbvBn5TmOe2zGFuZBuMAci1PnClxlFEYCidL6qxLBCKTbz6c9Tr71xa6PXRqqHR3NlGkv5QREDEL592M+DvhKNYMuf7xw6nRvtotpAcWR5BBi0doXAunilI8//ZQmDFMXkwQT1RGqh4yoNErntsnE+wHwqQ7rd/HpokfR6LPbA+uB/zoCeNfOSruHcPhJ+m4so9Z51lg0Mj7VwMBD+/SRwj6gT6gNrvi/ARsHY1dTSt8ndELyEDD2b8D9Y0SY4qDH+rI1JDFR6sRloGIOAgKTj4MhzVj/FkFXBJCpczGoqhptTupqHYIajDWufXmZ6MTjYDCVoBu+L5rM+yET49HEp2b17DVC/+EbBWWprut2OMB55pcAJrtrwE7HK5qPSYLHuNXEyrgr2+WcIFHVSXsKfbaTvb+zd3b+Ch5zJkjWE5MurFRjUvCr3TGsdXx/nlz3mAJ8RhQiqemn72L+/7gSTC51DMe/fmw/8o5SZVh48BrLBGcOBGKf8wuhYxcJmltxdIpmKIuifbrzZ31CzfeBkAvN8CEODdWiGkGutJv5SxysL6VBLg+7Qg6ftOIumOCho63oRJwKCt3mzQHznR6NaVNvqgdGDn+bb5DfBhsdJO+vV37XudYMM6tSgVm2brzCkNrIepdjZfwhv6mXOIRSxQ7WhTaada0yyUIW4/ssEB7WBZ2XCnlzqbZ9HNLFwNdlU+4xn4gOm9N6Yi/V6ikGq7TxR8gzO9yZhCF7UW3AldJBxr/t8QNz3++HEePS2U4Ix7uQPRDkXfyVrLU3nOUDQwwxySnTheeZwC+NUefN8wcXe5Q3nvti77cHT9AVSRwEQEoU30n2mUmsMW4Mat6EkYowUXi+FI1frFKs9HqKou6vIvoMQs8RZN1x0ebCXddXzu8/PrSBDFURSwi3FBvpS+YvPvkmLCGo9X1LqLkjA9up6W07M+32LDnCm4V4iOJqjALdDQKsoe6FqJ1sC42JqVuIFex0rOIrKFguU/aG8PW05kSWU+vl0q0tppXJuR/Y5cxYr5hjXVM4VQziXwGhJ8Sp6olv27EJFjtbvXwT0ESNUxjn4VeN2mez+5AaoaYQwWhAcOr0w3ioQ6eWRHgUo0104HmZOq0z53cIlm2fhWIq3reJphhJR0nUZn+KlGnkTiLyhExJbqnSJOX6k5QL6PwNRQnVHa1FXBVEdzKdCG4Xn/IDwSCWkH6yPXZT5Khw1RjJs4vS5Jcrnp0V8OnmGPxZyLLI8aCM+YPuS6Tfsb8T3p1zHwIpRM+xPb3I3x14Zhud8VixtYFXd8494O5pvC4txeF4HYSzuf2se5F079c9Lw8hrUWk/XDWA+AZniV9WmwwNhd/Ud3G1xVxsSrsTqcJt8mx3BqPTfYY0gMxstlY8Prx2gK1faH7UlexKq8URF4OwUGe6rfM4A6I75uxD3r/sqWAV8pjjG8s0pF+FXCkl6PaQPLIsnq0pAYSGbXVQkidvH4G1FRUqcjiKoaY/M87edTtkqvxRARuBI+kYTeXWoSU7tTNgmCJSUMPmFwjQjMS9Xqom9zvj689+jLSprHckBphqLlkr5cMQvtYAIsmmF5bt4TzuWljfNPqx57j59id1JnIHVOBotfGUhI2EbfnaPwTHr0/zj6nSVhGQl/eNnnuMT3WIts9pqH93Lfo9C1g5j5IYCu/RP01GTg0jBg8phJXGrp9jR8yo4RzjH7uFtDwNpZZPptyKgngr0AVXWmWnQhd3urVWFKSR2MftTuGEhZPkkblx6i4je2fkQ2Q0wYUfJXhHQ2D0sGxW0b3Z7b3V0x4je70dC8xfXwU7AuBNvMMU/cwpdUwW4zVuMcSaTo/aV09RUC4+p8L01CvaMr7EJGiuTHHDmChLdHMjcbhf2ZrMvp/K+T3+Es4Jszbxqh28Pqr1yoknI/rbas7H99a1r5XDAblUStf69+mEpp9KBx+gVo99CpiNxk7p594CpskX4dchw5rhJmdhFvZ79dC0RFWrcOIyGD7ylk62bKibIvIzTwvg5247yJGAXZqZeAZ7sKCqC5ilsaIXJ4Jb0661tuLXnX+jIEs4vkPn8+fGr/KxX/C9oKxh8kKUaqIi03BAEjszchsTgVTKwGynxUwc6lFIsUJtK8f/tDMBeijZXbg8W+94itoOuQ5xYFrigx1moFRc2Bo3g5q6rSSxo/6CQZsXHcOMf8ugCOUaxbYXMcO4n4wlubkAfr/IxeFlDiUs49Zt5OQuU34WmpnJd4zLOmhw4LDKFjRgOalzMAfddGXeE34mSjX+ULCyuGIJ9WX8kwF+LE0JjWu6x406noBlNENDz9wQ/CRctywZZw9OAvcgyVv3/NWcR3+xEb5LT8+5Njsypjvi8QAnuFbp++qBSkc6S+dNytgGngWYYpi5AsT1V+b8/fuT+W/tLQraR4JhkU9N1j+rqO2POERSmcfvwnFO1nbUOBwbn1nkPccCKjh8TKisTGTxqQd0xacLQZ6zWdz5L//lf3MuY62SDyZSbQ/NR+4KETqrH1MYWquWN/C3ER7yXenXF2CyrmfivrAAePftr3aJCW/h0d24Gm/aogoUnVIe4rUhRm1DsTyrggAxhsLyMuqr1wkapm1aLDUcgOGZ9GBXCaKSoEtF4U5JPou2COLC4xMfhcS/7NUHP0aNswArxspuL5qZWNb6v/0J97zcze71gcNnjmJ9de7ZcxphSu9ZzaFr4R+PA00E8FPd/OcAxJUxbyc2oEOztn5kObw2ykWyanMmErKPyOUHr6LDRHepjFOh8FP+pO2QMKkZlhzGMUelt8cWdJkMrbKlYF5Gegwv5a5vSDBzFrrRjJVkFUFC9LGYLuaqkkySXa3ivuHh+I/ovX03sybEI/mTRj2wHGNXuWFZzKqZH1VV8LXlHK6Ufc8HWx+7cJZM9BV3GmKhUoXo0hLvE8Vu0jv4/l1ERubsR7T2h8bf3ZnnkikznOkj/g23Ro4qy4I3sGnypUvRv8JviMt0Mx2Og3iwJZ7dSSHCXc9Nzl78RGx7HrM37etKyyNw3oNHyPd7Rxl6t+yxooi81HyBQVnKWW61G8i0neyoI/i/1Wh6Asq/vuXykT7Snj+Mhr2qAvqUHNRJCJU0JDW5fkpoGsNjK3qRA8POkA9iJkimLpWna5xnadLhNBfxw48wnjdBMqY0oivEyjrz62gWXYpqAj3xZICJYviQW1bIKDznDtVhsC++hcIQH0Pbgk7dYhU9w7x6RbzVgf03U549J25iV73VotS3k23YdiMy3j5H01LeUQB4H0883Ks3vI6DV2QtQfw2z1zTeUSSfsirJKMk3csr75WUX6fhA+Z1+z/xadc2wKXGaTI2iRJiMRUAwnZu/1kNQD80fMI1BqwuEAxmS/UEPOUVMPvCFL1zfmVHu3U0pf6dYz2J6Fqr5E7Dnb+HnKya4X4I0xVpQGCxPy7lN7kstCWwmH+gDYGnAfV4FNV33NYmvpuVj4cZRP+nH5kKp2KEtaEpgZb5bHFSoslMhsre6cNAOyMldKr88qjTvu9sNl/q8IBjVerAr5eDgVKNmjMPtkXV8i7OQJTiNEn6m2C2XgBCDtQD4weGwUmugEAtZMWoxWMFMucuQZFvHmDN33qvaVZqGPUGivIRimkj7HojcuDXDTdDrphWLz+RPgQekADEE9E5Ztjy+cfaDnVXgraoF8yjKXMz224Hk/HHirxdziNHUTSAhKFV7yyukZH4xZlLOWTCOwmAd8JiWxN13zPRiczKCxtUu1JB9j9Lbrz6mcVBd/T2jm2jrPnX0li931ohBxB1lN6ieND5WnkmULySAIcgtNbvOn22n/XNg25dQoWsW92VIO/+tVXf2KcA4DjSknqyR4WqR+G6cUnrQeCP4iKvGs6oPjshScYEvMBEFZOoDkMHc9qn/RKk0fNhSiEEnvfVedJWjP/2Lnap31kFOQSSj+D7PzqO723Czsvq1ZkI0w7e/9Rf/gSl+ag7pd+g1ix3AUU4JjsFBDPjz110a738I2zE3c+xCxJy4cW6UknExY0r1F0YYt54tNixWMtlUW+GQsCF8WOjfjBgZ0zMLKFO6UCT8Nh1fW45F3wzOC41cfkJBZD1FsSZGLRcqhnTH2TN/jtF8ffTKulgwEpQbsufVOP66ux7BIKpN/RxkwSnQ2qReQSdyrxjrcILb31R5wKl74+39CjR4l3XQCRUIINkoFxFO4qSU/hVrHkGbmBLdyqQdrw2PpUqNaec5Jvg9F/s2cGW+hltAqQ2lGoPuKSGCohDYF38Q307iUoW9hTRVVuDDdppEj9Gs3t8Fu1mLWdvGh0a02i7A4Hpr9Qu4yu0yqRHskihS6yNtLZwNcv2lw3Zdqy9AT5E8V1eh0Bmtbi/5wWU9v/Xh9UAcV/NeqkdTeU1XIKu98ZtCoOK/4X8Otz55+JckzHE4QT/vOnpQxuqAG4tvMYfeyHg9zhBwqs+NNXjZ/WtX22Rav7RdQO6dd4SzyUO55IHTuEhvwZ8hnZ7LEu9iQt1GblFXFHciMw4toUFO9ineHX9nPienNyqzdr/0y++mA1DqFs4wBps/9yIMFKsJ4Cw4HjE4q4XprMHe/Jar1FQz5nPOPkYF0WavQ6NUBJdrWeBGCmvxiaNFz9vZ8LtDBLnEyiyQWnIIP+0/9ooIdvBQ2FCWbzpk+mQwotaFLve+2P2DmHfyvPLTk52NYIR9Mon/r2n2wbX0fdfH3Rp9/fu2l9nHhrK4soqby1mPX6EfphYzHcwgVp6lY13v790smNmxz9o1icfk4sumUW/RuZCugXAqfz3GMWfdTt/lLJ8dci1Y9Da/j0rovI4BUrJR4ZFXnFLvpURy4BWM25oWItFGqxMcfJleQaPk4rbNQQ9rEv9HWyItfEfPW4XQ7bPhxMzE/CdIBFN8WviP3cSJhYp4kih3/gA55la/nHrdJ26jNpWRctZORQIS4qytUsQVL8GKXW+ynGiXtiJV+Rn6T/NKvfP6ydGqQ4OmjGPJEb5h7AY2Hu6y0l2l08d9HihlG3qMGyD10zZWRJNtVunlfx9lMFrGbjRen2vMWRzoVdTMsnDwu0ot+JmYQb09/HbTh8Ut01ZUyRZcGTwUH8Ha30icq8sPUuDavT1ETLx4rYzxJlb9m8qHpB/s/Or5NQvhmt4eLuN94/8iIXQsyZjVrAcWo4iE57QhV8SpuKvGAhYIBMSlO/mOv6fkDv2CkVYfMCj5MRYAlYd0gnR/6UXAcssNIAkm+2B/B3kWZxqUGYhGKh4u9kYvDalX914zTAATMIimupkTg/k/ykarIBSia+avL8+nts7fndwoMci9QrIl+/nH8q8vmh8sE8ga/7O26xKnrEdlLOnq9iuOWuR5EBbjLVq5SJe0ycsTFdlFw2sDSIV4P4sfxWWxwBr1bNnikUVTsOWvw4CDlzckeQ/YqlRrSTUHwvY09zT6zm5w7DQFejQFy02gF4jPxInl57ZwubipCjCCaAx1SXDXqflV8fgY1JlvM1Ij5QU+O70rJV/PWaS1kJpShafUDQ2WxEsKyuOVsdfUBZiRLkZUgjzdOmnTSSogU9jXm1izwVYYnuG+n+4z7XBbAtnCoLS0pbYgRCQwvxqwdO/8LZVKAtBZctV4x5/8KXSZ9TdRsgsxAhQq7J7XvtwpUseSn94/b74n5f7z5hgFbK5WeRZAnDuFsA75/jamNlUkAs2XN572FSY5gAx2Oy7hC2LoqKfsG5nvH0p8WXZdi2aTVXlgrX4y0/g40zRwtyBi7NQGGJFn4RB+qM00OMHnep+75mM+LhdwSiRPpfPsTE1v9fs7oSkQ/LiSxI0nY0tgDT7PArQv4Zhak5aAjfuaFJwYqVCX4AsBZpOeaBcvXcIoATmqj6wQy3bBUxDoVReTGqSaS4v8K/qfC4049dBnOQ4ws31zfOcwy9UO7+lObUdVNIOB6HnhbpfzDku0mRA0lj5yk+GRQOEo5yBCPj3p6JjqKCQMJ0mdK3ftOROdgXd0zfpvdLAl9tNH36nC1lDhdi7zsGAKl62RJcEIO3RmEaO9qvm270wQK4WTJr8F05/hw1qPi3pSQgc/011JYWv9GC3c/xtcZZGeR8V8/oRGghVM92wU1Y1l7xlW6LVbmPQT5u/qVX5/eyxZBSi/YZBqoKpn/pUwNl8+uPU3vWAQB9fUFjg49I4cxoW5vJXjhPV8bFzTf1N8xK8sEf/wxhIFOnhLG7cbI4vvC9SNnid7eEGuXyT0GoXo2MpglAIma0UGC28gwObDc+ABjqyXUWb4EtzhR3X7yYZAJC2+U8Vok9vUfhd/XxPL4ZywIOoCSWG8xgDRECxHdbqMujqcJu1L8RZankzUuNt37Fm8HRTH0WR5TV5P+XYonfF5Zztg/O2xycHswAcWjEmfZrxmJGDPrl1CVkH8huj6uHLdZYn9OBK2TEM0YDmieNqpCJSOGAKF3UGdrEZzJJY/536NGN5EFRUL3pOmpJJ+SNJyZUM7F+7sqOfBUzTacbtCQqTL1gftovUZNENw9ntS1eVkUtaeU/JEdC99Aqq0lGcrnupskZa7fqvy2+YwJ15tUwRn2P0MRUIya/83obY8gdUKpyEuWmPt/Axf/sTNxOxaTxRh4Y3ld+HtUT+k4nCbAIfdXnCnM30nx5+kTwO01gTo+i2xQNiIeKDO2iBMu4i+2OIFdDqD9D4syDLvEc7+2uOwtsvCAb0yI0hc4F9XJke1cjkR4FgFOf0ycxKryo5+Wrns/S8Lw+2P7GWp9Sl7S72fxY37BvaF27YEsuq0/dR/5VeOp53MDWwMW2FAvZnND5xHW31WfPn70dpLuR4hyAZDVGQnd/gmabvyGD6GKziaQhXj6tliednQqLVsWJzw5P5u5yFbuw1Wwh25YK+ELJ6OWJa6az4zwjWiBMwLuLqv9bbZkNZy9A3DNnlW6eTxIKE9DfpaK0SKPgwdvipZgixRJWeii0DA0szyrG1+PTthOnL/zHWQsurtHaZ/DSq+DjSPaNyo9ZrcbU23gjavTLUx1yKv578eJmxyFT9MYQ2s+MvXywSpelFGTypyw7Fbmiknb1tG+COmFYEBQA5A2tGUMlNPGUCTQl1dRZKMRq9yJI2eLn4SjUu5Lw1jMRiZ76VMWtbJZvQvQHHxUlQ03EPOqKIeLn94Feb0B1WgFqPYimCMHKJFOU++hDRb3NyebtPa7vzP+Sxwb1jmIl3/5XymWT/2RsuCXmKs34kVR6qgSiGZwTaKyX+/gLdLww6Q7ZBPw1FMo270NM74o2WfwoAMNs2xCZrrDkNbdm4wvRLYyAlqtUhfIML93+s9FO+h8891Ngg2Oyv11qIeHmIVz29JQOHVpt5UrKbfu8NNBp4iZ0AJvWiE/zfYzswR8WbXMYcUJqZTwv26gATM7Aw/g5bfbRUAhtWDJ4zDSCPyNUBGLrh5P+21S48CDpl5AtY+Sy49SDoFabCV4CBxRX46UjBzjD+U6wNhBMY1z5Z2AMU9KMy/SxHuTyzUAZoDMrf9GO/rVmFiOMmiGY5HOv+6XU3a0rwJ1eQMt08JQQPAS9wvXlaDZ/m9n+XiKXdi4uosOc5RdqnI7HUSMtubwQXCb+ZiMxEYehBgdHcKLmQ1miNupZ0DbvxxHrHr+Azkl/2fE43oNCP2bZbCef4EdZCoP1DZEkaqmc1HIVRL1PmxyNLDumSxPgTg5IGnxojxOUgs7V3e0fVJOkXlgnkbH8lWx7Jcw0rg8dA==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎来到我的博客, 请输入密码来访问这篇文章.
    
    </summary>
    
      <category term="base64" scheme="https://qupzhi.com/categories/base64/"/>
    
    
      <category term="base64" scheme="https://qupzhi.com/tags/base64/"/>
    
      <category term="编码" scheme="https://qupzhi.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="加密" scheme="https://qupzhi.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>版本控制工具——Git常用命令 </title>
    <link href="https://qupzhi.com/git-start2/"/>
    <id>https://qupzhi.com/git-start2/</id>
    <published>2018-12-18T05:04:00.000Z</published>
    <updated>2019-01-21T06:01:29.969Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：我们说过了git的几乎全部的常用情况，相信基本已经可以在平时团队协作开发的过程中游刃有余了。我熟悉了git的使用以后，这里给出git常用的命令，以下的命令几乎覆盖了所有的git常用操作，在此记录便于快速查找使用。</p><a id="more"></a><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git init                                              <span class="comment"># 初始化本地git仓库（创建新仓库）</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span>                   <span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@xxx.com"</span>          <span class="comment"># 配置邮件</span></span><br><span class="line">// git status等命令自动着色</span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         </span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line"></span><br><span class="line">// 查看当前代理设置</span><br><span class="line">git config --global http.proxy</span><br><span class="line">// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080</span><br><span class="line">git config --global http.proxy <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span> </span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy    <span class="comment">#删除 proxy git config</span></span><br></pre></td></tr></table></figure><h2 id="代码文件与提交相关"><a href="#代码文件与提交相关" class="headerlink" title="代码文件与提交相关"></a>代码文件与提交相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></span><br><span class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></span><br><span class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></span><br><span class="line">git commit -m <span class="string">'xxx'</span>                                       <span class="comment"># 提交</span></span><br><span class="line">git commit --amend -m <span class="string">'xxx'</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit -am <span class="string">'xxx'</span>                                      <span class="comment"># 将add和commit合为一步</span></span><br><span class="line">git rm xxx                                                <span class="comment"># 删除index中的文件</span></span><br><span class="line">git rm -r *                                               <span class="comment"># 递归删除</span></span><br><span class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></span><br><span class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></span><br><span class="line">git <span class="built_in">log</span> -5</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></span><br><span class="line">git <span class="built_in">log</span> -p -m</span><br><span class="line">git <span class="built_in">log</span> -- filename                                       <span class="comment"># 查看文件的修改日志 </span></span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></span><br><span class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></span><br><span class="line">git show HEAD                                             <span class="comment"># 显示HEAD提交日志</span></span><br><span class="line">git show HEAD^                                            <span class="comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span></span><br><span class="line">git whatchanged                                           <span class="comment"># 显示提交历史对应的文件修改</span></span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span></span><br></pre></td></tr></table></figure><h2 id="tag相关"><a href="#tag相关" class="headerlink" title="tag相关"></a>tag相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag                                                   <span class="comment"># 显示已存在的tag</span></span><br><span class="line">git tag -a v2.0 -m <span class="string">'xxx'</span>                                  <span class="comment"># 增加v2.0的tag</span></span><br><span class="line">git show v2.0                                             <span class="comment"># 显示v2.0的日志及详细内容</span></span><br><span class="line">git <span class="built_in">log</span> v2.0                                              <span class="comment"># 显示v2.0的日志</span></span><br><span class="line">git push --tags                                           <span class="comment"># 把所有tag推送到远程仓库</span></span><br><span class="line">git tag -d tag_name                                       <span class="comment"># 本地删除名为tag_name的tag</span></span><br><span class="line">git push origin :refs/tags/tag_name                       <span class="comment"># 远程删除名为tag_name的tag</span></span><br></pre></td></tr></table></figure><h2 id="差异比较相关"><a href="#差异比较相关" class="headerlink" title="差异比较相关"></a>差异比较相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff                                                  <span class="comment"># 显示所有未添加至index的变更</span></span><br><span class="line">git diff --cached                                         <span class="comment"># 显示所有已添加index但还未commit的变更</span></span><br><span class="line">git diff HEAD^                                            <span class="comment"># 比较与上一个版本的差异</span></span><br><span class="line">git diff HEAD -- ./lib                                    <span class="comment"># 比较与HEAD版本lib目录的差异</span></span><br><span class="line">git diff origin/master..master                            <span class="comment"># 比较远程分支master上有本地分支master上没有的</span></span><br><span class="line">git diff origin/master..master --<span class="built_in">stat</span>                     <span class="comment"># 只显示差异的文件，不显示具体内容</span></span><br></pre></td></tr></table></figure><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git <span class="comment"># 增加远程定义（用于push/pull/fetch）</span></span><br><span class="line">git branch                                                <span class="comment"># 显示本地分支</span></span><br><span class="line">git branch --contains 50089                               <span class="comment"># 显示包含提交50089的分支</span></span><br><span class="line">git branch -a                                             <span class="comment"># 显示所有分支</span></span><br><span class="line">git branch -r                                             <span class="comment"># 显示所有原创分支</span></span><br><span class="line">git branch --merged                                       <span class="comment"># 显示所有已合并到当前分支的分支</span></span><br><span class="line">git branch --no-merged                                    <span class="comment"># 显示所有未合并到当前分支的分支</span></span><br><span class="line">git branch -m master master_copy                          <span class="comment"># 本地分支改名</span></span><br><span class="line">git checkout -b master_copy                               <span class="comment"># 从当前分支创建新分支master_copy并检出</span></span><br><span class="line">git checkout -b master master_copy                        <span class="comment"># 上面的完整版</span></span><br><span class="line">git checkout features/performance                         <span class="comment"># 检出已存在的features/performance分支</span></span><br><span class="line">git checkout --track hotfixes/BJVEP933                    <span class="comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span></span><br><span class="line">git checkout v2.0                                         <span class="comment"># 检出版本v2.0</span></span><br><span class="line">git checkout -b devel origin/develop                      <span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">git checkout -- README                                    <span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git merge origin/master                                   <span class="comment"># 合并远程master分支至当前分支</span></span><br><span class="line">git cherry-pick ff44785404a8e                             <span class="comment"># 合并提交ff44785404a8e的修改</span></span><br><span class="line">git push origin master                                    <span class="comment"># 将当前分支push到远程master分支</span></span><br><span class="line">git push origin :hotfixes/BJVEP933                        <span class="comment"># 删除远程仓库的hotfixes/BJVEP933分支</span></span><br><span class="line">git fetch                                                 <span class="comment"># 获取所有远程分支（不更新本地分支，另需merge）</span></span><br><span class="line">git fetch --prune                                         <span class="comment"># 获取所有原创分支并清除服务器上已删掉的分支</span></span><br><span class="line">git pull origin master                                    <span class="comment"># 获取远程分支master并merge到当前分支</span></span><br><span class="line">git mv README README2                                     <span class="comment"># 重命名文件README为README2</span></span><br><span class="line">git reset --hard HEAD                                     <span class="comment"># 将当前版本重置为HEAD（通常用于merge失败回退）</span></span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           <span class="comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span></span><br><span class="line">git branch -D hotfixes/BJVEP933                           <span class="comment"># 强制删除分支hotfixes/BJVEP933，小心操作</span></span><br><span class="line">git ls-files                                              <span class="comment"># 列出git index包含的文件</span></span><br><span class="line">git show-branch                                           <span class="comment"># 图示当前分支历史</span></span><br><span class="line">git show-branch --all                                     <span class="comment"># 图示所有分支历史</span></span><br></pre></td></tr></table></figure><h2 id="图示命令"><a href="#图示命令" class="headerlink" title="图示命令"></a>图示命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git ls-tree HEAD                                          <span class="comment"># 内部命令：显示某个git对象</span></span><br><span class="line">git rev-parse v2.0                                        <span class="comment"># 内部命令：显示某个ref对于的SHA1 HASH</span></span><br><span class="line">git reflog                                                <span class="comment"># 显示所有提交，包括孤立节点</span></span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               <span class="comment"># 显示master分支昨天的状态</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph                   <span class="comment"># 图示提交日志</span></span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br></pre></td></tr></table></figure><h2 id="暂存相关"><a href="#暂存相关" class="headerlink" title="暂存相关"></a>暂存相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash                                                 <span class="comment"># 暂存当前修改，将所有至为HEAD状态</span></span><br><span class="line">git stash list                                            <span class="comment"># 查看所有暂存</span></span><br><span class="line">git stash show -p stash@&#123;0&#125;                               <span class="comment"># 参考第一次暂存</span></span><br><span class="line">git stash apply stash@&#123;0&#125;                                 <span class="comment"># 应用第一次暂存</span></span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git grep <span class="string">"delete from"</span>                                    <span class="comment">#查找当前分支下的文件内容，可以git grep --help看具体用法</span></span><br><span class="line">git grep <span class="string">"delete from"</span> v2.0                               <span class="comment">#指定tag来查找</span></span><br></pre></td></tr></table></figure><h2 id="git-index操作"><a href="#git-index操作" class="headerlink" title="git index操作"></a>git index操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git update-index —assume-unchanged 文件名                  <span class="comment">#取消本地跟踪</span></span><br><span class="line">git update-index —no-assume-unchanged 文件名               <span class="comment">#恢复本地跟踪</span></span><br><span class="line">git ls-files -v| grep <span class="string">'^h\ '</span>                              <span class="comment">#可以看到本地不跟踪的文件</span></span><br></pre></td></tr></table></figure><h1 id="管理远程分支"><a href="#管理远程分支" class="headerlink" title="管理远程分支"></a>管理远程分支</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote                                    <span class="comment">#不带参数，列出已经存在的远程分支</span></span><br><span class="line">git remote -v                                 <span class="comment">#(-v是–verbose 的简写,取首字母)列出详细信息，在每一个名字后面列出其远程url</span></span><br><span class="line">git remote add [shortname] [url]              <span class="comment">#添加远程仓库</span></span><br><span class="line">git fetch origin                              <span class="comment">#字符串 origin 指代对应的仓库地址了.比如说,要抓取所有 origin 有的,但本地仓库没有的信息,可以用</span></span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：我们说过了git的几乎全部的常用情况，相信基本已经可以在平时团队协作开发的过程中游刃有余了。我熟悉了git的使用以后，这里给出git常用的命令，以下的命令几乎覆盖了所有的git常用操作，在此记录便于快速查找使用。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://qupzhi.com/categories/git/"/>
    
    
      <category term="工具" scheme="https://qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="版本控制" scheme="https://qupzhi.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git教程" scheme="https://qupzhi.com/tags/git%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>版本控制工具——Git常用操作（下）</title>
    <link href="https://qupzhi.com/git-start3/"/>
    <id>https://qupzhi.com/git-start3/</id>
    <published>2018-12-15T05:21:00.000Z</published>
    <updated>2019-02-13T06:19:12.904Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：上一集我们一起入门学习了git的基本概念和git常用的操作，包括提交和同步代码、使用分支、出现代码冲突的解决办法、紧急保存现场和恢复现场的操作。学会以后已经足够我们使用Git参加协作开发了，但是在开发的过程中难免会出错，本文主要介绍版本控制的过程中出错了的场景，以及Git开发的一些技巧，让我们用的更流畅。</p><a id="more"></a><p>上集回顾：</p><ul><li>Git的基本概念</li><li>一个人使用Git时的代码版本控制–（提交、拉代码、分支操作）</li><li>多人合作时的代码版本控制–（合并冲突、暂存代码）</li></ul><p>上集传送门：<a href="/git-start" target="view_window">版本控制工具——Git常用操作（上）</a></p><p>本文核心：</p><ul><li>后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）</li><li>哎呀，提交的时候漏了文件</li><li>tag操作</li><li>git忽略不想提交的文件</li></ul><h1 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h1><h2 id="撤消当前commit"><a href="#撤消当前commit" class="headerlink" title="撤消当前commit"></a>撤消当前commit</h2><p>如果你发现刚刚的操作一不小心commit了，所幸你还没有推送到远程仓库，你可以用<code>reset</code>命令来撤消你的这次提交。<br><code>reset</code>命令的作用：重置HEAD(当前分支的版本顶端）到另外一个commit。</p><blockquote><p>我们的撤消当前提交的时候往往不希望我们此次提交的代码发生任何丢失，只是撤消掉commit的操作，以便我们继续修改文件。如果我们是想直接不要了这次commit的全部内容的任何修改我们将在下一小节讨论。</p></blockquote><p>来，我们先说一句蠢话来diss老板<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ touch to_boss.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a bad guy!'</span> &gt; to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git add to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"[+]骂了我的boss"</span></span><br><span class="line">[master 3d113a7] [+]骂了我的boss</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 to_boss.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>创建to_boss.txt文件，并向其写入了<code>my boss is a bad guy!</code></li><li><code>add</code>然后<code>status</code>查看新文件已经加入跟踪</li><li><code>commit</code>提交了这次的修改</li></ul><p>好了，刚刚我们“不小心”diss了我们的老板，要是被发现就完了，所幸还没有<code>push</code>，要快点撤消这些提交，再换成一些好话才行。<br>我们使用以下命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft head^</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line"></span><br><span class="line">$ cat to_boss.txt</span><br><span class="line">my boss is a bad guy!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a good boy!'</span></span><br><span class="line">my boss is a good boy!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a good boy!'</span> &gt; to_boss.txt</span><br><span class="line"></span><br><span class="line">$ cat to_boss.txt</span><br><span class="line">my boss is a good boy!</span><br><span class="line"></span><br><span class="line">$ git add to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line">    </span><br><span class="line">$ git commit -m <span class="string">"[*]夸了我的boss"</span></span><br><span class="line">[master 8be46aa] [*]夸了我的boss</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 to_boss.txt</span><br></pre></td></tr></table></figure><p></p><ul><li><code>git reset --soft head^</code>撤消了本次提交，将工作区恢复到了提交前但是已经<code>add</code>的状态</li><li>将<code>to_boss.txt</code>的内容改成了<code>my boss is a good boy!</code></li><li><code>add</code>然后<code>commit</code>提交</li></ul><p>好了，有惊无险，这就是撤消commit的操作。另一种情况是如果你想撤消commit的时候支持舍弃这次全部的修改就把<code>git reset --soft head^</code>改成<code>git reset --hard head^</code>，这样你本地修改就彻底丢掉了(慎用)，如果真用了想找回来怎么办？见<a href="#救命的后悔药">救命的后悔药</a>。</p><p>当然了，你只要开心不加<code>soft</code>或<code>hard</code>参数也是安全的(相当于使用了<code>--mixed</code>参数)，只不过是撤消以后你的本次修改就会回到<code>add</code>之前的状态，你可以重新检视然后再做修改和<code>commit</code>。</p><h2 id="回退远程仓库"><a href="#回退远程仓库" class="headerlink" title="回退远程仓库"></a>回退远程仓库</h2><p>要是我们做的更过分一点，直接把这次<code>commit</code>直接给<code>push</code>怎么办？要是被发现就全完了,我们来看看github上的远程仓库。</p><p><img src="/git-start3/rollback_push.png" alt="upload successful"></p><p>完了，真的提交了（我刚刚push的）让我们冷静下来，用<a href="#撤消当前commit">撤消当前commit</a>的方法先撤消本地的<code>commit</code>,这次我们来试试用<code>hard</code>参数来撤消</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard head^</span><br><span class="line">HEAD is now at 3f22a06 [+]add file time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git push origin master --force</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> + 3d113a7...3f22a06 master -&gt; master (forced update)</span><br></pre></td></tr></table></figure><ul><li>使用<code>git reset --hard head^</code>回滚到上一个<code>commit</code></li><li>使用<code>git status</code>查看现在的工作区情况，提示<code>Your branch is behind &#39;origin/master&#39; by 1 commit</code>,代表成功表了上一次的提示状态，<code>nothing to commit, working tree clean</code>代表这次的修改全没了，清理的算是一个彻底。如果还想找回来怎么办，我们还真是有办法让你找回来的，见<a href="#救命的后悔药">救命的后悔药</a>。</li><li><code>git push origin master --force</code> 命令强制提交到远程仓库(注意，如果是在团队合作的情况下，不到迫不得已不要给命令加–force参数)<br>让我们看看<code>github</code></li></ul><p><img src="/git-start3/rollback_push2.png" alt="upload successful"></p><p>真的撤消了远程仓库，长舒一口气。</p><h2 id="暂存区（Stage）到工作区（Working-Directory）"><a href="#暂存区（Stage）到工作区（Working-Directory）" class="headerlink" title="暂存区（Stage）到工作区（Working Directory）"></a>暂存区（Stage）到工作区（Working Directory）</h2><p>如果我们刚刚执行了<code>git reset --soft</code>或者<code>add</code>等的操作，把一些东西加到了我们的暂存区，比如日志文件,我们就要把他们从暂存区拿出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   mysql.log</span><br><span class="line">    </span><br><span class="line">$ git reset -- mysql.log</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">mysql.log</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><ul><li><code>status</code>查看暂存区，里面有一个mysql.log被放进去了</li><li><code>git reset -- mysql.log</code>把<code>mysql.log</code>取出来</li><li><code>status</code>可以看到真的取出来了<br>然后如果不要想这个文件的话再rm掉就好啦,但是如果这些文件每次自动生成都要用这种方式取出暂存区真的好累，我们可以用 <a href="#git忽略不想提交的文件">git忽略不想提交的文件</a></li></ul><h2 id="回滚文件到某个提交"><a href="#回滚文件到某个提交" class="headerlink" title="回滚文件到某个提交"></a>回滚文件到某个提交</h2><p>当我们想要把某个文件任意的回滚到某次提交上，而不改变其他文件的状态我们要怎么做呢？<br>我们有两种情况，一种是，只是想在工作区有修改的文件，直接丢弃掉他现在的修改；第二种是想把这个文件回滚到以前的某一次提交。我们先来说第一种：</p><h3 id="取消文件在工作区的修改"><a href="#取消文件在工作区的修改" class="headerlink" title="取消文件在工作区的修改"></a>取消文件在工作区的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 18:51 &gt; time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   time.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">18:51</span><br><span class="line"></span><br><span class="line">$ git checkout -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br></pre></td></tr></table></figure><ul><li>更新<code>time.txt</code>的内容，可以<code>status</code>看到他发生了变化</li><li><code>git checkout -- time.txt</code> , 取消这次在工作区的修改，如果他已经被<code>add</code>加到了暂存区，那么这个命令就没有用了，他的意思是取消本次在工作区的修改，去上一次保存的地方。如果没有<code>add</code>就回到和版本库一样的状态；如果已经加到了暂存区，又做了修改，那么就回加到暂存区后的状态<h3 id="将文件回滚到任意的版本"><a href="#将文件回滚到任意的版本" class="headerlink" title="将文件回滚到任意的版本"></a>将文件回滚到任意的版本</h3>我们这里说的把文件回滚到以前的某个版本的状态，完整的含义是保持其他文件的内容不变，改变这个文件到以前的某个版本，然后修改到自己满意的样子和做下一次的提交。</li></ul><p>核心命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;options&gt;] [&lt;branch&gt;] -- &lt;file&gt;...</span><br></pre></td></tr></table></figure><p></p><p>我们还是用<code>time.txt</code>这个文件来做试验,先搞三个版本出来，在这里我已经搞好了，来看看：<br>版本1，time.txt内容00:50<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line">    [*]update time to 00:50</span><br></pre></td></tr></table></figure><p></p><p>版本2，time.txt内容18:51<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line">    [*]update time to 18:51</span><br></pre></td></tr></table></figure><p></p><p>版本3，time.txt内容10:41<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 3f22a0639f8d79bd4e329442f181342465dbf0b6</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Tue Dec 18 10:42:29 2018 +0800</span><br><span class="line">    [+]add file time.txt</span><br></pre></td></tr></table></figure><p></p><p>现在的是版本1，我们把版本3检出试试。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 3f22a0639f8d -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>使用<code>checkout</code>+<code>commit id</code>+<code>-- filename</code>的组合，横跨版本2把历史版本3的<code>time.txt</code>搞出来了</li><li>查看状态,time.txt被改变了</li></ul><p>我们来把time.txt恢复到版本1，同样的方法，因为版本1是上一次提交我们可以省略掉版本号<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">00:50</span><br></pre></td></tr></table></figure><p></p><p>看到了吧！只要用<code>git checkout commit_id -- filename</code>的组合，想搞出哪个文件历史版本就搞出哪个。</p><p>到了这里，你可能会很懵比,<code>reset</code>和<code>checkout</code>命令真的好像啊！都可以用来做撤消</p><ul><li><code>checkout</code>语义上是把什么东西取出来，所以此命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</li><li><code>reset</code>语义上是重新设置，所以此命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</li></ul><p>还想不通可以给我发邮件：<a href="mailto:pzqu@qq.com" target="_blank" rel="noopener">pzqu@qq.com</a></p><h2 id="救命的后悔药"><a href="#救命的后悔药" class="headerlink" title="救命的后悔药"></a>救命的后悔药</h2><p>来到这里我已经很清楚的你的现况了，你的代码丢了现在一定非常的着急，不要慌，总是有办法找回他们的。但是前提是要保证你的项目根目录下.git文件夹是完整的，要是手动删除了里面的一些东西那就真完了。还要保证一点，你的代码以前是有过git追踪的，最少<code>add</code>过</p><h3 id="找回你丢失的历史记录"><a href="#找回你丢失的历史记录" class="headerlink" title="找回你丢失的历史记录"></a>找回你丢失的历史记录</h3><p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令，贴个图吧直观点：<br><img src="/git-start3/help1.png" alt="upload successful"></p><ul><li>有没有发现，<code>git reflog</code>里的全部都是和改变目录树有关的，比如<code>commit rebase reset merge</code>，也就是说一定要有改变目录树的操作才恢复的回来</li><li>像add这种操作就不能恢复了吗？那肯定不是，只是要用更麻烦点的方式来恢复</li><li><p><code>git log</code>是一样的，也可以看到所有分支的历史提交，不一样的是看不到已经被删除的 <code>commit</code> 记录和 <code>reset rebase merge</code> 的操作<br>我们可以看到<code>git reflog</code>前面的就是<code>commit id</code>，现在我们就可以用之前介绍过的方法来回滚版本了，<a href="#撤消当前commit">撤消当前commit</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 856a740</span><br><span class="line">HEAD is now at 856a740 [*]update time to 18:51</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff (HEAD -&gt; master)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 18:51</span><br><span class="line"> </span><br><span class="line">$ git reset --hard 35b66ed</span><br><span class="line">HEAD is now at 35b66ed [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit 35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 18:51</span><br></pre></td></tr></table></figure></li><li><p>根据<code>git reflog</code>返回的结果，用<code>git reset --hard commit_id</code>回退到<code>856a740</code>这个版本</p></li><li><code>git log -1</code>看近一行的日志，可以看到目前就在这了</li><li>再根据<code>git reflog</code>的结果，用<code>git reset --hard 35b66ed</code>跑到这次提交</li><li><code>git log -2</code>看到两次提交的日志，我们就这么再穿梭过来了，就是这么爽<br>但是我们如果只是想把此提交给找回来，恢复他，那还是不要用<code>reset</code>的方式，可以用<code>cherry-pick</code>或者<code>merge</code>来做合并</li></ul><h3 id="找回忘记提交的历史记录"><a href="#找回忘记提交的历史记录" class="headerlink" title="找回忘记提交的历史记录"></a>找回忘记提交的历史记录</h3><p>你之前没有commit过的文件，被删除掉了，或者被<code>reset --hard</code>的时候搞没了,这种情况可以说是相当的难搞了，所幸你以前做过<code>add</code>的操作把他放到过暂存区，那我们来试试找回来,先来创建一个灾难现场<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'my lose message'</span> &gt; lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git add lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git reset --hard 35b66ed8</span><br><span class="line">HEAD is now at 35b66ed [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">README.md      need_stash.txt share_file.txt time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>创建一个叫<code>lose_file.txt</code>的文件并写入内容<code>my lose message</code>，并把他加到暂存区</li><li>用<code>git reset --hard 35b66ed8</code>用丢弃一切修改的方式来使现在的工作区恢复到<code>35b66ed8</code>版本，因为还没提交所以也就是恢复到当前的（<code>head</code>）版本。</li><li>我们用<code>status</code>和<code>ls</code>再看，这个叫<code>lose_file.txt</code>的文件真的没了，完蛋了,第一反应用刚刚学到的命令<code>git reflow</code>会发现根本就不好使</li></ul><p>核心命令：<code>git fsck --lost-found</code>,他会通过一些神奇的方式把历史操作过的文件以某种算法算出来加到<code>.git/lost-found</code>文件夹里<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">dangling blob 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">dangling commit fdbb19cf4c5177003ea6610afd35cda117a41109</span><br><span class="line">dangling commit 8be46aa83f0fe90317b0c6b9c201ad994f8caeaf</span><br><span class="line">dangling blob 11400c1d56142615deba941a7577d18f830f4d85</span><br><span class="line">dangling tree 3bd4c055afedc51df0326def49cf85af15994323</span><br><span class="line">dangling commit 3d113a773771c09b7c3bf34b9e974a697e04210a</span><br><span class="line">dangling commit bfdc065df8adc44c8b69fa6826e75c5991e6cad0</span><br><span class="line">dangling tree c96ff73cb25b57ac49666a3e1e45e0abb8913296</span><br><span class="line">dangling blob d6d03143986adf15c806df227389947cf46bc6de</span><br><span class="line">dangling commit 7aa21bc382cdebe6371278d1af1041028b8a2b09</span><br></pre></td></tr></table></figure><p></p><p>这里涉及到git的一些低层的知识，我们可以看到这里有<code>blob、commit、tree</code>类型的数据，还有<code>tag</code>等类型的。他们是什么含义呢？</p><p><img src="/git-start3/losefile.png" alt="upload successful"></p><ul><li><code>blob</code>组件并不会对文件信息进行存储，而是对文件的内容进行记录</li><li><code>commit</code>组件在每次提交之后都会生成，当我们进行<code>commit</code>之后，首先会创建一个<code>commit</code>组件，之后把所有的文件信息创建一个<code>tree</code>组件,所以哪个<code>blob</code>代表什么文件都可以在<code>tree</code> 里找到<br>我们来看看怎么恢复刚刚不见了的<code>lose_file.txt</code>文件，在上面执行完<code>git fsck --lost-found</code>命令，返回的第一行<code>blob</code>我们看看他的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git show 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">my lose message</span><br><span class="line"></span><br><span class="line">git show 7f5965523d2b9e850b39eb46e8e0f7c5755f6719 &gt; lose_file.txt</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">README.md      lose_file.txt  need_stash.txt share_file.txt time.txt</span><br></pre></td></tr></table></figure><ul><li><p>看到没有，就是我们丢失的文件内容，这样就找回来了！<br>我们再来看看<code>commit tree</code>的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p fdbb19cf4c5177003ea6610afd35cda117a41109</span><br><span class="line">tree 673f696143eb74ac5e82a46ca61438b2b2d3bbf4</span><br><span class="line">parent e278392ccbf4361f27dc338c854c8a03daab8c49</span><br><span class="line">parent 7b54a8ae74be7192586568c6e36dc5a813ff47cf</span><br><span class="line">author pzqu &lt;pzqu@example.com&gt; 1544951197 +0800</span><br><span class="line">committer pzqu &lt;pzqu@example.com&gt; 1544951197 +0800</span><br><span class="line"></span><br><span class="line">Merge branch <span class="string">'master'</span> of github.com:pzqu/git_test</span><br><span class="line"></span><br><span class="line">$ git ls-tree 3bd4c055afedc51df0326def49cf85af15994323</span><br><span class="line">100644 blob c44be63b27a3ef835a0386a62ed168c91e680e87share_file.txt</span><br></pre></td></tr></table></figure></li><li><p>用<code>git cat-file -p</code>可以看到commit的内容，可以选择把这个commit合并到我们的分支里，还是<code>reset merge rebase cherry-pick</code>这些命令来合<code>commit</code></p></li><li><code>git ls-tree</code>列出tree下面的文件名和<code>id</code>的记录信息，然后就可以根据这些来恢复文件了</li></ul><p>后记：<br>如果你发现执行<code>git fsck --lost-found</code>的输出找不到你想要的，那么在执行完<code>git fsck --lost-found</code>后会出现一堆文件 在 .git/lost-found 文件夹里,我们不管他。可以用以下命令来输出近期修改的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$  find .git/objects -<span class="built_in">type</span> f | xargs ls -lt | sed 3q</span><br><span class="line">-r--r--r--  1 pzqu  staff    32 12 23 12:19 .git/objects/7f/5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">-r--r--r--  1 pzqu  staff    15 12 23 01:51 .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">-r--r--r--  1 pzqu  staff   162 12 23 00:51 .git/objects/35/b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">my lose message</span><br><span class="line"></span><br><span class="line">$ git cat-file -t b2484b5ab58c5cb6ecd92dacc09b41b78e9b0001</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p b2484b5ab58c5cb6ecd92dacc09b41b78e9b0001</span><br><span class="line">100644 blob f9894f4195f4854cfc3e3c55960200adebbc3ac5README.md</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391need_stash.txt</span><br><span class="line">100644 blob 83f50ec84c00f5935da8089bac192171cfda8621share_file.txt</span><br><span class="line">100644 blob f0664bd6a49e268d3db47c508b08d865bc25f7bbtime.txt</span><br></pre></td></tr></table></figure><ul><li>这里用<code>find .git/objects -type f | xargs ls -lt | sed 3q</code>返回了近3个修改的文件,想要更多就改<code>3q</code>这个数值，比如你想输出100个就用<code>100q</code></li><li><code>git cat-file -t 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</code> 就能看见文件类型 把最后一个/去掉 复制从objects/ 后面的所有东西放在-t后面</li><li><code>git cat-file -p id</code>就能看见文件内容，是不是很爽</li></ul><h1 id="漏提交"><a href="#漏提交" class="headerlink" title="漏提交"></a>漏提交</h1><p>有时候会碰到我们已经commit但是有修改忘记了提交，想把他们放在刚刚的<code>commit</code>里面，这种时候怎么做呢？<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --name-status --pretty=oneline -1</span><br><span class="line">35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD) [*]update time to 00:50</span><br><span class="line">M       time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   lose_file.txt</span><br><span class="line">new file:   test_amend.txt</span><br><span class="line">    </span><br><span class="line">$ git commit --amend --no-edit</span><br><span class="line">[master 31cc277] [*]update time to 00:50</span><br><span class="line"> Date: Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line"> 3 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 lose_file.txt</span><br><span class="line"> create mode 100644 test_amend.txt</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --name-status --pretty=oneline -1</span><br><span class="line">31cc2774f0668b5b7c049a404284b19e9b40dc5d (HEAD -&gt; master) [*]update time to 00:50</span><br><span class="line">A       lose_file.txt</span><br><span class="line">A       test_amend.txt</span><br><span class="line">M       time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>查看文件提交日志只有<code>time.txt</code></li><li>stage里还有新的修改在</li><li>使用<code>git commit --amend --no-edit</code>合并到上一个提交里，如果不加<code>--no-edit</code>参数的话，会提示你来修改commit提示信息(这个命令也可以用在重复编辑<code>commit message</code>)。</li><li>查看日志，合并提交成功！</li></ul><h1 id="tag标签"><a href="#tag标签" class="headerlink" title="tag标签"></a>tag标签</h1><h2 id="创建一个tag"><a href="#创建一个tag" class="headerlink" title="创建一个tag"></a>创建一个tag</h2><p>标签是一个类似于快照的东西，常常用于测试和发布版本。所以我们常常把<code>tag</code>名以版本号来命名，比如：v1.0beat1这样<br>我们怎么创建标签呢？首先先切换到想打标签的分支，然后直接打就可以了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev/pzqu</span><br><span class="line">  master</span><br><span class="line">* release_v1.0</span><br><span class="line"></span><br><span class="line">$ git tag -a release_v1.0 -m <span class="string">"release v1.0"</span></span><br><span class="line"></span><br><span class="line">$ git tag release_v1.1</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">release_v1.0</span><br><span class="line">release_v1.1</span><br><span class="line"></span><br><span class="line">$ git push --tags</span><br><span class="line">Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 158 bytes | 158.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new tag]         release_v1.0 -&gt; release_v1.0</span><br><span class="line"> * [new tag]         release_v1.1 -&gt; release_v1.1</span><br></pre></td></tr></table></figure><p></p><ul><li>切换到想打<code>tag</code>的分支</li><li>创建名为<code>release_v1.0</code>带有信息<code>release v1.0</code>的<code>tag</code></li><li>创建的不带有<code>tag</code>的提交信息的<code>release_v1.1</code></li><li><code>git tag</code>查看<code>tag</code></li><li>推送本地全部<code>tag</code></li></ul><p>也可以推送单个tag<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin release_v1.1</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new tag]         release_v1.1 -&gt; release_v1.1</span><br></pre></td></tr></table></figure><p></p><p>我们来删除tag<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d release_v1.0</span><br><span class="line">Deleted tag <span class="string">'release_v1.0'</span> (was eb5d177)</span><br><span class="line"></span><br><span class="line">$ git push origin :refs/tags/release_v1.0</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> - [deleted]         release_v1.0</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">release_v1.1</span><br></pre></td></tr></table></figure><p></p><ul><li>本地删除名为<code>release_v1.0</code>的<code>tag</code></li><li>远程删除名为<code>release_v1.0</code>的<code>tag</code></li></ul><h2 id="对历史提交打tag"><a href="#对历史提交打tag" class="headerlink" title="对历史提交打tag"></a>对历史提交打tag</h2><p>先看看当前的log<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">31cc277 (HEAD -&gt; release_v1.0, tag: release_v1.1, origin/release_v1.0, master) [*]update time to 00:50</span><br><span class="line">856a740 [*]update time to 18:51</span><br><span class="line">3f22a06 [+]add file time.txt</span><br><span class="line">4558a25 (origin/dev/pzqu, dev/pzqu) [*]test stash</span><br><span class="line">d9e018e [*]merge master to dev/pzqu</span><br></pre></td></tr></table></figure><p></p><p>比方说要对<code>[*]update time to 18:51</code>这次提交打标签，它对应的commit id是<code>856a740</code>，敲入命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v.9 856a740</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">31cc277 (HEAD -&gt; release_v1.0, tag: release_v1.1, origin/release_v1.0, master) [*]update time to 00:50</span><br><span class="line">856a740 (tag: v0.9) [*]update time to 18:51</span><br></pre></td></tr></table></figure><p></p><ul><li>成功打上</li></ul><h1 id="git忽略不想提交的文件"><a href="#git忽略不想提交的文件" class="headerlink" title="git忽略不想提交的文件"></a>git忽略不想提交的文件</h1><p>我们有两种情况，一种是我们根本就不想这些文件出现在git库里比如日志文件；另一种是git远程仓库里有这些文件，就像通用的配置文件，我们必须要在本地修改配置来适应运行环境，这种情况下我们不想每次提交的时候都去跟踪这些文件。</p><h2 id="忽略自动生成的垃圾文件、中间文件、敏感信息文件"><a href="#忽略自动生成的垃圾文件、中间文件、敏感信息文件" class="headerlink" title="忽略自动生成的垃圾文件、中间文件、敏感信息文件"></a>忽略自动生成的垃圾文件、中间文件、敏感信息文件</h2><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>我们要怎么做呢？</p><blockquote><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"*.log"</span> &gt; .gitignore</span><br><span class="line"></span><br><span class="line">$ touch test.log</span><br><span class="line"></span><br><span class="line">$ touch test2.log</span><br><span class="line"></span><br><span class="line">$ ls -a</span><br><span class="line">.              .git           README.md      need_stash.txt test.log       test_amend.txt</span><br><span class="line">..             .gitignore     lose_file.txt  share_file.txt test2.log      time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch release_v1.0</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p></p></blockquote><ul><li>创建并写入忽略规则<code>*.log</code>忽略全部以<code>.log</code>为后缀的文件</li><li>创建了<code>test.log</code>和<code>test2.log</code></li><li><code>status</code>查看，真是工作区是<code>clean</code>，新创建的文件没有被跟踪</li></ul><h2 id="忽略远程存在，本地不想与远程同步的文件"><a href="#忽略远程存在，本地不想与远程同步的文件" class="headerlink" title="忽略远程存在，本地不想与远程同步的文件"></a>忽略远程存在，本地不想与远程同步的文件</h2><h3 id="添加跟踪忽略"><a href="#添加跟踪忽略" class="headerlink" title="添加跟踪忽略"></a>添加跟踪忽略</h3><p>核心命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index —assume-unchanged 文件名</span><br></pre></td></tr></table></figure><p></p><p><img src="/git-start3/ignore1.png" alt="upload successful"></p><ul><li>创建<code>time.txt</code>文件并写入<code>10:41</code>,提交到远程仓库</li><li>使用命令<code>git update-index —assume-unchanged</code>加<code>time.txt</code>加到忽略名单里</li><li>修改<code>time.txt</code>的内容为<code>10:43</code></li><li><code>status</code>查看确实没有被跟踪<br>看远程仓库</li></ul><p><img src="/git-start3/ignore2.png" alt="upload successful"></p><h3 id="取消跟踪忽略"><a href="#取消跟踪忽略" class="headerlink" title="取消跟踪忽略"></a>取消跟踪忽略</h3><p>核心命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index —no-assume-unchanged 文件名</span><br></pre></td></tr></table></figure><p></p><p><img src="/git-start3/ignore3.png" alt="upload successful"></p><ul><li><code>pull</code>同步远程仓库，真的没有更新刚刚被添加跟踪忽略的文件</li><li><code>git update-index —no-assume-unchanged</code>取消跟踪忽略</li><li><code>status</code>查看，出现文件的跟踪</li></ul><h3 id="查看跟踪记录"><a href="#查看跟踪记录" class="headerlink" title="查看跟踪记录"></a>查看跟踪记录</h3><p>如果忘记了哪些文件被自己本地跟踪</p><p><img src="/git-start3/ignore4.png" alt="upload successful"></p><ul><li>使用命令<code>git update-index —assume-unchanged</code>加<code>time.txt</code>加到忽略名单里</li><li>使用<code>git ls-files -v| grep &#39;^h\ &#39;</code>命令可以看到小写h代表本地不跟踪的文件</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>学完本文章，你将学会</p><ul><li>撤消commit,回滚暂存区，回滚工作区、回退远程仓库</li><li>两种方法找回不小心丢失的文件</li><li>提交的时候漏了文件，修改commit的提交信息</li><li>tag操作，创建、创建有描述信息的tag、删除tag、删除远程tag、推送本地单个tag和全部tag</li><li>git忽略自动生成的垃圾文件、中间文件、敏感信息文件；忽略远程存在，本地不想与远程同步的文件并恢复跟踪和查看哪些文件被跟踪</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="下集"><a href="#下集" class="headerlink" title="下集"></a>下集</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><p><a href="https://www.cnblogs.com/hope-markup/p/6683522.html" target="_blank" rel="noopener">关于git reset –hard这个命令的惨痛教训</a></p><p><a href="https://www.cnblogs.com/Calvino/p/5930656.html" target="_blank" rel="noopener">Git 基础再学习之：git checkout – file</a></p><p><a href="https://www.cnblogs.com/instona/p/4243009.html" target="_blank" rel="noopener">如何理解git checkout – file和git reset HEAD – file</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：上一集我们一起入门学习了git的基本概念和git常用的操作，包括提交和同步代码、使用分支、出现代码冲突的解决办法、紧急保存现场和恢复现场的操作。学会以后已经足够我们使用Git参加协作开发了，但是在开发的过程中难免会出错，本文主要介绍版本控制的过程中出错了的场景，以及Git开发的一些技巧，让我们用的更流畅。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://qupzhi.com/categories/git/"/>
    
    
      <category term="工具" scheme="https://qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="版本控制" scheme="https://qupzhi.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git教程" scheme="https://qupzhi.com/tags/git%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>版本控制工具——Git常用操作（上）</title>
    <link href="https://qupzhi.com/git-start/"/>
    <id>https://qupzhi.com/git-start/</id>
    <published>2018-12-07T15:53:00.000Z</published>
    <updated>2018-12-22T08:13:02.782Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --><p>摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。</p><a id="more"></a><p>本文核心点：</p><ul><li>Git的基本概念</li><li>一个人使用Git时的代码版本控制–（提交、拉代码、分支操作）</li><li>多人合作时的代码版本控制–（合并冲突、暂存代码）</li></ul><h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>git是世界上目前最先进的分布式版本控制系统,致力于团队、个人进行项目版本管理，完美的解决难以比较代码、难以合并代码、难以取消修改、难以在写当前代码的过程中保存未完成的修改去修改线上版本的bug等的痛点。<br>git是一个非常强大的工具，但作为一个git使用者来说，不用完全学习Git的知识点与命令，因为有的命令的使用频率非常的低甚至数年都不会用到，让我们来由浅入深进行学习。</p><h2 id="git的历史"><a href="#git的历史" class="headerlink" title="git的历史"></a>git的历史</h2><p>git是linux的创始人linus，在付费版本控制工具BitMover收回对Linux社区免费使用权利的时候，一怒之下花费两个星期的时间写出来的。（牛笔的人）</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>选择自己的操作系统对应的git版本安装，安装成功后运行<code>git version</code>后，输出git版本则安装正确。<br>git 官方： <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>使用<code>git config</code>命令来配置用户名和邮箱<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "pzqu" </span><br><span class="line">git config --global user.email pzqu@example.com</span><br></pre></td></tr></table></figure><p></p><blockquote><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p></blockquote><p>使用<code>git config user.name</code>和<code>git config user.email</code>来检查是否成功，也可以直接用<code>git config --list</code>来列出全部git配置信息来查看</p><p><img src="/git-start/85838584.png" alt=""></p><h2 id="创建git托管的项目"><a href="#创建git托管的项目" class="headerlink" title="创建git托管的项目"></a>创建git托管的项目</h2><p>假如我们创建一个项目叫make_money，先创建一个文件夹叫make_money，再使用<code>git init</code>命令创建git项目。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:05:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:24]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">make_money</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money [0:07:10]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /Users/pzqu/Documents/code/test/make_money/.git/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money on git:master o [0:07:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -al</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:07 .</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:06 ..</span><br><span class="line">drwxr-xr-x  9 pzqu  staff  288 11  7 00:07 .git</span><br></pre></td></tr></table></figure><p></p><p>创建成功以后，会出现一个叫.git的隐藏文件夹，这个就是你的git仓库，以后所有的git操作历史提交记录信息就全部记录在此了，只要这个文件夹在就可以记住我们的全部git操作</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>在使用git的时候还要清楚暂存区和工作区的含义，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇-工作区和暂存区</a></p><h1 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h1><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><h3 id="新文件与修改"><a href="#新文件与修改" class="headerlink" title="新文件与修改"></a>新文件与修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:37:50]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:42:02]</span></span><br><span class="line">$ touch file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:15]</span></span><br><span class="line">$ git add file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:23]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   file1.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:56:38]</span></span><br><span class="line">$ git commit -m <span class="string">"[+]add new file1.txt"</span></span><br><span class="line">[master 66cc488] [+]add new file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>add 添加修改的内容到索引</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p><code>git add .</code> ：监控工作区的状态树，此命令会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p><p><code>git add -u</code>：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写）</p><p><code>git add -A</code> ：是上面两个功能的合集（git add –all的缩写）</p><p><img src="/git-start/pasted-0.png" alt="upload successful"></p><pre><code>git show 列出最近一次的提交</code></pre><blockquote><p>对于commit：像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:24]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:25]</span></span><br><span class="line">$ git rm file1.txt</span><br><span class="line">rm <span class="string">'file1.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:30]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:32]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">deleted:    file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:40] C:128</span></span><br><span class="line">$ git commit -m <span class="string">"[-]delete file1.txt"</span></span><br><span class="line">[master e278392] [-]delete file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>git rm 删除file1.txt文件</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p>tip1: 如果没有用git rm删除文件，在本地删除文件后，git add一下再提交可以达到同样的效果</p><p>tip2: 要是你加班太晚，头晕不小心删除了不想删除的文件怎么办？见<br><a href="/git-start3/#后悔药" target="view_window">版本控制工具——Git常用操作（下）-后悔药</a></p><h2 id="拉代码"><a href="#拉代码" class="headerlink" title="拉代码"></a>拉代码</h2><h3 id="方法一-pull"><a href="#方法一-pull" class="headerlink" title="方法一 pull"></a>方法一 pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [17:01:13]</span></span><br><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:pzqu/git_test</span><br><span class="line">   5fd4d8f..7b54a8a  master     -&gt; origin/master</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 share_file.txt</span><br></pre></td></tr></table></figure><p>上图命令：</p><ul><li>git pull</li></ul><p>查看本地仓库变化<code>git log</code></p><p><img src="/git-start/git_pull.png" alt="upload successful"></p><p>上图可以看到向远程仓库pull的时候，出现了两个新的commit，<code>commit 7b54a8ae74...</code>的提交信息为<code>Create share_file.txt</code>,另一个<code>commit fdbb19cf4c51770</code>的提交信息为<code>Merge branch &#39;master&#39; of github.com:pzqu/git_test</code>。事实上主线只有一个提交，为什么会出现这种情况? 是因为pull其实会做两个操作</p><ul><li>拉远程仓库代码到本地</li><li>自动与当前分支合并并生成一个合并成功的提交</li></ul><p>注意这里的第二个个步骤如果远程有人和你改了同一个文件就会出现一个冲突，这个时候git会提示你哪些文件有冲突，手动改了再提交一次就可以了。详情见<a href="#合并冲突">合并冲突</a></p><h3 id="方法二-fetch"><a href="#方法二-fetch" class="headerlink" title="方法二 fetch"></a>方法二 fetch</h3><p>我在远程修改了文件，向<code>share_file.txt</code>加了一行内容<code>tom modify</code>，此时拉代码。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:07:21]</span></span><br><span class="line">$ git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:08:43]</span></span><br><span class="line">$ git rebase origin/master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: [+]add new file1.txt</span><br><span class="line">Applying: [-]delete file1.txt</span><br></pre></td></tr></table></figure><p></p><p>上图所示有以下两个操作</p><ul><li>fetch 拉取远端代码到本地</li><li>rebase 把本地代码提交基于远端分支重新replay</li></ul><p>效果如下：</p><p><img src="/git-start/fetch_log.png" alt="upload successful"></p><p>上图是<code>git log</code>所输出的提交内容，刚刚pull的时候忘记把pull自动产生的merge提交到远程，rebase的时候把本地的提交放到了远程提交之后，看起来就是一条直线，比较优雅，也是推荐的方式。</p><p>同样的，如果产生了冲突，详情见<a href="#合并冲突">合并冲突</a></p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>分支是多人协同最经典的地方所在，我们来创建一个分支<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu origin/master</span><br><span class="line">Branch <span class="string">'dev/pzqu'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p></p><ul><li><code>git checkout -b 分支名 其他分支</code>,<code>-b</code>代表创建并切换到新建的分支，<code>分支名</code>代表新创建的分支叫什么名字，这里叫<code>dev/pzqu</code> ，<code>其他分支</code>代表基于哪一个分支来创建，这里基于远程的master分支<code>origin/master</code>，如果省略则代表基于当前分支</li><li><code>git branch</code>展示本地的分支情况，加<code>-a</code>参数可以展示全部的分支，包括远程分支</li><li><code>*</code>在分支前，指明了现在所在的分支是<code>dev/pzqu</code></li></ul><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu2</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu2'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  dev/pzqu</span><br><span class="line">* dev/pzqu2</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">$ git checkout dev/pzqu</span><br><span class="line">Switched to branch <span class="string">'dev/pzqu'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>基于当前分支创建了一个新的分支并自动切换过去<code>dev/pzqu2</code></li><li><code>git checkout 已存在的分支名</code>切换分支回到<code>dev/pzqu</code></li></ul><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br><span class="line">  </span><br><span class="line">$ git branch -D dev/pzqu2</span><br><span class="line">Deleted branch dev/pzqu2 (was 7c9be37).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>位于<code>dev/pzqu</code>，删除了<code>dev/pzqu2</code>分支</li></ul><h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><h3 id="合并同一个分支的冲突（常见）"><a href="#合并同一个分支的冲突（常见）" class="headerlink" title="合并同一个分支的冲突（常见）"></a>合并同一个分支的冲突（常见）</h3><p>为了产生一个冲突，我在另一个地方向远程仓库提交了代码，更改<code>share_file.txt</code>文件，加了一行内容<code>tom add for merge</code>，<br>本地修改同一个文件加了一行<code>pzqu add for merge</code>，并提交到本地，这样一来，本地和远程仓库的同一个文件就不一样了，一会拉代码一定会产生一个冲突。效果如下：</p><p><img src="/git-start/merge1.png" alt="upload successful"></p><ul><li>一般rebase或pull冲突的时候，都会出现提示，然后git status会出现上图图示</li><li>这个时候不可以进行任何分支切换和commit操作，按照他提示进行处理</li><li>git status提示哪个文件是都被修改的，both modified，然后使用编辑器修改该文件，解决冲突</li><li>解决完成后，git add 添加该冲突文件</li><li>git rebase –continue，并更新commit message，完成整个rebase流程<br>我们来看看这个冲突的文件：</li></ul><p><img src="/git-start/merge2.png" alt="upload successful"></p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><p><img src="/git-start/merge3.png" alt="upload successful"></p><p><code>git add</code>再<code>git rebase --continue</code>后完成rebase，效果如下，再<code>push</code>的远程仓库即可</p><p><img src="/git-start/merge4.png" alt="upload successful"></p><h3 id="合并不同分支的代码产生冲突"><a href="#合并不同分支的代码产生冲突" class="headerlink" title="合并不同分支的代码产生冲突"></a>合并不同分支的代码产生冲突</h3><p>关于怎么创建分支与切换分支见<a href="#创建分支和切换分支">创建分支和切换分支</a>,这里只讨论合并时产生的冲突的情况，我们已经基于<code>master</code>分支创建了一个<code>dev/pzqu</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支，加一行<code>master add for merge</code>并提交，文件内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>切换到<code>dev/pzqu</code>分支，向<code>share_file.txt</code>加入一行<code>dev/pzqu add for merge</code>并提交，现在<code>share_file.txt</code>内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>现在两个分支的同一个文件内容不一样了，现在我们在<code>dev/pzqu</code>分支上进行合并：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git merge master</span><br><span class="line">Auto-merging share_file.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> share_file.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:17:31] C:1</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">=======</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</span><br></pre></td></tr></table></figure><p></p><p>上图出现了一个冲突，是我们意料之中的，修改<code>share_file.txt</code>文件，解决此冲突：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line"></span><br><span class="line">$ git add share_file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:22:40]</span></span><br><span class="line">$ git commit -m <span class="string">"[*]merge master to dev/pzqu"</span></span><br><span class="line">[dev/pzqu d9e018e] [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu o [11:23:00]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p></p><p>冲突解决也提交了，看看我们现在的分支内容：</p><p><img src="/git-start/merge_branch_devpzqu.png" alt="upload successful"></p><p>上图我们可以看到：</p><ul><li><p><code>master</code>分支比远程<code>origin/master</code>分支多一次提交，<code>dev/pzqu</code>分支由于是基于<code>origin/master</code>分支，合并了<code>master</code>分支的提交和当前<code>dev/pzqu</code>分支的提交，超出本地<code>master</code>两个提交，致此我们把<code>master</code>合并到<code>dev/pzqu</code>的操作就完成了。</p></li><li><p>通常我们开一个新的开发分支是为了在自己的分支上写代码，方便提交也不会把主线弄乱，现在我们用同样的方法将<code>dev/pzqu</code>合并到<code>master</code>分支，然后把两个分支都提交到远程。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge dev/pzqu</span><br><span class="line">Updating 58f047a..d9e018e</span><br><span class="line">Fast-forward</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line">   7c9be37..d9e018e  master -&gt; master</span><br><span class="line">   </span><br><span class="line">$ git push origin dev/pzqu</span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 887 bytes | 887.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'dev/pzqu'</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/pzqu/git_test/pull/new/dev/pzqu</span><br><span class="line">remote:</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new branch]      dev/pzqu -&gt; dev/pzqu</span><br></pre></td></tr></table></figure><ul><li>切换到<code>master</code>分支</li><li>合并<code>dev/pzqu</code>到<code>master</code>分支</li><li><code>master</code>推到远程仓库</li><li>如果<code>dev/pzqu</code>要保留，就可以推送到远程仓库。</li></ul><p><img src="/git-start/merge_branch_statuslast.png" alt="upload successful"></p><ul><li>现在我们可以看到全部的分支都在一起了，强迫症都舒服了。</li></ul><h2 id="暂存代码保存现场"><a href="#暂存代码保存现场" class="headerlink" title="暂存代码保存现场"></a>暂存代码保存现场</h2><p>这种情况一般是出现在你正在完成一个功能，但是忽然线上发现了一个Bug，必须马上开一个新的分支来修复bug，但是现在的功能没写完不打算提交(commit)，现在怎么办？？不用怕暂存代码来帮助你。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line">modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//省略操作：去创建一个Bug分支，修复他并完成与主线的合并，删除Bug分支。</span><br><span class="line">//省略操作：切回来当前分支继续开发</span><br><span class="line">//下面来恢复现场</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   share_file.txt</span><br></pre></td></tr></table></figure><p></p><ul><li><code>status</code>查看到有2个文件修改没有提交</li><li><code>stash</code>把修改放到暂存区，并生成一个id</li><li><code>stash list</code>列出暂存区所有内容</li><li><code>stash apply</code>重新把暂存区内容放到本地</li></ul><p>这里的<code>stash apply</code>成功的把暂存区的一次暂存恢复到了本地，但是暂存区还有会保存这次暂存，如果想删除这次暂存要用<code>git stash drop</code>来删除；也可以用<code>git stash pop</code>，恢复最后一次暂存的同时把stash内容也删了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (bfdc065df8adc44c8b69fa6826e75c5991e6cad0)</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>好了，暂存区清干净了。</p><pre><code>注意：要放到暂存区的文件一定要先通过git add加到index</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文阅读结束以后，我们学会了</p><ul><li>Git的基本概念，知道git的作用、历史；学会安装配置Git，使用Git创建项目托管以及工作区和暂存区的概念</li><li>学会Git的本地操作，提交、拉代码、创建切换删除分支操作，</li><li>多人合作时的代码版本控制，学会了不同情况下的合并冲突、暂存代码操作</li></ul><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>Git常用操作（下）我计划给大家介绍以下点：</p><ul><li>后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）</li><li>哎呀，提交的时候漏了文件</li><li>tag操作</li><li>git忽略不想提交的文件</li></ul><p>下集传送门：<br><a href="/git-start3" target="view_window">版本控制工具——Git常用操作（下）</a></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 03 2019 13:04:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://qupzhi.com/categories/git/"/>
    
    
      <category term="工具" scheme="https://qupzhi.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="版本控制" scheme="https://qupzhi.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git教程" scheme="https://qupzhi.com/tags/git%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
