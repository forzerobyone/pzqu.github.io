<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql备份还原方案xtrabackup]]></title>
    <url>%2Fmysql-backup-xtrabackup%2F</url>
    <content type="text"><![CDATA[摘要：mysql当数据库过大的时候，使用mysqldump的方式进行备份是一种非常慢的操作，500G的数据就够你备份一天一夜，我发现了一种mysql快速备份的方案，它使用文件存储的方式进行备份，支持全量和增量备份，这里所写为全量方式（如果可以接受备份开始到下次恢复之间的数据丢失时使用）。xtrabackup的备份速度很快，不管有多少的数据，备份速度完全是依赖于磁盘的读写速度，还支持压缩、不打断正在执行的事务、自动实现备份检验（用mysqldump会锁表，要加上可重复读–single-transaction才不会影响线上的程序写表，但是写表后的东西在还原的时候就会丢了，这也是全量备份的痛点）特点准备mysql备份组件需要的安装包安装备份工具1. 上传并解压2. 安装rpm包3. 检查是否安装成功开始备份1. 执行命令开始备份2. 检查是否备份成功还原备份1. 事务日志应用到备份2. 恢复数据3. 设置属主属组为mysql并启动引用特点(1)备份过程快速、可靠(2)备份过程不会打断正在执行的事务(3)能够基于压缩等功能节约磁盘空间和流量(4)自动实现备份检验(5)还原速度快准备mysql备份组件需要的安装包检查服务器是centos6版本还是centos7+版本。选择安装包12centos6/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tarcentos7/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el7-x86_64-bundle.tar安装包可以在此下载 ： https://www.percona.com/downloads/XtraBackup/LATEST/安装备份工具以下所有操作如果是在集群下，要在一个主节点上操作，操作一次即可，启动时设置主节点为被同步节点，集群的管理我们以后再讨论。1. 上传并解压假设当前系统是centos6+,使用Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar包，拷贝到系统/tmp/backup_mariadb20181127目录下(没有则创建,日期写当天)，使用tar xvf Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar命令解压,你可以得到以下文件。1234567# pwd/tmp/backup_mariadb20181127# lsPercona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tarpercona-xtrabackup-24-2.4.12-1.el6.x86_64.rpmpercona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm2. 安装rpm包执行以下命令123rpm -ivh --force --nodeps percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm rpm -ivh --force --nodeps percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpmrpm -ivh --force --nodeps percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm3. 检查是否安装成功按以下显示则安装成功1234# rpm -qa | grep perconapercona-xtrabackup-test-24-2.4.12-1.el6.x86_64percona-xtrabackup-24-2.4.12-1.el6.x86_64percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64开始备份1. 执行命令开始备份执行以下命令开始备份，其中/etc/my.cnf为mysql配置文件位置，10.123.2.4为mysql绑定的ip（写当前机器的ip）,user1为用户名，123456Abc为密码，/tmp/backup_mariadb20181127为备份文件所在目录，所有按实际环境填写。此处我们只备份cloud库所以--databases库就不用改动了1innobackupex --defaults-file=/etc/my.cnf --host=10.123.2.4 --databases="cloud" --use-memory=500M --user=user1 --password=123456Abc /tmp/backup_mariadb20181127如果只需要备份其中一个或多个数据库，可以加参数--databases=&quot;cloud test&quot;,其中cloud和test是库名可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。2. 检查是否备份成功最后一行显示completed OK！ 则备份成功，在所执行的目录下（此处是/tmp/backup_mariadb20181127）会出现备份的文件1181127 11:56:48 completed OK!可以看到文件结构，我们此处自动生成的备份文件夹名为2018-11-27_11-52-48，是一个以时间命名的文件夹12345# ls2018-11-27_11-52-48 Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm# pwd/tmp/backup_mariadb20181127还原备份1. 事务日志应用到备份备份出的数据并不能直接使用，因为备份出的数据是不一致的，我们还需要将同时备份出的事务日志应用到备份中，才能得到一份完整、一致、可用的数据，xtrabackup称这一步操作为prepare，也就是还原数据前的”准备”工作。1innobackupex --apply-log 2018-11-27_11-52-48/在事务日志容量很大的情况下，可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。输出最后如下就为正确1181127 11:56:10 completed OK!2. 恢复数据方法一、此处使用该方法，适用于备份部分数据库的方法数据目录在/data/mariadb/data，我们备份的数据库为cloud库。进入mysql命令行mysql -A，删除cloud库drop database cloud;(如果无法进入命令行则到数据目录下直接干掉cloud文件夹，集群操作的话必须通过drop或者先停止集群，确定好主从模式)执行命令1234567cd /data/mariadb/datarm ib* -frm -f cloud/etc/init.d/mysqld stop #关闭数据库cd /tmp/backup_mariadb20181127/2018-11-27_11-52-48 #进入备份目录cp ib* /data/mariadb/datacp -R cloud /data/mariadb/data方法二、先停止数据库服务/etc/init.d/mysqld stop，且对应的数据目录(此处是/data/mariadb/data)为空,如果不为空，手动删除，一般此方法针对全量备份的方法。1innobackupex --datadir=/data/mariadb/data --copy-back /tmp/backup_mariadb20181127/2018-11-27_11-52-48–copy-back：对应的目录就是我们准备好的可用数据的目录。此处为/tmp/backup_mariadb20181127/2018-11-27_11-52-48–datadir：指定的目录就是还原后数据要存放的目录，如果my.cnf设置了datadir，可以省略–datadir，执行copyback时会读取my.cnf中的配置，datadir目录必须为空目录,如果不为空，手动删除。3. 设置属主属组为mysql并启动此时我们还不能启动mysql，因为我们是使用root用户拷贝的数据，所以数据目录中的数据文件的属主属组仍然为root，我们需要将这些文件的属主属组设置为mysql。1234cd /data/mariadb/datachown -R mysql.mysql *chown -R mysql.mysql /data/mariadb/binlog/etc/inid.d/mysqld start引用Xtrabackup 安装使用xtrabackup 原理]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>备份mysql数据库</tag>
        <tag>mysql教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq管理利器——rabbitmqadmin]]></title>
    <url>%2Frabbitmqadmin%2F</url>
    <content type="text"><![CDATA[摘要：在运维rabbitmq集群的过程中，发生了队列的严重堆积，我们在可以容忍mq消息丢失的情况下，使用常用的purge_queue queue命令等好长时间都清理不成功，在管理页面上直接purge导致页面卡住不动，最终都没有办法达到清理成功的效果。这个时候发现了一个python的rabbitmq管理工具，非常的好用且迅速，在此记录。如何获取rabbitmqadmin常用命令查看系统操作用户管理操作队列操作其他指定输出格式用户角色rabbitmqctl 命令参考如何获取rabbitmqadmin方法1. 直接复制出来1234567891011121314151617181920212223242526cp -a /var/lib/rabbitmq/mnesia/rabbit@localhost-plugins-expand/rabbitmq_management-3.3.5/priv/www/cli/rabbitmqadmin /usr/local/bin/rabbitmqadmin``` **方法2** 从管理页面获取1. 打开`rabbitmq_management`，访问15672管理页面，方法见&lt;a href="https://qupzhi.com/first-blog" target="_blank"&gt;rabbitmq集群的各种运维操作 4.2 打开15672网页管理端，访问mq &lt;/a&gt;2. 访问 ip:15672/rabbitmqadmin下载页面，另存为`rabbitmqadmin.py`,放到此目录：`/usr/local/bin/rabbitmqadmin`，授权`chmod +x /usr/local/bin/rabbitmqadmin`多一句废话：可以使用wget直接下载页面上的东西# 常用命令## 查看```bashrabbitmqadmin list users #查看用户列表rabbitmqadmin list vhosts #查看vhostsrabbitmqadmin list connections ###查看 connectionsrabbitmqadmin list exchanges ##查看 exchangesrabbitmqadmin list bindings ##查看 bindingsrabbitmqadmin list permissions ##查看 permissionsrabbitmqadmin list channels ##查看 channelsrabbitmqadmin list parameters ##查看 parametersrabbitmqadmin list consumers ##查看consumersrabbitmqadmin list queues ##查看queuesrabbitmqadmin list policies ##查看policiesrabbitmqadmin list nodes ##查看nodesrabbitmqadmin show overview ##查看overview系统操作用户管理操作新增一个用户12rabbitmqctl add_user Username Passwordrabbitmqadmin declare user name=wyl password=password tags=administrator删除一个用户1rabbitmqctl delete_user Username修改用户的密码1rabbitmqctl change_password Username Newpassword查看当前用户列表123rabbitmqctl list_usersrabbitmqadmin list users # 查看 usersrabbitmqadmin list users name # 查看 users的时候限制字段设置用户角色1rabbitmqctl set_user_tags User TagUser为用户名， Tag为角色名(对应于administrator，monitoring，policymaker，management，或其他自定义名称见用户角色)。也可以给同一用户设置多个角色，例如1rabbitmqctl set_user_tags hncscwc monitoring policymaker队列操作添加queue12rabbitmqadmin declare queue name=test durable=true ## durable=true 代表持久化打开 declare是宣布的意思rabbitmqadmin --vhost=test --username=admin --password=admin declare queue name=test durable=true #指定vhost添加队列查看queues123[root@rabbitmq1 sbin]# rabbitmqadmin list queues#查看bindings[root@rabbitmq1 sbin]# rabbitmqadmin list bindings添加消息到test queue1rabbitmqadmin publish routing_key=test payload="this is a testing" ##未指定exchange默认 exchange name为空再次查看对列发现test有一条消息1[root@rabbitmq1 sbin]# rabbitmqadmin list queues从test queue消费一条信息1rabbitmqadmin get queue=test requeue=true #requeue=true 这条消息消费后还在，反之如果为false消费后消息就不在了。删除队列1rabbitmqadmin delete queue name=test清除队列消息内容1rabbitmqadmin purge queue name=队列名其他指定输出格式使用 -f 可以指定格式有如下几种格式 raw_json, long, pretty_json, kvp, tsv, table, bash 默认为 table,具体自己试用户角色超级管理员(administrator)可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。监控者(monitoring)可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)策略制定者(policymaker)可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。与administrator的对比，administrator能看到这些内容普通管理者(management)仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。其他无法登陆管理控制台，通常就是普通的生产者和消费者。了解了这些后，就可以根据需要给不同的用户设置不同的角色，以便按需管理。rabbitmqctl 命令1234567891011121314151617181920212223242526272829303132333435rabbitmqctl list_queues：查看所有队列信息rabbitmqctl stop_app：关闭应用（关闭当前启动的节点）rabbitmqctl start_app：启动应用，和上述关闭命令配合使用，达到清空队列的目的rabbitmqctl reset：从管理数据库中移除所有数据，例如配置过的用户和虚拟宿主, 删除所有持久化的消息（这个命令要在rabbitmqctl stop_app之后使用）rabbitmqctl force_reset：作用和rabbitmqctl reset一样，区别是无条件重置节点，不管当前管理数据库状态以及集群的配置。如果数据库或者集群配置发生错误才使用这个最后的手段rabbitmqctl status：节点状态rabbitmqctl add_user username password：添加用户rabbitmqctl list_users：列出所有用户rabbitmqctl list_user_permissions username：列出用户权限rabbitmqctl change_password username newpassword：修改密码rabbitmqctl add_vhost vhostpath：创建虚拟主机rabbitmqctl list_vhosts：列出所有虚拟主机rabbitmqctl set_permissions -p vhostpath username ".*" ".*" ".*"：设置用户权限rabbitmqctl list_permissions -p vhostpath：列出虚拟主机上的所有权限 rabbitmqctl clear_permissions -p vhostpath username：清除用户权限rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息rabbitmqctl delete_user username：删除用户rabbitmqctl delete_vhost vhostpath：删除虚拟主机未完待续-催更 pzqu@qq.com参考通过rabbitmqadmin管理rabbitmq,【吴业亮】云计算开发工程师RabbitMQ学习笔记四：RabbitMQ命令（附疑难问题解决）]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>rabbitmq集群</tag>
        <tag>rabbitmq工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq集群恢复]]></title>
    <url>%2Frabbitmq-restart-save-data%2F</url>
    <content type="text"><![CDATA[摘要：在rabbitmq集群运行了一段时间的时候，rabbitmq出现了异常，发现集群中的某些节点死活都不能启动。这种情况往往是因为不是奇数个节点或者其他的问题导致的集群脑裂，集群中的节点没有办法确定主从关系。现在我们就来讨论在出现这种情况的时候，在不丢失数据的情况下，我们应该怎么通过人工的方式来进行恢复。rabbitmq配置检查在我们进行问题的处理之前，我们必须要先确定我们的mq配置是不是合规的，rabbitmq集群的各种运维操作引用RabbitMQ 集群配置RabbitMQ两种集群模式配置管理（五）未完待续-催更 pzqu@qq.com]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq集群</tag>
        <tag>rabbitmq教程</tag>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq之Federation配置]]></title>
    <url>%2Frabbitmq-federation%2F</url>
    <content type="text"><![CDATA[摘要：当我们有多个rabbitmq集群的时候，如果想要单向的同步集群的消息，也就是说把新集群当作老集群的镜像集群，实时的同步老集群的消息，在老集群消息被消费的时候不会影响同步到新集群的消息。在外部看上去就像每次写入消息的时候，同时向新老两个集群写入一样,不论mq的跨版本，不论mq的用户。一般我们会将这种情况应用于存在两个不同的系统，但是老数据来源只能向一个队列写入数据，此时为了在新系统上也可以实时同步到老系统队列中的数据的时候。Federation介绍特点松耦合性（Loose coupling）WAN 友好性（WAN-friendly）扩展性（Scalability）federation能做什么？配置的种类身份验证操作步骤说明1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/3. 创建upstream4. 创建policy5. 查看状态图6. 查看连接高级参考Federation介绍federation 插件的最终目标是，在不同 broker 之间进行消息传递而无需建立集群；该功能在很多场景下非常有用：注意:当你在一个cluster中使用federation插件，所有在集群中 的nodes都需要安装federation插件特点松耦合性（Loose coupling）federation 插件能够在分属不同管理域的 broker 或 cluster 之间传递消息：他们可能设置了不同的 user 和 vhost ；他们可能运行在不同版本的 RabbitMQ 和 Erlang 上；WAN 友好性（WAN-friendly）federation 插件基于 AMQP 0-9-1 协议在不同 broker 之间进行通信，并设计成能够容忍不稳定的网络连通情况；扩展性（Scalability）federation 不需要在 n 个 broker 之间建立 O(n^2) 个连接（尽管这是最简单的使用模式），这也就意味着 federation 在使用时更容易扩展federation能做什么？federation 插件允许你将多个 exchange 或多个 queue 进行 federate ；federated exchange 或 federated queue 能够从一个或多个 upstream 接收到消息；也就是说，你的队列可以和其他集群的队列建立一种关系，他们之间可以相互的同步数据，可以是我同步给你，也可以是你同步给我，不过这种关系有两个角色一个是上游一个是下游，数据流向是上游流向下流。这里有三个名词，federation 插件允许你将多个 exchange 或多个 queue 进行 federate：upstream： 上游，是指位于其他 broker 上的、远端 exchange 和 queue ；federated exchange： 到exchange的关系，能够将发给 upstream 的消息路由到本地的某个 queue 中；federated queue： 到queue的关系，则允许一个本地消费者接收到来自 upstream queue 的消息；配置的种类关于 federation upstream 的信息全都保存在 RabbitMQ 的数据库中，其中包括了 user 信息、permission 信息、queue 信息等等；在 federation 中存在 3 种界别的配置：Upstreams - 每一个 upstream 用于定义如何与另外的 broker 建立连接；Upstream sets - 每一个 upstream set 用于针对一系列使用 federation 功能 upstream 进行了分组；Policies - 每一种 policy 会限定（过滤）出一组 exchange ，或者一组 queue ，或者同时针对两者进行限定；policy 最终将作用于一个单独的 upstream 上，或者一个 upstream set 上，并对其他对象发挥作用；实际上，在最简单的使用情况下，你可以忽略已经存在的upstream设置，因为有一个隐含的默认upstream叫做“all”，他会添加所有的upstream。身份验证我们讨论的是免身份验证的方式，如果有身份难的需求请参考官网：http://www.rabbitmq.com/authentication.html操作步骤说明parameter 和 policy 可以通过 3 种方式进行设置：通过 rabbitmqctl 脚本；通过 management 插件提供的 HTTP API ；通过 rabbitmq_federation_management 插件提供的 Web UI（更通用的方式,我们也是通过页面来配置就可以了）；注意：基于 Web UI 的方式不能提供全部功能，尤其无法针对 upstream set 进行管理；1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)参考命令：12rabbitmq-plugins enable rabbitmq_federationrabbitmq-plugins enable rabbitmq_federation_management2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/3. 创建upstreamtips:在下游，也就是新队列（被同步队列）上操作12UI操作:Admin-&gt;Federation Upstreams-&gt;Add a new upstream Name:随意填写 URI:填被同步集群(例如:amqp://user1:xxx@x.x.x.x,xxx为连接密码) Expires:默认填写3600000 单位ms其余字段可不用填写Expires：是代表缓存时间，如果说网络连通性不好的时候，消息会在上游的队列中缓存的时间，超时丢弃，设置为空则表示，永远缓存不会丢弃数据（但是如果长时候不恢复内存会占用越来越大，建议设置上）Acknowledgement Mode: 代表消息确认方式，用来防止消息在传输过程中丢失，有三个值，on-confirm、on-publish、no-ack，对传输速度的影响是从慢速到快速，对安全性是不会丢失到可能会丢失。通常使用on-publish，不然on-confirm太慢了。4. 创建policytips:在下游，也就是新队列（被同步队列）上操作1234UI操作:Admin-&gt;Policies-&gt;Add / update a policyName:随意填写(sync_data)Pattern:匹配表达式(例如:^(?!amq.).* 剔除系统队列后的所有队列)Apply to: 默认选择Exchange and queues Definition:federation-upstream-set = all (选定federation规则)5. 查看状态图现在，所有内置的 exchange 都应该建立了 federation ，因为他们都能匹配上面的 policy，可以通过页面查看状态12UI操作:Admin &gt; Federation Status &gt; Running Links 查看针对每个 exchange 的 federation 连接。配置成功可以看到匹配的Exchange / Queue， state:running也可以通过下面的命令查看状态图：1rabbitmqctl eval 'rabbit_federation_status:status().'也可以通过 management 插件中的 exchange 列表，或者下面的命令输出，确认上述 policy 已经作用到了 exchange 上；1rabbitmqctl list_exchanges name policy | grep federate-me通常情况下，针对每个 upstream 都会有一条 federation 连接，该 federation 连接对应到一个 exchange 上；例如 3 个 exchange 与 2 个 upstream 分别建立 federation 的情况下，会有 6 条连接。6. 查看连接登录到被同步集群（上游）的管理界面::http://x.x.x.:15672/#/ 前往 Connections选项 配置成功可以看到来自同步集群的连接 高级更复杂的配置：https://www.rabbitmq.com/federation-reference.html参考官网]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq集群</tag>
        <tag>rabbitmq教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制工具——Git快速入门]]></title>
    <url>%2Fgit-start%2F</url>
    <content type="text"><![CDATA[摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。什么是Git简介git的历史开始安装git配置用户信息创建git托管的项目git的常用命令引用什么是Git简介git是世界上目前最先进的分布式版本控制系统,致力于团队、个人进行项目版本管理，完美的解决难以比较代码、难以合并代码、难以取消修改、难以在写当前代码的过程中保存未完成的修改去修改线上版本的bug等的痛点。git是一个非常强大的工具，但作为一个git使用者来说，不用完全学习Git的知识点与命令，因为有的命令的使用频率非常的低甚至数年都不会用到，让我们来由浅入深进行学习。git的历史git是linux的创始人linus，在付费版本控制工具BitMover收回对Linux社区免费使用权利的时候，一怒之下花费两个星期的时间写出来的。（所以永远不要逼一个牛人，这种牛笔难以想象）开始安装git选择自己的操作系统对应的git版本安装，安装成功后运行git version后，输出git版本则安装正确。git 官方： https://git-scm.com/downloads配置用户信息使用git config命令来配置用户名和邮箱12git config --global user.name "pzqu" git config --global user.email pzqu@example.com如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。使用git config user.name和git config user.email来检查是否成功，也可以直接用git config --list来列出全部git配置信息来查看创建git托管的项目假如我们创建一个项目叫make_money，先创建一个文件夹叫make_money，再使用git init命令创建git项目。1234567891011121314151617181920# pzqu @ pzqu-pc in ~/Documents/code/test [0:05:29]$ mkdir make_money# pzqu @ pzqu-pc in ~/Documents/code/test [0:06:24]$ lsmake_money# pzqu @ pzqu-pc in ~/Documents/code/test [0:06:29]$ cd make_money# pzqu @ pzqu-pc in ~/Documents/code/test/make_money [0:07:10]$ git initInitialized empty Git repository in /Users/pzqu/Documents/code/test/make_money/.git/# pzqu @ pzqu-pc in ~/Documents/code/test/make_money on git:master o [0:07:12]$ ls -altotal 0drwxr-xr-x 3 pzqu staff 96 11 7 00:07 .drwxr-xr-x 3 pzqu staff 96 11 7 00:06 ..drwxr-xr-x 9 pzqu staff 288 11 7 00:07 .git创建成功以后，会出现一个叫.git的隐藏文件夹，这个就是你的git仓库，以后所有的git操作历史提交记录信息就全部记录在此了，只要这个文件夹在就可以记住我们的全部git操作git的常用命令以下的命令几乎覆盖了所有的git常用操作，在使用git的时候还要清楚暂存区和工作区的含义，参考廖雪峰的官方网站-git篇-工作区和暂存区1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283git init # 初始化本地git仓库（创建新仓库）git config --global user.name "xxx" # 配置用户名git config --global user.email "xxx@xxx.com" # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库git status # 查看当前版本状态（是否修改）git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至indexgit commit -m 'xxx' # 提交git commit --amend -m 'xxx' # 合并上一次提交（用于反复修改）git commit -am 'xxx' # 将add和commit合为一步git rm xxx # 删除index中的文件git rm -r * # 递归删除git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log -5git log --stat # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag # 显示已存在的taggit tag -a v2.0 -m 'xxx' # 增加v2.0的taggit show v2.0 # 显示v2.0的日志及详细内容git log v2.0 # 显示v2.0的日志git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0 # 检出版本v2.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退）git merge origin/master # 合并远程master分支至当前分支git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有tag推送到远程仓库git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master # 获取远程分支master并merge到当前分支git mv README README2 # 重命名文件README为README2git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933git ls-files # 列出git index包含的文件git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史git whatchanged # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD # 内部命令：显示某个git对象git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASHgit reflog # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git log --pretty=format:'%h %s' --graph # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash # 暂存当前修改，将所有至为HEAD状态git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存git grep "delete from"引用git管网廖雪峰的官方网站-git篇hexo博客部署到vps]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>版本控制</tag>
        <tag>git教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible_roles]]></title>
    <url>%2Fansible-roles%2F</url>
    <content type="text"><![CDATA[摘要：本节主要总结ansiblerroles中常用的语法以及高级特性、例如变量、下载、解压、修改文件内容等,便于使用ansible协同开发，做更加庞大的任务。常用远程执行脚本设置某个参数供下文使用文件是否存在和变量是否声明解压下载修改文件内容，直接替换方式配置文件执行命令时指定脚本执行目录高级委托统一目录结构引用常用远程执行脚本脚本放到template里12345678910- name: init rbac rights template: src: 'init_rbac_privilege.sh' dest: '/tmp/init_rbac_privilege.sh' mode: 0755- name: init rbac rights shell: "bash /tmp/init_rbac_privilege.sh" run_once: true ignore_errors: yes脚本放files文件里12345678- name: copy script file to remote server copy: src: "generate_uuid.py" dest: "&#123;&#123; dest_script_file &#125;&#125;" mode: 0755- name: set to execute script file and args shell: "python &#123;&#123; dest_script_file &#125;&#125;"设置某个参数供下文使用123456789- name: set to execute script file path set_fact: dest_script_file: '/tmp/generate_uuid.py'- name: copy script file to remote server copy: src: "generate_uuid.py" dest: "&#123;&#123; dest_script_file &#125;&#125;" mode: 0755文件是否存在和变量是否声明12345678- stat: path: "&#123;&#123; dest_script_file &#125;&#125;" register: file_result- name: set to execute script file and args shell: "python &#123;&#123; dest_script_file &#125;&#125; &#123;&#123; inventory_hostname &#125;&#125;" register: p_new_host_uuid when: host_uuid is not defined and file_result.stat.exists解压解压tar.gz，desc所指定的目录需要提前创建12345- name: Unarchive ceph_report program package unarchive: remote_src: yes src: "/tmp/ceph_report/ceph_report.tar.gz" dest: "/data/monitorcloud/script/"下载12345- name: download ceph_report package get_url: url: "http://&#123;&#123; tstack_repo_address &#125;&#125;:&#123;&#123; tstack_repo_port &#125;&#125;/tstack/tstack-tars/ceph_report.tar.gz" dest: "/tmp/ceph_report/ceph_report.tar.gz" mode: 0644修改文件内容，直接替换方式1234567891011- name: insert mons connect message lineinfile: path: "/data/monitorcloud/script/ceph_report/host_dic" state: present insertafter: EOF backrefs: no line: "&#123;&#123;item[0]&#125;&#125; &#123;&#123;item[1]&#125;&#125;" with_nested: - "&#123;&#123; groups['mons'] | union( groups['osds'] )&#125;&#125;" - ["&#123;&#123;ansible_ssh_pass&#125;&#125;"] ignore_errors: true配置文件ansible中指定配置文件，.j2中可映射ansible变量12345- name: Prepare ceph_report_http program configuration file template: src: "opts.py.j2" dest: "/data/monitorcloud/script/ceph_report/opts.py" mode: 0644执行命令时指定脚本执行目录12345- name: execute ceph_report_http install script shell: "/usr/bin/python ceph_report_http.py install" args: chdir: '/data/monitorcloud/script/ceph_report/' ignore_errors: yes高级委托在当前运行ansible的机器上，委托其他机器运行123- name: add host record to center server shell: 'echo "192.168.1.100 test.xyz.com " &gt;&gt; /etc/hosts' delegate_to: 192.168.1.1也可以委托ansible服务端运行123- name: add host record to center server shell: 'echo hello' delegate_to: localhost统一目录结构1234567891011121314151617181920212223242526272829303132project/├── filter_plugins # 自定义 filter 插件存放目录├── fooapp # Fooapp 片色目录 ( 与 common 角色目录平级)├── group_vars │ ├── group1 # group1 自定义变量文件│ └── group2 # group2 自定义变量文件├── host_vars│ ├── hostname1 # hostname1 自定义变量文件│ └── hostname2 # hostname1 自定义变量文件├── library # 自定义模块存放目录├── monitoring # Monitoring 角色目录 ( 与 common 角色目录平级)├── roles # Role 存放目录│ └── common # common 角色目录│ ├── defaults │ │ └── main.yml # common 角色自定义文件 (优先级低)│ ├── files│ │ ├── bar.txt # common 角色 files 资源文件│ │ └── foo.sh # common 角色 files 资源文件│ ├── handlers│ │ └── main.yml # common 角色 handlers 入口文件│ ├── meta│ │ └── main.yml # common 角色 依赖文件│ ├── tasks│ │ └── main.yml # common 角色 task 入口文件│ ├── template│ │ └── ntp.conf.j2 # common 角色 template 文件│ └── vars│ └── main.yml # common 角色 变量定义文件├── site.yaml # Playbook 统一入口文件├── stage # stage 环境的 inventory 文件├── webservers.yml # 特殊 Playbook 文件└── webtier # webtier 角色目录 ( 与 common 角色目录平级)引用ansible进阶技巧 https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.htmlshilei ansible 文档 https://wiki.shileizcc.com/confluence/display/AN/Ansible骏马金龙 ansible系列文章 http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>自动化</tag>
        <tag>部署</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进入自动化部署的大门-ansible]]></title>
    <url>%2Fansible%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[摘要：ansible是运维与实施人员的福音，其优雅的结构，丰富的模块库，简单的编程方式都让其成为自动化部署的不二语言。现在就让我们了解ansible,并使用ansible来做一些简单的任务一、基本概念1.1 如何安装及安装要求1.2 专有名词解释1.3 原理图1.4 连接机制1.5 常用文件及配置位置二、简单的例子2.1 配置被管控机器的连接信息2.2 执行命令2.3 讨论执行命令的四个模块有什么区别三、 完成复杂的ansible操作引用资源一、基本概念Ansible是一款开源软件，可自动执行软件供应，配置管理和应用程序部署。Ansible通过SSH，远程PowerShell或其他远程API连接。—-选自wikipedia简介：ansible有两种服务器类型，控制机器与节点。控制机器就是安装ansible服务的机器，我们在上面编写和运行ansible的程序代码，并在控制机器上通过ssh远程操作机器（下发上传、执行命令）。当ansible脚本不运行的时候，不会占用任何资源（比如saltstack在运行的时候就会启动进程来监控4505/4506端口），也正由于ansible的这个特点，每次ansible发布更新的时候，只需要更新控制机器就可以了。1.1 如何安装及安装要求要求：控制机是linux系统，需要有python2.6/2.7linux系统打开文件数量设置大一些（方法自行百度）节点要求，python2.4以上版本安装方法（有很多，在此只列出常用的方法，具体安装步骤不做赘述）：源码安装 git://github.com/ansible/ansible.gityum 方式 / apt 方式 / emerge 方式 或其他linux系统的系统安装方式pip 方式1.2 专有名词解释关键字释义playbook剧本，将要执行的步骤全部放到playbook里面modules（通常指core modules）核心模块，用于执行某些任务的已有内置插件roles角色，像演戏一样，剧本中指定在什么时候哪个角色来做什么操作，所以剧本包含角色，角色就有自己的台词，不过ansible里面的角色特殊的地方是，剧本只知识角色是干什么的，具体操作步骤是在角色本身管理（无厘头）custom modules自定义模块，在核心模块不够用的时候可以自定义编写模块plugins插件，常用于ansible的日志系统与邮件系统，还有的插件有扩展内置连接方式、扩展变量定义方式、扩展内部循环语法、扩展新的过滤器等InventoryAnsible 管理主机的清单1.3 原理图1.4 连接机制ansible通常使用的是ssh协议（或者Kerberos、LDAP）来进行连接（在openssh不支持的操作系统或ansible比较老的版本，ansible使用paramiko），ansible支持的连接方式有三种SSH、Local、ZeroMQ，在规模比较大的情况下使用ZeroMQ连接方式对执行速度有显著提高1.5 常用文件及配置位置文件位置ansible应用程序的主配置文件/etc/ansible/ansible.cfg定义管控主机/etc/ansible/hosts二、简单的例子这里我们来实现在所有被管控机器上执行hostname命令输出主机名2.1 配置被管控机器的连接信息备注1：在/etc/ansible/hosts位置写入一个主机组（分组名为test），以后针对这个分组操作就视为对分组内的所有主机操作。备注2：[test:vars] 标签下为test分组的变量，ansible_ssh_user和ansible_ssh_pass是ansible的内置变量，意思为该分组下所有主机的用户和和密码，当前了也可以单独指定某台主机只需要将这两个参数追加到ip的旁边就好。这里三台主机都是同一个用户名和密码，所以像这样配置。备注3：默认路径是在/etc/ansible/hosts,如果你不喜欢是可以修改的(修改配置文件/etc/ansible/ansible.cfg的inventory=/etc/ansible/hosts即可)2.2 执行命令执行命令，输出test分组下的所有主机的主机名，-i指定主机或分组,-m指定使用的模块，-a指定传给模块的参数，这里command模块就是执行linux命令的模块缺省时默认使用该模块，相同作用的还有shell模块、raw模块、script模块（使用场景与部分细节上不同，后面探讨）2.3 讨论执行命令的四个模块有什么区别每次在使用的时候都会有一些迷惑，为什么非要弄四个执行命令的模块出来，一开始决定没有必要，但是到后来才明白存在既合理，这里和大家探讨一下模块解释command模块是为了安全的执行linux命令，所以不支持`”&lt;”, “&gt;”, ““, 和 “&amp;”`等符号（没有shell注入风险），如果要一定要使用这些，则使用shell模块shell模块通过/bin/sh来执行，其他都和command一样raw模块用来执行低版本的linux命令，可以不需要python来执行命令，甚至支持windows命令，带来的问题是很多很特性是不能用的script模块其原理是先将脚本，复制到远程主机，再在远程主机上执行，所以要指定脚本路径以及操作方法结论：要安全用command，要方便用shell，要操作写好的shell脚本或者其他脚本就用script、要是以上操作都跑不了的机器就用raw三、 完成复杂的ansible操作未完待续–引用Ansible插件扩展 https://blog.csdn.net/yongchaocsdn/article/details/79271870资源插件 https://github.com/ansible/ansible/tree/stable-2.4/lib/ansible/plugins]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>自动化</tag>
        <tag>部署</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置像我一样的hexo博客]]></title>
    <url>%2F%E9%85%8D%E7%BD%AE%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[摘要：csdn和博客园虽然用的人多、技术氛围好，但是由于csdn的广告和灌水以及博客园的简陋页面让我决定搭建一套属于自己的博客，此处用到比较火的hexo搭建，而且免费就能获得自己的网站，如果不买域名的话完全够用了一、搭建本地 hexo1.1 安装nodejs1.2 安装git1.3 使用npm安装Hexo1.4 创建本地服务1.5 主题配置二、 配置你的github2.1 创建一个新项目2.2 填写正确的项目名称2.3 配置你的项目三、激动人心的博客3.1 修改hexo配置文件3.2 部署成功四、个性化配置你的博客4.1 配置博客名，博客描述等信息4.2 添加头像4.3 添加日志列表4.2 其他五、配置你的hexo可以插入图片附：加速npm引用一、搭建本地 hexo1.1 安装nodejs到nodejs官网下载安装 http://nodejs.cn/1.2 安装git到git官网下载安装 https://git-scm.com/downloads1.3 使用npm安装Hexo1npm install -g hexo-cli备注： 如果npm下载比较慢可以跳到 附：加速npm1.4 创建本地服务创建一个文件夹，此处为blog，执行以下命令1234hexo i blog //init的缩写 blog是项目名cd blog //切换到站点根目录hexo g //generetor的缩写hexo s //server的缩写访问本地服务localhost:4000证明成功,为什么和我的不一样，因为我修改了hexo的主题配置可以跳到 四、个性化配置你的博客有页面出来证明你的配置已经成功了，原始的主题不是很喜欢，我这里也使用了最火的nexT主题1.5 主题配置在站点根目录输入1git clone https://github.com/iissnan/hexo-theme-next themes/next完成后，打开根目录下的_config.yml， 找到 theme 字段，并将其值更改为 nextnext有三种主题，我选择的是双栏 Scheme，找到 站点根目录/themes/next/_congig.yml 文件，再找到schme字段，将其值改为Pisces,其他两种可以参考引用里所写的使配置生效123hexo clean //清除缓存hexo g //重新生成代码hexo s //部署到本地这样你的会有一套和我一样主题的博客了，如果你不喜欢这套主题，或者想自己来开发一套定制自己的主题参考官方文档,下面让我们把他推到github上，变成独一无二的网站二、 配置你的github2.1 创建一个新项目如果没有注册github帐号到&gt;官网注册点此创建项目（如果你不是程序员建议勾选上图中Initalize this repository with a README选项）：2.2 填写正确的项目名称项目名可以为任意英文.github.io，public设置为公开项目,点击绿色创建按钮2.3 配置你的项目在项目里创建一个readme.md即可，这下可以在页面上访问到这个免费的网站了我的网站 https://pzqu.github.io/三、激动人心的博客3.1 修改hexo配置文件修改根目录的配置文件_config.yml，以下部分如果没有需要手动创建，建议直接拷贝我的，repo为自己刚刚创建的那个项目的git链接（注意冒号与值之间必须有空格）1234deploy: type: git repo: https://github.com/pzqu/pzqu.github.io.git branch: master3.2 部署成功直接执行一套命令,再刷新刚刚的域名即可12npm install hexo-deployer-git --savehexo d // 部署的命令,会生成代码并推送到github上去四、个性化配置你的博客4.1 配置博客名，博客描述等信息参考官方网站 https://hexo.io/zh-cn/docs/configuration.html4.2 添加头像在主题配置文件里修改avatar: images/avatar.gif4.3 添加日志列表4.2 其他添加顶部加载条,修改主题配置文件，pace_theme有好几款，自己选一款12pace: truepace_theme: pace-theme-flash添加打赏功能，修改主题配置文件，图片可以上传到themes\next\source\images123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wxpay.jpgalipay: /images/alipay.jpg文章阅读量参考 https://www.jianshu.com/p/702a7aec4d00评论系统http://www.zhaojun.im/hexo-valine/删除底部强力驱动、统计站点网上自己查添加分享添加评论五、配置你的hexo可以插入图片把主页配置文件 _config.yml 里的post_asset_folder:这个选项设置为true在你的hexo目录下执行npm install hexo-asset-image --save等待一小段时间后，再运行hexo n &quot;配置像我一样的hexo博客&quot;来生成md博文时，/source/_posts文件夹内除了配置像我一样的hexo博客.md文件还有一个同名的文件夹最后在配置像我一样的hexo博客.md中想引入图片时，先把图片复制到配置像我一样的hexo博客这个文件夹中，然后只需要在配置像我一样的hexo博客.md中按照markdown的格式引入图片,注意使用相对路径：![你想输入的替代文字](配置像我一样的hexo博客/图片名.jpg)附：加速npm配置npm镜像npm config set registry https://registry.npm.taobao.org查看npm镜像npm config get registry引用用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！npm太慢， 淘宝npm镜像使用方法]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>建站教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq集群的各种运维操作]]></title>
    <url>%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[摘要：在rabbitmq集群操作或者搭建的时候，常常会因为对于集群的不熟练而导致各种异常错误，常见的有绑定了浮动ip没有绑定实体ip导致，页面上操作mq完全没有问题，但是一到程序操作就出现问题，我们一起来学习下，rabbitmq集群的正确操作一、rabbitmq集群必要条件1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法1.2. 配置域名映射到实体ip二、启动停止2.1 停止2.2 启动三、重建集群3.1 使用2.1方法停止所有机器3.2 移除rabbitmq配置记录与存储文件3.3 按2.2方法启动所有机器3.4 停止被加入集群节点app3.5 建立集群3.6 启动集群3.7 检查集群状态3.8 添加集群配置 （见第四）四 添加集群配置4.1 创建用户4.2 打开15672网页管理端，访问mq4.3 在底部导入.json后缀的配置文件即可以下操作都以三节点集群为例，机器名标记为机器A、机器B、机器C，如果为双节点忽略机器C，如果为各多节点则与机器C操作相同一、rabbitmq集群必要条件1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法12#编辑配置路径 /etc/rabbitmq/rabbitmq-env.confNODE_IP_ADDRESS=172.16.136.1331.2. 配置域名映射到实体ip123456789101112131415161718192021#配置文件1所在路径 /etc/rabbitmq/rabbitmq.config (如果是集群，每台机器都需要修改这个绑定本机实体ip)#其中rabbit@master是创建集群时所配置的参数，@后面的参数为主机名，示例中为master[ &#123;rabbit, [ &#123;cluster_nodes, &#123;[&apos;rabbit@master&apos;], disc&#125;&#125;, &#123;cluster_partition_handling, ignore&#125;, &#123;default_user, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;, &#123;default_pass, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;, &#123;tcp_listen_options, [binary, &#123;packet, raw&#125;, &#123;reuseaddr, true&#125;, &#123;backlog, 128&#125;, &#123;nodelay, true&#125;, &#123;exit_on_close, false&#125;, &#123;keepalive, true&#125;]&#125; ]&#125;, &#123;kernel, [ &#123;inet_dist_listen_max, 44001&#125;, &#123;inet_dist_listen_min, 44001&#125; ]&#125;].1234#配置文件2 所在路径 /etc/hosts (如果是集群，每台机器都需要修改这个绑定本机实体ip，而且hosts文件的映射不得重复，如果重复linux系统为以最下面一条记录为准)172.16.136.133 master172.16.136.134 venus172.16.136.135 venus2二、启动停止2.1 停止123456789#机器Aservice rabbitmq-server stopepmd -kill#机器Bservice rabbitmq-server stopepmd -kill#机器Cservice rabbitmq-server stopepmd -kill2.2 启动123456#机器Aservice rabbitmq-server start#机器Bservice rabbitmq-server start#机器Cservice rabbitmq-server start三、重建集群注1：此处的mq集群重建是比较快速和有效的方法，面向的是初次安装或者可以接受mq中所存有的数据丢失的情况下，必须先有mq的.json后缀的配置文件或者有把握写入集群中exchange、queue等配置。注2:如果是运行中的mq出现问题，需要在保存数据和配置的情况下恢复集群时，请跳到rabbitmq集群恢复3.1 使用2.1方法停止所有机器3.2 移除rabbitmq配置记录与存储文件12#位于 /var/lib/rabbitmq/mensiamv /var/lib/rabbitmq/mensia /var/lib/rabbitmq/mensia.bak3.3 按2.2方法启动所有机器3.4 停止被加入集群节点app比如A、B、C三台机器，将B和C加入到A中去，需要执行以下命令1234#机器Brabbitmqctl stop_app#机器Crabbitmqctl stop_app3.5 建立集群注意此处master为唯一没有执行rabbitmqctl stop_app的机器1234#机器Brabbitmqctl join_cluster rabbit@master#机器Crabbitmqctl join_cluster rabbit@master3.6 启动集群1234#机器Brabbitmqctl start_app#机器Crabbitmqctl start_app3.7 检查集群状态在任意一台机器上执行rabbitmqctl cluster_status命令即可检查，输出包含集群中的节点与运行中的节点，兼以主机名标志3.8 添加集群配置 （见第四）四 添加集群配置4.1 创建用户例子中创建了两个用户添加用户add_user,设置角色set_user_tags,添加rabbitmq虚拟主机add_vhost，设置访问权限set_permissions,以下是详细用法123456789# 创建第一个用户/usr/sbin/rabbitmqctl add_user 用户名 密码/usr/sbin/rabbitmqctl set_user_tags 用户名 administrator/usr/sbin/rabbitmqctl set_permissions -p / 用户名 ".*" ".*" ".*"# 创建第二个用户/usr/sbin/rabbitmqctl add_user 用户名2 密码/usr/sbin/rabbitmqctl set_user_tags 用户名2 management /usr/sbin/rabbitmqctl add_vhost sip_ext /usr/sbin/rabbitmqctl set_permissions -p sip_ext 用户名2 '.*' '.*' '.*'备注：RabbitMQ 虚拟主机，RabbitMQ 通过虚拟主机（vhost）来分发消息。拥有自己独立的权限控制，不同的vhost之间是隔离的，单独的。 权限控制的基本单位：vhost。 用户只能访问与之绑定的vhost。 vhost是AMQP中唯一无法通过协议来创建的基元。只能通过rabbitmqctl工具来创建。 4.2 打开15672网页管理端，访问mq/usr/sbin/rabbitmq-plugins enable rabbitmq_management备注：如果发现命令执行完毕没有打开此服务，15672端口没有监听，则是由于没有重启mq导致的4.3 在底部导入.json后缀的配置文件即可如果覆盖了用户需要使用以下命令修改mq用户密码/usr/sbin/rabbitmqctl change_password 用户名 密码]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq集群</tag>
        <tag>rabbitmq教程</tag>
      </tags>
  </entry>
</search>
