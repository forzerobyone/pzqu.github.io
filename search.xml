<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>版本控制工具——Git常用操作（上）</title>
      <link href="/git-start/"/>
      <url>/git-start/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。</p><a id="more"></a><p>本文核心点：</p><ul><li>Git的基本概念</li><li>一个人使用Git时的代码版本控制–（提交、拉代码、分支操作）</li><li>多人合作时的代码版本控制–（合并冲突、暂存代码）</li></ul><h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>git是世界上目前最先进的分布式版本控制系统,致力于团队、个人进行项目版本管理，完美的解决难以比较代码、难以合并代码、难以取消修改、难以在写当前代码的过程中保存未完成的修改去修改线上版本的bug等的痛点。<br>git是一个非常强大的工具，但作为一个git使用者来说，不用完全学习Git的知识点与命令，因为有的命令的使用频率非常的低甚至数年都不会用到，让我们来由浅入深进行学习。</p><h2 id="git的历史"><a href="#git的历史" class="headerlink" title="git的历史"></a>git的历史</h2><p>git是linux的创始人linus，在付费版本控制工具BitMover收回对Linux社区免费使用权利的时候，一怒之下花费两个星期的时间写出来的。（牛笔的人）</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>选择自己的操作系统对应的git版本安装，安装成功后运行<code>git version</code>后，输出git版本则安装正确。<br>git 官方： <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>使用<code>git config</code>命令来配置用户名和邮箱<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "pzqu" </span><br><span class="line">git config --global user.email pzqu@example.com</span><br></pre></td></tr></table></figure><p></p><blockquote><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p></blockquote><p>使用<code>git config user.name</code>和<code>git config user.email</code>来检查是否成功，也可以直接用<code>git config --list</code>来列出全部git配置信息来查看</p><p><img src="/git-start/85838584.png" alt=""></p><h2 id="创建git托管的项目"><a href="#创建git托管的项目" class="headerlink" title="创建git托管的项目"></a>创建git托管的项目</h2><p>假如我们创建一个项目叫make_money，先创建一个文件夹叫make_money，再使用<code>git init</code>命令创建git项目。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:05:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:24]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">make_money</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money [0:07:10]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /Users/pzqu/Documents/code/test/make_money/.git/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money on git:master o [0:07:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -al</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:07 .</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:06 ..</span><br><span class="line">drwxr-xr-x  9 pzqu  staff  288 11  7 00:07 .git</span><br></pre></td></tr></table></figure><p></p><p>创建成功以后，会出现一个叫.git的隐藏文件夹，这个就是你的git仓库，以后所有的git操作历史提交记录信息就全部记录在此了，只要这个文件夹在就可以记住我们的全部git操作</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>在使用git的时候还要清楚暂存区和工作区的含义，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇-工作区和暂存区</a></p><h1 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h1><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><h3 id="新文件与修改"><a href="#新文件与修改" class="headerlink" title="新文件与修改"></a>新文件与修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:37:50]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:42:02]</span></span><br><span class="line">$ touch file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:15]</span></span><br><span class="line">$ git add file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:23]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   file1.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:56:38]</span></span><br><span class="line">$ git commit -m <span class="string">"[+]add new file1.txt"</span></span><br><span class="line">[master 66cc488] [+]add new file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>add 添加修改的内容到索引</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p><code>git add .</code> ：监控工作区的状态树，此命令会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p><p><code>git add -u</code>：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写）</p><p><code>git add -A</code> ：是上面两个功能的合集（git add –all的缩写）</p><p><img src="/git-start/pasted-0.png" alt="upload successful"></p><pre><code>git show 列出最近一次的提交</code></pre><blockquote><p>对于commit：像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:24]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:25]</span></span><br><span class="line">$ git rm file1.txt</span><br><span class="line">rm <span class="string">'file1.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:30]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:32]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">deleted:    file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:40] C:128</span></span><br><span class="line">$ git commit -m <span class="string">"[-]delete file1.txt"</span></span><br><span class="line">[master e278392] [-]delete file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>git rm 删除file1.txt文件</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p>tip1: 如果没有用git rm删除文件，在本地删除文件后，git add一下再提交可以达到同样的效果</p><p>tip2: 要是你加班太晚，头晕不小心删除了不想删除的文件怎么办？见<br><a href="/git-start3/#后悔药" target="view_window">版本控制工具——Git常用操作（下）-后悔药</a></p><h2 id="拉代码"><a href="#拉代码" class="headerlink" title="拉代码"></a>拉代码</h2><h3 id="方法一-pull"><a href="#方法一-pull" class="headerlink" title="方法一 pull"></a>方法一 pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [17:01:13]</span></span><br><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:pzqu/git_test</span><br><span class="line">   5fd4d8f..7b54a8a  master     -&gt; origin/master</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 share_file.txt</span><br></pre></td></tr></table></figure><p>上图命令：</p><ul><li>git pull</li></ul><p>查看本地仓库变化<code>git log</code></p><p><img src="/git-start/git_pull.png" alt="upload successful"></p><p>上图可以看到向远程仓库pull的时候，出现了两个新的commit，<code>commit 7b54a8ae74...</code>的提交信息为<code>Create share_file.txt</code>,另一个<code>commit fdbb19cf4c51770</code>的提交信息为<code>Merge branch &#39;master&#39; of github.com:pzqu/git_test</code>。事实上主线只有一个提交，为什么会出现这种情况? 是因为pull其实会做两个操作</p><ul><li>拉远程仓库代码到本地</li><li>自动与当前分支合并并生成一个合并成功的提交</li></ul><p>注意这里的第二个个步骤如果远程有人和你改了同一个文件就会出现一个冲突，这个时候git会提示你哪些文件有冲突，手动改了再提交一次就可以了。详情见<a href="#合并冲突">合并冲突</a></p><h3 id="方法二-fetch"><a href="#方法二-fetch" class="headerlink" title="方法二 fetch"></a>方法二 fetch</h3><p>我在远程修改了文件，向<code>share_file.txt</code>加了一行内容<code>tom modify</code>，此时拉代码。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:07:21]</span></span><br><span class="line">$ git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:08:43]</span></span><br><span class="line">$ git rebase origin/master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: [+]add new file1.txt</span><br><span class="line">Applying: [-]delete file1.txt</span><br></pre></td></tr></table></figure><p></p><p>上图所示有以下两个操作</p><ul><li>fetch 拉取远端代码到本地</li><li>rebase 把本地代码提交基于远端分支重新replay</li></ul><p>效果如下：</p><p><img src="/git-start/fetch_log.png" alt="upload successful"></p><p>上图是<code>git log</code>所输出的提交内容，刚刚pull的时候忘记把pull自动产生的merge提交到远程，rebase的时候把本地的提交放到了远程提交之后，看起来就是一条直线，比较优雅，也是推荐的方式。</p><p>同样的，如果产生了冲突，详情见<a href="#合并冲突">合并冲突</a></p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>分支是多人协同最经典的地方所在，我们来创建一个分支<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu origin/master</span><br><span class="line">Branch <span class="string">'dev/pzqu'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p></p><ul><li><code>git checkout -b 分支名 其他分支</code>,<code>-b</code>代表创建并切换到新建的分支，<code>分支名</code>代表新创建的分支叫什么名字，这里叫<code>dev/pzqu</code> ，<code>其他分支</code>代表基于哪一个分支来创建，这里基于远程的master分支<code>origin/master</code>，如果省略则代表基于当前分支</li><li><code>git branch</code>展示本地的分支情况，加<code>-a</code>参数可以展示全部的分支，包括远程分支</li><li><code>*</code>在分支前，指明了现在所在的分支是<code>dev/pzqu</code></li></ul><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu2</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu2'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  dev/pzqu</span><br><span class="line">* dev/pzqu2</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">$ git checkout dev/pzqu</span><br><span class="line">Switched to branch <span class="string">'dev/pzqu'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>基于当前分支创建了一个新的分支并自动切换过去<code>dev/pzqu2</code></li><li><code>git checkout 已存在的分支名</code>切换分支回到<code>dev/pzqu</code></li></ul><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br><span class="line">  </span><br><span class="line">$ git branch -D dev/pzqu2</span><br><span class="line">Deleted branch dev/pzqu2 (was 7c9be37).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>位于<code>dev/pzqu</code>，删除了<code>dev/pzqu2</code>分支</li></ul><h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><h3 id="合并同一个分支的冲突（常见）"><a href="#合并同一个分支的冲突（常见）" class="headerlink" title="合并同一个分支的冲突（常见）"></a>合并同一个分支的冲突（常见）</h3><p>为了产生一个冲突，我在另一个地方向远程仓库提交了代码，更改<code>share_file.txt</code>文件，加了一行内容<code>tom add for merge</code>，<br>本地修改同一个文件加了一行<code>pzqu add for merge</code>，并提交到本地，这样一来，本地和远程仓库的同一个文件就不一样了，一会拉代码一定会产生一个冲突。效果如下：</p><p><img src="/git-start/merge1.png" alt="upload successful"></p><ul><li>一般rebase或pull冲突的时候，都会出现提示，然后git status会出现上图图示</li><li>这个时候不可以进行任何分支切换和commit操作，按照他提示进行处理</li><li>git status提示哪个文件是都被修改的，both modified，然后使用编辑器修改该文件，解决冲突</li><li>解决完成后，git add 添加该冲突文件</li><li>git rebase –continue，并更新commit message，完成整个rebase流程<br>我们来看看这个冲突的文件：</li></ul><p><img src="/git-start/merge2.png" alt="upload successful"></p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><p><img src="/git-start/merge3.png" alt="upload successful"></p><p><code>git add</code>再<code>git rebase --continue</code>后完成rebase，效果如下，再<code>push</code>的远程仓库即可</p><p><img src="/git-start/merge4.png" alt="upload successful"></p><h3 id="合并不同分支的代码产生冲突"><a href="#合并不同分支的代码产生冲突" class="headerlink" title="合并不同分支的代码产生冲突"></a>合并不同分支的代码产生冲突</h3><p>关于怎么创建分支与切换分支见<a href="#创建分支和切换分支">创建分支和切换分支</a>,这里只讨论合并时产生的冲突的情况，我们已经基于<code>master</code>分支创建了一个<code>dev/pzqu</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支，加一行<code>master add for merge</code>并提交，文件内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>切换到<code>dev/pzqu</code>分支，向<code>share_file.txt</code>加入一行<code>dev/pzqu add for merge</code>并提交，现在<code>share_file.txt</code>内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>现在两个分支的同一个文件内容不一样了，现在我们在<code>dev/pzqu</code>分支上进行合并：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git merge master</span><br><span class="line">Auto-merging share_file.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> share_file.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:17:31] C:1</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">=======</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</span><br></pre></td></tr></table></figure><p></p><p>上图出现了一个冲突，是我们意料之中的，修改<code>share_file.txt</code>文件，解决此冲突：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line"></span><br><span class="line">$ git add share_file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:22:40]</span></span><br><span class="line">$ git commit -m <span class="string">"[*]merge master to dev/pzqu"</span></span><br><span class="line">[dev/pzqu d9e018e] [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu o [11:23:00]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p></p><p>冲突解决也提交了，看看我们现在的分支内容：</p><p><img src="/git-start/merge_branch_devpzqu.png" alt="upload successful"></p><p>上图我们可以看到：</p><ul><li><p><code>master</code>分支比远程<code>origin/master</code>分支多一次提交，<code>dev/pzqu</code>分支由于是基于<code>origin/master</code>分支，合并了<code>master</code>分支的提交和当前<code>dev/pzqu</code>分支的提交，超出本地<code>master</code>两个提交，致此我们把<code>master</code>合并到<code>dev/pzqu</code>的操作就完成了。</p></li><li><p>通常我们开一个新的开发分支是为了在自己的分支上写代码，方便提交也不会把主线弄乱，现在我们用同样的方法将<code>dev/pzqu</code>合并到<code>master</code>分支，然后把两个分支都提交到远程。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge dev/pzqu</span><br><span class="line">Updating 58f047a..d9e018e</span><br><span class="line">Fast-forward</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line">   7c9be37..d9e018e  master -&gt; master</span><br><span class="line">   </span><br><span class="line">$ git push origin dev/pzqu</span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 887 bytes | 887.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'dev/pzqu'</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/pzqu/git_test/pull/new/dev/pzqu</span><br><span class="line">remote:</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new branch]      dev/pzqu -&gt; dev/pzqu</span><br></pre></td></tr></table></figure><ul><li>切换到<code>master</code>分支</li><li>合并<code>dev/pzqu</code>到<code>master</code>分支</li><li><code>master</code>推到远程仓库</li><li>如果<code>dev/pzqu</code>要保留，就可以推送到远程仓库。</li></ul><p><img src="/git-start/merge_branch_statuslast.png" alt="upload successful"></p><ul><li>现在我们可以看到全部的分支都在一起了，强迫症都舒服了。</li></ul><h2 id="暂存代码保存现场"><a href="#暂存代码保存现场" class="headerlink" title="暂存代码保存现场"></a>暂存代码保存现场</h2><p>这种情况一般是出现在你正在完成一个功能，但是忽然线上发现了一个Bug，必须马上开一个新的分支来修复bug，但是现在的功能没写完不打算提交(commit)，现在怎么办？？不用怕暂存代码来帮助你。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line">modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//省略操作：去创建一个Bug分支，修复他并完成与主线的合并，删除Bug分支。</span><br><span class="line">//省略操作：切回来当前分支继续开发</span><br><span class="line">//下面来恢复现场</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   share_file.txt</span><br></pre></td></tr></table></figure><p></p><ul><li><code>status</code>查看到有2个文件修改没有提交</li><li><code>stash</code>把修改放到暂存区，并生成一个id</li><li><code>stash list</code>列出暂存区所有内容</li><li><code>stash apply</code>重新把暂存区内容放到本地</li></ul><p>这里的<code>stash apply</code>成功的把暂存区的一次暂存恢复到了本地，但是暂存区还有会保存这次暂存，如果想删除这次暂存要用<code>git stash drop</code>来删除；也可以用<code>git stash pop</code>，恢复最后一次暂存的同时把stash内容也删了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (bfdc065df8adc44c8b69fa6826e75c5991e6cad0)</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>好了，暂存区清干净了。</p><pre><code>注意：要放到暂存区的文件一定要先通过git add加到index</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文阅读结束以后，我们学会了</p><ul><li>Git的基本概念，知道git的作用、历史；学会安装配置Git，使用Git创建项目托管以及工作区和暂存区的概念</li><li>学会Git的本地操作，提交、拉代码、创建切换删除分支操作，</li><li>多人合作时的代码版本控制，学会了不同情况下的合并冲突、暂存代码操作</li></ul><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>Git常用操作（下）我计划给大家介绍以下点：</p><ul><li>后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）</li><li>哎呀，提交的时候漏了文件</li><li>tag操作</li><li>git忽略不想提交的文件</li></ul><p>下集传送门：<br><a href="/git-start3" target="view_window">版本控制工具——Git常用操作（下）</a></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> git教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql备份还原方案xtrabackup</title>
      <link href="/mysql-backup-xtrabackup/"/>
      <url>/mysql-backup-xtrabackup/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：mysql当数据库过大的时候，使用mysqldump的方式进行备份是一种非常慢的操作，500G的数据就够你备份一天一夜，我发现了一种mysql快速备份的方案，它使用文件存储的方式进行备份，支持全量和增量备份，这里所写为全量方式（如果可以接受备份开始到下次恢复之间的数据丢失时使用）。xtrabackup的备份速度很快，不管有多少的数据，备份速度完全是依赖于磁盘的读写速度，还支持压缩、不打断正在执行的事务、自动实现备份检验（用mysqldump会锁表，要加上可重复读–single-transaction才不会影响线上的程序写表，但是写表后的东西在还原的时候就会丢了，这也是全量备份的痛点）</p><a id="more"></a><ul><li><a href="#特点">特点</a></li><li><a href="#准备mysql备份组件需要的安装包">准备mysql备份组件需要的安装包</a></li><li><a href="#安装备份工具">安装备份工具</a><ul><li><a href="#1-上传并解压">1. 上传并解压</a></li><li><a href="#2-安装rpm包">2. 安装rpm包</a></li><li><a href="#3-检查是否安装成功">3. 检查是否安装成功</a></li></ul></li><li><a href="#开始备份">开始备份</a><ul><li><a href="#1-执行命令开始备份">1. 执行命令开始备份</a></li><li><a href="#2-检查是否备份成功">2. 检查是否备份成功</a></li></ul></li><li><a href="#还原备份">还原备份</a><ul><li><a href="#1-事务日志应用到备份">1. 事务日志应用到备份</a></li><li><a href="#2-恢复数据">2. 恢复数据</a></li><li><a href="#3-设置属主属组为mysql并启动">3. 设置属主属组为mysql并启动</a></li></ul></li><li><a href="#引用">引用</a></li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>(1)备份过程快速、可靠</p><p>(2)备份过程不会打断正在执行的事务</p><p>(3)能够基于压缩等功能节约磁盘空间和流量</p><p>(4)自动实现备份检验</p><p>(5)还原速度快</p><h1 id="准备mysql备份组件需要的安装包"><a href="#准备mysql备份组件需要的安装包" class="headerlink" title="准备mysql备份组件需要的安装包"></a>准备mysql备份组件需要的安装包</h1><p>检查服务器是centos6版本还是centos7+版本。选择安装包<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos6/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</span><br><span class="line">centos7/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el7-x86_64-bundle.tar</span><br></pre></td></tr></table></figure><p></p><p>安装包可以在此下载 ： <a href="https://www.percona.com/downloads/XtraBackup/LATEST/" target="_blank" rel="noopener">https://www.percona.com/downloads/XtraBackup/LATEST/</a></p><h1 id="安装备份工具"><a href="#安装备份工具" class="headerlink" title="安装备份工具"></a>安装备份工具</h1><p><font color="red">以下所有操作如果是在集群下，要在一个主节点上操作，操作一次即可</font>，启动时设置主节点为被同步节点，集群的管理我们以后再讨论。</p><h2 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1. 上传并解压"></a>1. 上传并解压</h2><p>假设当前系统是centos6+,使用<code>Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</code>包，拷贝到系统<code>/tmp/backup_mariadb20181127</code>目录下(没有则创建,日期写当天)，使用<code>tar xvf Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</code>命令解压,你可以得到以下文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pwd</span><br><span class="line">/tmp/backup_mariadb20181127</span><br><span class="line"># ls</span><br><span class="line">Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</span><br><span class="line">percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line">percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  </span><br><span class="line">percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="2-安装rpm包"><a href="#2-安装rpm包" class="headerlink" title="2. 安装rpm包"></a>2. 安装rpm包</h2><p>执行以下命令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  </span><br><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p></p><h2 id="3-检查是否安装成功"><a href="#3-检查是否安装成功" class="headerlink" title="3. 检查是否安装成功"></a>3. 检查是否安装成功</h2><p>按以下显示则安装成功<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -qa | grep percona</span></span><br><span class="line">percona-xtrabackup-test-24-2.4.12-1.el6.x86_64</span><br><span class="line">percona-xtrabackup-24-2.4.12-1.el6.x86_64</span><br><span class="line">percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64</span><br></pre></td></tr></table></figure><p></p><h1 id="开始备份"><a href="#开始备份" class="headerlink" title="开始备份"></a>开始备份</h1><h2 id="1-执行命令开始备份"><a href="#1-执行命令开始备份" class="headerlink" title="1. 执行命令开始备份"></a>1. 执行命令开始备份</h2><p>执行以下命令开始备份，其中<code>/etc/my.cnf</code>为mysql配置文件位置，10.123.2.4为mysql绑定的ip（写当前机器的ip）,user1为用户名，123456Abc为密码，/tmp/backup_mariadb20181127为备份文件所在目录，所有按实际环境填写。此处我们只备份cloud库所以<code>--databases</code>库就不用改动了<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --defaults-file=/etc/my.cnf --host=10.123.2.4 --databases="cloud" --use-memory=500M --user=user1 --password=123456Abc /tmp/backup_mariadb20181127</span><br></pre></td></tr></table></figure><p></p><ul><li>如果只需要备份其中一个或多个数据库，可以加参数<code>--databases=&quot;cloud test&quot;</code>,其中cloud和test是库名</li><li>可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。</li></ul><h2 id="2-检查是否备份成功"><a href="#2-检查是否备份成功" class="headerlink" title="2. 检查是否备份成功"></a>2. 检查是否备份成功</h2><p>最后一行显示completed OK！ 则备份成功，在所执行的目录下（此处是/tmp/backup_mariadb20181127）会出现备份的文件<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">181127 11:56:48 completed OK!</span><br></pre></td></tr></table></figure><p></p><p>可以看到文件结构，我们此处自动生成的备份文件夹名为<code>2018-11-27_11-52-48</code>，是一个以时间命名的文件夹<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">2018-11-27_11-52-48</span><br><span class="line"> Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar  percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm  percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/backup_mariadb20181127</span><br></pre></td></tr></table></figure><p></p><h1 id="还原备份"><a href="#还原备份" class="headerlink" title="还原备份"></a>还原备份</h1><h2 id="1-事务日志应用到备份"><a href="#1-事务日志应用到备份" class="headerlink" title="1. 事务日志应用到备份"></a>1. 事务日志应用到备份</h2><p>备份出的数据并不能直接使用，因为备份出的数据是不一致的，我们还需要将同时备份出的事务日志应用到备份中，才能得到一份完整、一致、可用的数据，xtrabackup称这一步操作为prepare，也就是还原数据前的”准备”工作。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --apply-log 2018-11-27_11-52-48/</span><br></pre></td></tr></table></figure><p></p><p>在事务日志容量很大的情况下，可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。<br>输出最后如下就为正确<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">181127 11:56:10 completed OK!</span><br></pre></td></tr></table></figure><p></p><h2 id="2-恢复数据"><a href="#2-恢复数据" class="headerlink" title="2. 恢复数据"></a>2. 恢复数据</h2><p>方法一、此处使用该方法，适用于备份部分数据库的方法<br>数据目录在<code>/data/mariadb/data</code>，我们备份的数据库为cloud库。<br>进入mysql命令行<code>mysql -A</code>，删除cloud库<code>drop database cloud;</code>(如果无法进入命令行则到数据目录下直接干掉cloud文件夹，集群操作的话必须通过drop或者先停止集群，确定好主从模式)<br>执行命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/mariadb/data</span><br><span class="line">rm ib* -f</span><br><span class="line">rm -f cloud</span><br><span class="line">/etc/init.d/mysqld stop <span class="comment">#关闭数据库</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/backup_mariadb20181127/2018-11-27_11-52-48 <span class="comment">#进入备份目录</span></span><br><span class="line">cp ib* /data/mariadb/data</span><br><span class="line">cp -R cloud /data/mariadb/data</span><br></pre></td></tr></table></figure><p></p><p>方法二、先停止数据库服务<code>/etc/init.d/mysqld stop</code>，且对应的数据目录(此处是<code>/data/mariadb/data</code>)为空,如果不为空，手动删除，一般此方法针对全量备份的方法。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex  --datadir=/data/mariadb/data --copy-back /tmp/backup_mariadb20181127/2018-11-27_11-52-48</span><br></pre></td></tr></table></figure><p></p><p>–copy-back：对应的目录就是我们准备好的可用数据的目录。此处为<code>/tmp/backup_mariadb20181127/2018-11-27_11-52-48</code></p><p>–datadir：指定的目录就是还原后数据要存放的目录，如果my.cnf设置了datadir，可以省略–datadir，执行copyback时会读取my.cnf中的配置，datadir目录必须为空目录,如果不为空，手动删除。</p><h2 id="3-设置属主属组为mysql并启动"><a href="#3-设置属主属组为mysql并启动" class="headerlink" title="3. 设置属主属组为mysql并启动"></a>3. 设置属主属组为mysql并启动</h2><p>此时我们还不能启动mysql，因为我们是使用root用户拷贝的数据，所以数据目录中的数据文件的属主属组仍然为root，我们需要将这些文件的属主属组设置为mysql。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/mariadb/data</span><br><span class="line">chown -R mysql.mysql *</span><br><span class="line">chown -R mysql.mysql /data/mariadb/binlog</span><br><span class="line">/etc/inid.d/mysqld start</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="http://www.cnblogs.com/zhoujinyi/p/4088866.html" target="_blank" rel="noopener">Xtrabackup 安装使用</a><br><a href="https://blog.csdn.net/fanren224/article/details/79693863" target="_blank" rel="noopener">xtrabackup 原理</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备份mysql数据库 </tag>
            
            <tag> mysql教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq管理利器——rabbitmqadmin</title>
      <link href="/rabbitmqadmin/"/>
      <url>/rabbitmqadmin/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：在运维rabbitmq集群的过程中，发生了队列的严重堆积，我们在可以容忍mq消息丢失的情况下，使用常用的<code>purge_queue queue</code>命令等好长时间都清理不成功，在管理页面上直接purge导致页面卡住不动，最终都没有办法达到清理成功的效果。这个时候发现了一个python的rabbitmq管理工具，非常的好用且迅速，在此记录。</p><a id="more"></a><ul><li><a href="#如何获取rabbitmqadmin">如何获取rabbitmqadmin</a></li><li><a href="#常用命令">常用命令</a><ul><li><a href="#查看">查看</a></li><li><a href="#系统操作">系统操作</a></li><li><a href="#用户管理操作">用户管理操作</a></li><li><a href="#队列操作">队列操作</a></li></ul></li><li><a href="#其他">其他</a><ul><li><a href="#指定输出格式">指定输出格式</a></li><li><a href="#用户角色">用户角色</a></li><li><a href="#rabbitmqctl-命令">rabbitmqctl 命令</a></li></ul></li><li><a href="#参考">参考</a></li></ul><h1 id="如何获取rabbitmqadmin"><a href="#如何获取rabbitmqadmin" class="headerlink" title="如何获取rabbitmqadmin"></a>如何获取rabbitmqadmin</h1><p><strong>方法1.</strong> 直接复制出来<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cp -a /var/lib/rabbitmq/mnesia/rabbit@localhost-plugins-expand/rabbitmq_management-3.3.5/priv/www/cli/rabbitmqadmin /usr/local/bin/rabbitmqadmin</span><br><span class="line">``` </span><br><span class="line">**方法2** 从管理页面获取</span><br><span class="line"></span><br><span class="line">1. 打开`rabbitmq_management`，访问15672管理页面，方法见&lt;a href="https://qupzhi.com/first-blog" target="_blank"&gt;rabbitmq集群的各种运维操作 4.2 打开15672网页管理端，访问mq  &lt;/a&gt;</span><br><span class="line">2. 访问 ip:15672/rabbitmqadmin</span><br><span class="line">下载页面，另存为`rabbitmqadmin.py`,放到此目录：`/usr/local/bin/rabbitmqadmin`，授权`chmod +x /usr/local/bin/rabbitmqadmin`</span><br><span class="line"></span><br><span class="line">多一句废话：可以使用wget直接下载页面上的东西</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看</span></span></span><br><span class="line">```bash</span><br><span class="line">rabbitmqadmin list users                #查看用户列表</span><br><span class="line">rabbitmqadmin list vhosts               #查看vhosts</span><br><span class="line">rabbitmqadmin list connections          ###查看 connections</span><br><span class="line">rabbitmqadmin list exchanges            ##查看 exchanges</span><br><span class="line">rabbitmqadmin list bindings             ##查看 bindings</span><br><span class="line">rabbitmqadmin list permissions          ##查看 permissions</span><br><span class="line">rabbitmqadmin list channels             ##查看 channels</span><br><span class="line">rabbitmqadmin list parameters           ##查看 parameters</span><br><span class="line">rabbitmqadmin list consumers            ##查看consumers</span><br><span class="line">rabbitmqadmin list queues               ##查看queues</span><br><span class="line">rabbitmqadmin list policies             ##查看policies</span><br><span class="line">rabbitmqadmin list nodes                ##查看nodes</span><br><span class="line">rabbitmqadmin show overview             ##查看overview</span><br></pre></td></tr></table></figure><p></p><h2 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h2><h2 id="用户管理操作"><a href="#用户管理操作" class="headerlink" title="用户管理操作"></a>用户管理操作</h2><ol><li><p>新增一个用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  add_user  Username  Password</span><br><span class="line">rabbitmqadmin declare user name=wyl password=password tags=administrator</span><br></pre></td></tr></table></figure></li><li><p>删除一个用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  delete_user  Username</span><br></pre></td></tr></table></figure></li><li><p>修改用户的密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  change_password  Username  Newpassword</span><br></pre></td></tr></table></figure></li><li><p>查看当前用户列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  list_users</span><br><span class="line">rabbitmqadmin list users    # 查看 users</span><br><span class="line">rabbitmqadmin list users name # 查看 users的时候限制字段</span><br></pre></td></tr></table></figure></li><li><p>设置用户角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  User  Tag</span><br></pre></td></tr></table></figure></li></ol><p>User为用户名， Tag为角色名(对应于<code>administrator，monitoring，policymaker，management</code>，或其他自定义名称见<a href="#用户角色">用户角色</a>)。<br>也可以给同一用户设置多个角色，例如<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  hncscwc  monitoring policymaker</span><br></pre></td></tr></table></figure><p></p><h2 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h2><p>添加queue<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin <span class="built_in">declare</span> queue name=<span class="built_in">test</span> durable=<span class="literal">true</span>    <span class="comment">## durable=true 代表持久化打开  declare是宣布的意思</span></span><br><span class="line">rabbitmqadmin --vhost=<span class="built_in">test</span> --username=admin --password=admin  <span class="built_in">declare</span> queue name=<span class="built_in">test</span> durable=<span class="literal">true</span> <span class="comment">#指定vhost添加队列</span></span><br></pre></td></tr></table></figure><p></p><p>查看queues<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list queues</span></span><br><span class="line"><span class="comment">#查看bindings</span></span><br><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list bindings</span></span><br></pre></td></tr></table></figure><p></p><p>添加消息到test queue<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin publish routing_key=<span class="built_in">test</span> payload=<span class="string">"this is a testing"</span>     <span class="comment">##未指定exchange默认 exchange name为空</span></span><br></pre></td></tr></table></figure><p></p><p>再次查看对列发现test有一条消息<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list queues</span></span><br></pre></td></tr></table></figure><p></p><p>从test queue消费一条信息<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin get queue=<span class="built_in">test</span> requeue=<span class="literal">true</span>   <span class="comment">#requeue=true 这条消息消费后还在，反之如果为false消费后消息就不在了。</span></span><br></pre></td></tr></table></figure><p></p><p>删除队列<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin delete queue name=<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>清除队列消息内容<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin purge queue name=队列名</span><br></pre></td></tr></table></figure><p></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="指定输出格式"><a href="#指定输出格式" class="headerlink" title="指定输出格式"></a>指定输出格式</h2><p>使用 -f 可以指定格式<br>有如下几种格式 raw_json, long, pretty_json, kvp, tsv, table, bash 默认为 table,具体自己试</p><h2 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h2><ol><li>超级管理员(administrator)<br>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>监控者(monitoring)<br>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li>策略制定者(policymaker)<br>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。<br>与administrator的对比，administrator能看到这些内容</li><li>普通管理者(management)<br>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</li><li>其他<br>无法登陆管理控制台，通常就是普通的生产者和消费者。<br>了解了这些后，就可以根据需要给不同的用户设置不同的角色，以便按需管理。</li></ol><h2 id="rabbitmqctl-命令"><a href="#rabbitmqctl-命令" class="headerlink" title="rabbitmqctl 命令"></a>rabbitmqctl 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_queues：查看所有队列信息</span><br><span class="line"></span><br><span class="line">rabbitmqctl stop_app：关闭应用（关闭当前启动的节点）</span><br><span class="line"></span><br><span class="line">rabbitmqctl start_app：启动应用，和上述关闭命令配合使用，达到清空队列的目的</span><br><span class="line"></span><br><span class="line">rabbitmqctl reset：从管理数据库中移除所有数据，例如配置过的用户和虚拟宿主, 删除所有持久化的消息（这个命令要在rabbitmqctl stop_app之后使用）</span><br><span class="line"></span><br><span class="line">rabbitmqctl force_reset：作用和rabbitmqctl reset一样，区别是无条件重置节点，不管当前管理数据库状态以及集群的配置。如果数据库或者集群配置发生错误才使用这个最后的手段</span><br><span class="line"></span><br><span class="line">rabbitmqctl status：节点状态</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_user username password：添加用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_users：列出所有用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_user_permissions username：列出用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl change_password username newpassword：修改密码</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_vhost vhostpath：创建虚拟主机</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_vhosts：列出所有虚拟主机</span><br><span class="line"></span><br><span class="line">rabbitmqctl set_permissions -p vhostpath username ".*" ".*" ".*"：设置用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_permissions -p vhostpath：列出虚拟主机上的所有权限 </span><br><span class="line"></span><br><span class="line">rabbitmqctl clear_permissions -p vhostpath username：清除用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息</span><br><span class="line"></span><br><span class="line">rabbitmqctl delete_user username：删除用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl delete_vhost vhostpath：删除虚拟主机</span><br></pre></td></tr></table></figure><p>未完待续-催更 <a href="mailto:pzqu@qq.com" target="_blank" rel="noopener">pzqu@qq.com</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/wylfengyujiancheng/article/details/67063083b" target="_blank" rel="noopener">通过rabbitmqadmin管理rabbitmq,【吴业亮】云计算开发工程师</a></p><p><a href="https://www.cnblogs.com/wuzhiyuan/p/6856985.html" target="_blank" rel="noopener">RabbitMQ学习笔记四：RabbitMQ命令（附疑难问题解决）</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> rabbitmq集群 </tag>
            
            <tag> rabbitmq工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq集群恢复</title>
      <link href="/rabbitmq-restart-save-data/"/>
      <url>/rabbitmq-restart-save-data/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：在rabbitmq集群运行了一段时间的时候，rabbitmq出现了异常，发现集群中的某些节点死活都不能启动。这种情况往往是因为不是奇数个节点或者其他的问题导致的集群脑裂，集群中的节点没有办法确定主从关系。现在我们就来讨论在出现这种情况的时候，在不丢失数据的情况下，我们应该怎么通过人工的方式来进行恢复。</p><a id="more"></a><h1 id="rabbitmq配置检查"><a href="#rabbitmq配置检查" class="headerlink" title="rabbitmq配置检查"></a>rabbitmq配置检查</h1><p>在我们进行问题的处理之前，我们必须要先确定我们的mq配置是不是合规的，<a href="/first-blog#一rabbitmq集群必要条件">rabbitmq集群的各种运维操作</a></p><p><img src="/rabbitmq-restart-save-data/rabbitmq-restart.png" alt=""></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://xiexianbin.cn/software/2017/04/24/rabbitmq-cluster#anchor4" target="_blank" rel="noopener">RabbitMQ 集群配置</a><br><a href="http://www.ywnds.com/?p=4741" target="_blank" rel="noopener">RabbitMQ两种集群模式配置管理（五）</a></p><p>未完待续-催更 <a href="mailto:pzqu@qq.com" target="_blank" rel="noopener">pzqu@qq.com</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq集群 </tag>
            
            <tag> rabbitmq教程 </tag>
            
            <tag> TODO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq之Federation配置</title>
      <link href="/rabbitmq-federation/"/>
      <url>/rabbitmq-federation/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：当我们有多个rabbitmq集群的时候，如果想要单向的同步集群的消息，也就是说把新集群当作老集群的镜像集群，实时的同步老集群的消息，在老集群消息被消费的时候不会影响同步到新集群的消息。在外部看上去就像每次写入消息的时候，同时向新老两个集群写入一样,不论mq的跨版本，不论mq的用户。一般我们会将这种情况应用于存在两个不同的系统，但是老数据来源只能向一个队列写入数据，此时为了在新系统上也可以实时同步到老系统队列中的数据的时候。</p><a id="more"></a><ul><li><a href="#federation介绍">Federation介绍</a><ul><li><a href="#特点">特点</a><ul><li><a href="#松耦合性loose-coupling">松耦合性（Loose coupling）</a></li><li><a href="#wan-友好性wan-friendly">WAN 友好性（WAN-friendly）</a></li><li><a href="#扩展性scalability">扩展性（Scalability）</a></li></ul></li><li><a href="#federation能做什么">federation能做什么？</a></li><li><a href="#配置的种类">配置的种类</a></li><li><a href="#身份验证">身份验证</a></li></ul></li><li><a href="#操作步骤说明">操作步骤说明</a><ul><li><a href="#1-在集群的每一个node开启federation插件同步和被同步集群都需要">1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)</a></li><li><a href="#2-登录到同步集群的管理界面httpxxx15672">2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/</a></li><li><a href="#3-创建upstream">3. 创建upstream</a></li><li><a href="#4-创建policy">4. 创建policy</a></li><li><a href="#5-查看状态图">5. 查看状态图</a></li><li><a href="#6-查看连接">6. 查看连接</a></li></ul></li><li><a href="#高级">高级</a></li><li><a href="#参考">参考</a></li></ul><h1 id="Federation介绍"><a href="#Federation介绍" class="headerlink" title="Federation介绍"></a>Federation介绍</h1><blockquote><p>federation 插件的最终目标是，在不同 broker 之间进行消息传递而无需建立集群；该功能在很多场景下非常有用：</p></blockquote><p><strong>注意:当你在一个cluster中使用federation插件，所有在集群中 的nodes都需要安装federation插件</strong></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="松耦合性（Loose-coupling）"><a href="#松耦合性（Loose-coupling）" class="headerlink" title="松耦合性（Loose coupling）"></a>松耦合性（Loose coupling）</h3><ul><li>federation 插件能够在分属不同管理域的 broker 或 cluster 之间传递消息：</li><li>他们可能设置了不同的 user 和 vhost ；</li><li>他们可能运行在不同版本的 RabbitMQ 和 Erlang 上；</li></ul><h3 id="WAN-友好性（WAN-friendly）"><a href="#WAN-友好性（WAN-friendly）" class="headerlink" title="WAN 友好性（WAN-friendly）"></a>WAN 友好性（WAN-friendly）</h3><ul><li>federation 插件基于 AMQP 0-9-1 协议在不同 broker 之间进行通信，并设计成能够容忍不稳定的网络连通情况；</li></ul><h3 id="扩展性（Scalability）"><a href="#扩展性（Scalability）" class="headerlink" title="扩展性（Scalability）"></a>扩展性（Scalability）</h3><ul><li>federation 不需要在 n 个 broker 之间建立 O(n^2) 个连接（尽管这是最简单的使用模式），这也就意味着 federation 在使用时更容易扩展</li></ul><h2 id="federation能做什么？"><a href="#federation能做什么？" class="headerlink" title="federation能做什么？"></a>federation能做什么？</h2><blockquote><p>federation 插件允许你将多个 exchange 或多个 queue 进行 federate ；federated exchange 或 federated queue 能够从一个或多个 upstream 接收到消息；</p></blockquote><p>也就是说，你的队列可以和其他集群的队列建立一种关系，他们之间可以相互的同步数据，可以是我同步给你，也可以是你同步给我，不过这种关系有两个角色一个是上游一个是下游，数据流向是上游流向下流。<br>这里有三个名词，federation 插件允许你将多个 exchange 或多个 queue 进行 federate：</p><ul><li>upstream： 上游，是指位于其他 broker 上的、远端 exchange 和 queue ；</li><li>federated exchange： 到exchange的关系，能够将发给 upstream 的消息路由到本地的某个 queue 中；</li><li>federated queue： 到queue的关系，则允许一个本地消费者接收到来自 upstream queue 的消息；</li></ul><h2 id="配置的种类"><a href="#配置的种类" class="headerlink" title="配置的种类"></a>配置的种类</h2><p>关于 federation upstream 的信息全都保存在 RabbitMQ 的数据库中，其中包括了 user 信息、permission 信息、queue 信息等等；<br>在 federation 中存在 3 种界别的配置：</p><ul><li>Upstreams - 每一个 upstream 用于定义如何与另外的 broker 建立连接；</li><li>Upstream sets - 每一个 upstream set 用于针对一系列使用 federation 功能 upstream 进行了分组；</li><li>Policies - 每一种 policy 会限定（过滤）出一组 exchange ，或者一组 queue ，或者同时针对两者进行限定；policy 最终将作用于一个单独的 upstream 上，或者一个 upstream set 上，并对其他对象发挥作用；</li></ul><p><em>实际上，在最简单的使用情况下，你可以忽略已经存在的upstream设置，因为有一个隐含的默认upstream叫做“all”，他会添加所有的upstream。</em></p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>我们讨论的是免身份验证的方式，如果有身份难的需求请参考官网：<a href="http://www.rabbitmq.com/authentication.html" target="_blank" rel="noopener">http://www.rabbitmq.com/authentication.html</a></p><h1 id="操作步骤说明"><a href="#操作步骤说明" class="headerlink" title="操作步骤说明"></a>操作步骤说明</h1><blockquote><p>parameter 和 policy 可以通过 3 种方式进行设置：<br>通过 rabbitmqctl 脚本；<br>通过 management 插件提供的 HTTP API ；<br>通过 rabbitmq_federation_management 插件提供的 Web UI（更通用的方式,我们也是通过页面来配置就可以了）；注意：基于 Web UI 的方式不能提供全部功能，尤其无法针对 upstream set 进行管理；</p></blockquote><h2 id="1-在集群的每一个node开启federation插件-同步和被同步集群都需要"><a href="#1-在集群的每一个node开启federation插件-同步和被同步集群都需要" class="headerlink" title="1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)"></a>1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)</h2><p>参考命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></table></figure><p></p><h2 id="2-登录到同步集群的管理界面-http-x-x-x-15672"><a href="#2-登录到同步集群的管理界面-http-x-x-x-15672" class="headerlink" title="2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/"></a>2. 登录到同步集群的管理界面::<a href="http://x.x.x.:15672/#/" target="_blank" rel="noopener">http://x.x.x.:15672/#/</a></h2><h2 id="3-创建upstream"><a href="#3-创建upstream" class="headerlink" title="3. 创建upstream"></a>3. 创建upstream</h2><p>tips:在下游，也就是新队列（被同步队列）上操作</p><p><img src="/rabbitmq-federation/upstream.png" alt="upstrem"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin-&gt;Federation Upstreams-&gt;Add a new upstream Name:随意填写 URI:填被同步集群(例如:amqp://user1:xxx@x.x.x.x,xxx为连接密码) Expires:默认填写3600000 单位ms</span><br><span class="line">其余字段可不用填写</span><br></pre></td></tr></table></figure><p><strong>Expires</strong>：是代表缓存时间，如果说网络连通性不好的时候，消息会在上游的队列中缓存的时间，超时丢弃，设置为空则表示，永远缓存不会丢弃数据（但是如果长时候不恢复内存会占用越来越大，建议设置上）<br><strong>Acknowledgement Mode</strong>: 代表消息确认方式，用来防止消息在传输过程中丢失，有三个值，on-confirm、on-publish、no-ack，对传输速度的影响是从慢速到快速，对安全性是不会丢失到可能会丢失。通常使用<code>on-publish</code>，不然<code>on-confirm</code>太慢了。</p><h2 id="4-创建policy"><a href="#4-创建policy" class="headerlink" title="4. 创建policy"></a>4. 创建policy</h2><p>tips:在下游，也就是新队列（被同步队列）上操作<br><img src="/rabbitmq-federation/policy.png" alt="policy"><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin-&gt;Policies-&gt;Add / update a policy</span><br><span class="line">Name:随意填写(sync_data)</span><br><span class="line">Pattern:匹配表达式(例如:^(?!amq.).* 剔除系统队列后的所有队列)</span><br><span class="line">Apply to: 默认选择Exchange and queues Definition:federation-upstream-set = all (选定federation规则)</span><br></pre></td></tr></table></figure><p></p><h2 id="5-查看状态图"><a href="#5-查看状态图" class="headerlink" title="5. 查看状态图"></a>5. 查看状态图</h2><p>现在，所有内置的 exchange 都应该建立了 federation ，因为他们都能匹配上面的 policy，可以通过页面查看状态<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin &gt; Federation Status &gt; Running Links 查看针对每个 exchange 的 federation 连接。</span><br><span class="line">配置成功可以看到匹配的Exchange / Queue， state:running</span><br></pre></td></tr></table></figure><p></p><p>也可以通过下面的命令查看状态图：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl eval 'rabbit_federation_status:status().'</span><br></pre></td></tr></table></figure><p></p><p>也可以通过 management 插件中的 exchange 列表，或者下面的命令输出，确认上述 policy 已经作用到了 exchange 上；<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_exchanges name policy | grep federate-me</span><br></pre></td></tr></table></figure><p></p><p>通常情况下，针对每个 upstream 都会有一条 federation 连接，该 federation 连接对应到一个 exchange 上；例如 3 个 exchange 与 2 个 upstream 分别建立 federation 的情况下，会有 6 条连接。</p><h2 id="6-查看连接"><a href="#6-查看连接" class="headerlink" title="6. 查看连接"></a>6. 查看连接</h2><pre><code>登录到被同步集群（上游）的管理界面::http://x.x.x.:15672/#/ 前往 Connections选项 配置成功可以看到来自同步集群的连接</code></pre><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>更复杂的配置：<a href="https://www.rabbitmq.com/federation-reference.html" target="_blank" rel="noopener">https://www.rabbitmq.com/federation-reference.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.rabbitmq.com/federation.html" target="_blank" rel="noopener">官网</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq集群 </tag>
            
            <tag> rabbitmq教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ansible_roles</title>
      <link href="/ansible-roles/"/>
      <url>/ansible-roles/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：本节主要总结ansiblerroles中常用的语法以及高级特性、例如变量、下载、解压、修改文件内容等,便于使用ansible协同开发，做更加庞大的任务。</p><a id="more"></a><ul><li><a href="#常用">常用</a><ul><li><a href="#远程执行脚本">远程执行脚本</a></li><li><a href="#设置某个参数供下文使用">设置某个参数供下文使用</a></li><li><a href="#文件是否存在和变量是否声明">文件是否存在和变量是否声明</a></li><li><a href="#解压">解压</a></li><li><a href="#下载">下载</a></li><li><a href="#修改文件内容直接替换方式">修改文件内容，直接替换方式</a></li><li><a href="#配置文件">配置文件</a></li><li><a href="#执行命令时指定脚本执行目录">执行命令时指定脚本执行目录</a></li></ul></li><li><a href="#高级">高级</a><ul><li><a href="#委托">委托</a></li></ul></li><li><a href="#统一目录结构">统一目录结构</a></li><li><a href="#引用">引用</a></li></ul><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="远程执行脚本"><a href="#远程执行脚本" class="headerlink" title="远程执行脚本"></a>远程执行脚本</h2><ol><li><p>脚本放到template里</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">init</span> <span class="string">rbac</span> <span class="string">rights</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">'init_rbac_privilege.sh'</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">'/tmp/init_rbac_privilege.sh'</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">init</span> <span class="string">rbac</span> <span class="string">rights</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"bash /tmp/init_rbac_privilege.sh"</span></span><br><span class="line"><span class="attr">  run_once:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></li><li><p>脚本放files文件里</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">copy</span> <span class="string">script</span> <span class="string">file</span> <span class="string">to</span> <span class="string">remote</span> <span class="string">server</span></span><br><span class="line"><span class="attr">  copy:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"generate_uuid.py"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">and</span> <span class="string">args</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"python <span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="设置某个参数供下文使用"><a href="#设置某个参数供下文使用" class="headerlink" title="设置某个参数供下文使用"></a>设置某个参数供下文使用</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">path</span></span><br><span class="line"><span class="attr">  set_fact:</span></span><br><span class="line"><span class="attr">    dest_script_file:</span> <span class="string">'/tmp/generate_uuid.py'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">copy</span> <span class="string">script</span> <span class="string">file</span> <span class="string">to</span> <span class="string">remote</span> <span class="string">server</span></span><br><span class="line"><span class="attr">  copy:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"generate_uuid.py"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br></pre></td></tr></table></figure><h2 id="文件是否存在和变量是否声明"><a href="#文件是否存在和变量是否声明" class="headerlink" title="文件是否存在和变量是否声明"></a>文件是否存在和变量是否声明</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- stat:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">file_result</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">and</span> <span class="string">args</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"python <span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span> <span class="template-variable">&#123;&#123; inventory_hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">p_new_host_uuid</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">host_uuid</span> <span class="string">is</span> <span class="string">not</span> <span class="string">defined</span> <span class="string">and</span> <span class="string">file_result.stat.exists</span></span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>解压tar.gz，desc所指定的目录需要提前创建<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Unarchive</span> <span class="string">ceph_report</span> <span class="string">program</span> <span class="string">package</span></span><br><span class="line"><span class="attr">  unarchive:</span></span><br><span class="line"><span class="attr">    remote_src:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"/tmp/ceph_report/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/data/monitorcloud/script/"</span></span><br></pre></td></tr></table></figure><p></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">download</span> <span class="string">ceph_report</span> <span class="string">package</span></span><br><span class="line"><span class="attr">  get_url:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"http://<span class="template-variable">&#123;&#123; tstack_repo_address &#125;&#125;</span>:<span class="template-variable">&#123;&#123; tstack_repo_port &#125;&#125;</span>/tstack/tstack-tars/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/tmp/ceph_report/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0644</span></span><br></pre></td></tr></table></figure><h2 id="修改文件内容，直接替换方式"><a href="#修改文件内容，直接替换方式" class="headerlink" title="修改文件内容，直接替换方式"></a>修改文件内容，直接替换方式</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">insert</span> <span class="string">mons</span> <span class="string">connect</span> <span class="string">message</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">"/data/monitorcloud/script/ceph_report/host_dic"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">EOF</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">"<span class="template-variable">&#123;&#123;item[0]&#125;&#125;</span> <span class="template-variable">&#123;&#123;item[1]&#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_nested:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; groups['mons'] | union( groups['osds'] )&#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">["&#123;&#123;ansible_ssh_pass&#125;&#125;"]</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>ansible中指定配置文件，.j2中可映射ansible变量<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Prepare</span> <span class="string">ceph_report_http</span> <span class="string">program</span> <span class="string">configuration</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"opts.py.j2"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/data/monitorcloud/script/ceph_report/opts.py"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0644</span></span><br></pre></td></tr></table></figure><p></p><h2 id="执行命令时指定脚本执行目录"><a href="#执行命令时指定脚本执行目录" class="headerlink" title="执行命令时指定脚本执行目录"></a>执行命令时指定脚本执行目录</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">execute</span> <span class="string">ceph_report_http</span> <span class="string">install</span> <span class="string">script</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"/usr/bin/python  ceph_report_http.py install"</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="attr">     chdir:</span> <span class="string">'/data/monitorcloud/script/ceph_report/'</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>在当前运行ansible的机器上，委托其他机器运行<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">host</span> <span class="string">record</span> <span class="string">to</span> <span class="string">center</span> <span class="string">server</span> </span><br><span class="line"><span class="attr"> shell:</span> <span class="string">'echo "192.168.1.100 test.xyz.com " &gt;&gt; /etc/hosts'</span></span><br><span class="line"><span class="attr"> delegate_to:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p></p><p>也可以委托ansible服务端运行<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">host</span> <span class="string">record</span> <span class="string">to</span> <span class="string">center</span> <span class="string">server</span> </span><br><span class="line"><span class="attr"> shell:</span> <span class="string">'echo hello'</span></span><br><span class="line"><span class="attr"> delegate_to:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure><p></p><h1 id="统一目录结构"><a href="#统一目录结构" class="headerlink" title="统一目录结构"></a>统一目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── filter_plugins          # 自定义 filter 插件存放目录</span><br><span class="line">├── fooapp                  # Fooapp 片色目录 ( 与 common 角色目录平级)</span><br><span class="line">├── group_vars             </span><br><span class="line">│   ├── group1              # group1 自定义变量文件</span><br><span class="line">│   └── group2              # group2 自定义变量文件</span><br><span class="line">├── host_vars</span><br><span class="line">│   ├── hostname1           # hostname1 自定义变量文件</span><br><span class="line">│   └── hostname2           # hostname1 自定义变量文件</span><br><span class="line">├── library                 # 自定义模块存放目录</span><br><span class="line">├── monitoring              # Monitoring 角色目录 ( 与 common 角色目录平级)</span><br><span class="line">├── roles                   # Role 存放目录</span><br><span class="line">│   └── common              # common 角色目录</span><br><span class="line">│       ├── defaults       </span><br><span class="line">│       │   └── main.yml    # common 角色自定义文件 (优先级低)</span><br><span class="line">│       ├── files</span><br><span class="line">│       │   ├── bar.txt     # common 角色 files 资源文件</span><br><span class="line">│       │   └── foo.sh      # common 角色 files 资源文件</span><br><span class="line">│       ├── handlers</span><br><span class="line">│       │   └── main.yml    # common 角色 handlers 入口文件</span><br><span class="line">│       ├── meta</span><br><span class="line">│       │   └── main.yml    # common 角色 依赖文件</span><br><span class="line">│       ├── tasks</span><br><span class="line">│       │   └── main.yml    # common 角色 task 入口文件</span><br><span class="line">│       ├── template</span><br><span class="line">│       │   └── ntp.conf.j2 # common 角色 template 文件</span><br><span class="line">│       └── vars</span><br><span class="line">│           └── main.yml    # common 角色 变量定义文件</span><br><span class="line">├── site.yaml               # Playbook 统一入口文件</span><br><span class="line">├── stage                   # stage 环境的 inventory 文件</span><br><span class="line">├── webservers.yml          # 特殊 Playbook 文件</span><br><span class="line">└── webtier                 # webtier 角色目录 ( 与 common 角色目录平级)</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>ansible进阶技巧 <a href="https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html</a></p><p>shilei ansible 文档 <a href="https://wiki.shileizcc.com/confluence/display/AN/Ansible" target="_blank" rel="noopener">https://wiki.shileizcc.com/confluence/display/AN/Ansible</a></p><p>骏马金龙 ansible系列文章 <a href="http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible" target="_blank" rel="noopener">http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进入自动化部署的大门-ansible</title>
      <link href="/ansible%E5%88%9D%E6%8E%A2/"/>
      <url>/ansible%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：ansible是运维与实施人员的福音，其优雅的结构，丰富的模块库，简单的编程方式都让其成为自动化部署的不二语言。现在就让我们了解ansible,并使用ansible来做一些简单的任务</p><a id="more"></a><ul><li><a href="#一基本概念">一、基本概念</a><ul><li><a href="#11-如何安装及安装要求">1.1 如何安装及安装要求</a></li><li><a href="#12-专有名词解释">1.2 专有名词解释</a></li><li><a href="#13-原理图">1.3 原理图</a></li><li><a href="#14-连接机制">1.4 连接机制</a></li><li><a href="#15-常用文件及配置位置">1.5 常用文件及配置位置</a></li></ul></li><li><a href="#二简单的例子">二、简单的例子</a><ul><li><a href="#21-配置被管控机器的连接信息">2.1 配置被管控机器的连接信息</a></li><li><a href="#22-执行命令">2.2 执行命令</a></li></ul></li><li><a href="#23-讨论执行命令的四个模块有什么区别">2.3 讨论执行命令的四个模块有什么区别</a></li><li><a href="#三-完成复杂的ansible操作">三、 完成复杂的ansible操作</a></li><li><a href="#引用">引用</a></li><li><a href="#资源">资源</a></li></ul><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><blockquote><p>Ansible是一款开源软件，可自动执行软件供应，配置管理和应用程序部署。Ansible通过SSH，远程PowerShell或其他远程API连接。—-选自wikipedia</p></blockquote><p>简介：ansible有两种服务器类型，控制机器与节点。控制机器就是安装ansible服务的机器，我们在上面编写和运行ansible的程序代码，并在控制机器上通过ssh远程操作机器（下发上传、执行命令）。当ansible脚本不运行的时候，不会占用任何资源（比如saltstack在运行的时候就会启动进程来监控4505/4506端口），也正由于ansible的这个特点，每次ansible发布更新的时候，只需要更新控制机器就可以了。</p><h2 id="1-1-如何安装及安装要求"><a href="#1-1-如何安装及安装要求" class="headerlink" title="1.1 如何安装及安装要求"></a>1.1 如何安装及安装要求</h2><p>要求：</p><ul><li>控制机是linux系统，需要有python2.6/2.7</li><li>linux系统打开文件数量设置大一些（方法自行百度）</li><li>节点要求，python2.4以上版本</li></ul><p>安装方法（有很多，在此只列出常用的方法，具体安装步骤不做赘述）：</p><ul><li>源码安装 git://github.com/ansible/ansible.git</li><li>yum 方式 / apt 方式 / emerge 方式 或其他linux系统的系统安装方式</li><li>pip 方式</li></ul><h2 id="1-2-专有名词解释"><a href="#1-2-专有名词解释" class="headerlink" title="1.2 专有名词解释"></a>1.2 专有名词解释</h2><table><thead><tr><th>关键字</th><th>释义</th></tr></thead><tbody><tr><td>playbook</td><td>剧本，将要执行的步骤全部放到playbook里面</td></tr><tr><td>modules（通常指core modules）</td><td>核心模块，用于执行某些任务的已有内置插件</td></tr><tr><td>roles</td><td>角色，像演戏一样，剧本中指定在什么时候哪个角色来做什么操作，所以剧本包含角色，角色就有自己的台词，不过ansible里面的角色特殊的地方是，剧本只知识角色是干什么的，具体操作步骤是在角色本身管理（无厘头）</td></tr><tr><td>custom modules</td><td>自定义模块，在核心模块不够用的时候可以自定义编写模块</td></tr><tr><td>plugins</td><td>插件，常用于ansible的日志系统与邮件系统，还有的插件有扩展内置连接方式、扩展变量定义方式、扩展内部循环语法、扩展新的过滤器等</td></tr><tr><td>Inventory</td><td>Ansible 管理主机的清单</td></tr></tbody></table><h2 id="1-3-原理图"><a href="#1-3-原理图" class="headerlink" title="1.3 原理图"></a>1.3 原理图</h2><p><img src="/ansible初探/20180819164218.png" alt="原理图"></p><h2 id="1-4-连接机制"><a href="#1-4-连接机制" class="headerlink" title="1.4 连接机制"></a>1.4 连接机制</h2><p>ansible通常使用的是ssh协议（或者Kerberos、LDAP）来进行连接（在openssh不支持的操作系统或ansible比较老的版本，ansible使用paramiko），ansible支持的连接方式有三种SSH、Local、ZeroMQ，在规模比较大的情况下使用ZeroMQ连接方式对执行速度有显著提高</p><h2 id="1-5-常用文件及配置位置"><a href="#1-5-常用文件及配置位置" class="headerlink" title="1.5 常用文件及配置位置"></a>1.5 常用文件及配置位置</h2><table><thead><tr><th>文件</th><th>位置</th></tr></thead><tbody><tr><td>ansible应用程序的主配置文件</td><td>/etc/ansible/ansible.cfg</td></tr><tr><td>定义管控主机</td><td>/etc/ansible/hosts</td></tr></tbody></table><h1 id="二、简单的例子"><a href="#二、简单的例子" class="headerlink" title="二、简单的例子"></a>二、简单的例子</h1><p>这里我们来实现在所有被管控机器上执行<code>hostname</code>命令输出主机名</p><h2 id="2-1-配置被管控机器的连接信息"><a href="#2-1-配置被管控机器的连接信息" class="headerlink" title="2.1 配置被管控机器的连接信息"></a>2.1 配置被管控机器的连接信息</h2><p><img src="/ansible初探/20180819164958.png" alt="配置被管控机器的连接信息"></p><ul><li>备注1：在<code>/etc/ansible/hosts</code>位置写入一个主机组（分组名为<code>test</code>），以后针对这个分组操作就视为对分组内的所有主机操作。</li><li>备注2：<code>[test:vars]</code> 标签下为<code>test</code>分组的变量，<code>ansible_ssh_user</code>和<code>ansible_ssh_pass</code>是ansible的内置变量，意思为该分组下所有主机的用户和和密码，当前了也可以单独指定某台主机只需要将这两个参数追加到ip的旁边就好。这里三台主机都是同一个用户名和密码，所以像这样配置。</li><li>备注3：默认路径是在<code>/etc/ansible/hosts</code>,如果你不喜欢是可以修改的(修改配置文件<code>/etc/ansible/ansible.cfg</code>的<code>inventory=/etc/ansible/hosts</code>即可)<h2 id="2-2-执行命令"><a href="#2-2-执行命令" class="headerlink" title="2.2 执行命令"></a>2.2 执行命令</h2></li></ul><p>执行命令，输出<code>test</code>分组下的所有主机的主机名，<code>-i</code>指定主机或分组,<code>-m</code>指定使用的模块，<code>-a</code>指定传给模块的参数，这里<code>command</code>模块就是执行linux命令的模块缺省时默认使用该模块，相同作用的还有<code>shell</code>模块、<code>raw</code>模块、<code>script</code>模块（使用场景与部分细节上不同，后面探讨）<br><img src="/ansible初探/20180827230444.png" alt="20180827230444.png"></p><h1 id="2-3-讨论执行命令的四个模块有什么区别"><a href="#2-3-讨论执行命令的四个模块有什么区别" class="headerlink" title="2.3 讨论执行命令的四个模块有什么区别"></a>2.3 讨论执行命令的四个模块有什么区别</h1><p>每次在使用的时候都会有一些迷惑，为什么非要弄四个执行命令的模块出来，一开始决定没有必要，但是到后来才明白存在既合理，这里和大家探讨一下</p><table><thead><tr><th>模块</th><th>解释</th></tr></thead><tbody><tr><td><code>command模块</code></td><td>是为了安全的执行linux命令，所以不支持`”&lt;”, “&gt;”, “</td><td>“, 和 “&amp;”`等符号（没有shell注入风险），如果要一定要使用这些，则使用shell模块</td></tr><tr><td><code>shell模块</code></td><td>通过<code>/bin/sh</code>来执行，其他都和command一样</td></tr><tr><td><code>raw模块</code></td><td>用来执行低版本的linux命令，可以不需要python来执行命令，甚至支持windows命令，带来的问题是很多很特性是不能用的</td></tr><tr><td>script模块</td><td>其原理是先将脚本，复制到远程主机，再在远程主机上执行，所以要指定脚本路径以及操作方法</td></tr></tbody></table><p>结论：要安全用command，要方便用shell，要操作写好的shell脚本或者其他脚本就用script、要是以上操作都跑不了的机器就用raw</p><h1 id="三、-完成复杂的ansible操作"><a href="#三、-完成复杂的ansible操作" class="headerlink" title="三、 完成复杂的ansible操作"></a>三、 完成复杂的ansible操作</h1><p>未完待续–</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Ansible插件扩展 <a href="https://blog.csdn.net/yongchaocsdn/article/details/79271870" target="_blank" rel="noopener">https://blog.csdn.net/yongchaocsdn/article/details/79271870</a></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>插件 <a href="https://github.com/ansible/ansible/tree/stable-2.4/lib/ansible/plugins" target="_blank" rel="noopener">https://github.com/ansible/ansible/tree/stable-2.4/lib/ansible/plugins</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置像我一样的hexo博客</title>
      <link href="/%E9%85%8D%E7%BD%AE%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E9%85%8D%E7%BD%AE%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：csdn和博客园虽然用的人多、技术氛围好，但是由于csdn的广告和灌水以及博客园的简陋页面让我决定搭建一套属于自己的博客，此处用到比较火的hexo搭建，而且免费就能获得自己的网站，如果不买域名的话完全够用了<br><a id="more"></a></p><ul><li><a href="#一搭建本地-hexo">一、搭建本地 hexo</a><ul><li><a href="#11-安装nodejs">1.1 安装nodejs</a></li><li><a href="#12-安装git">1.2 安装git</a></li><li><a href="#13-使用npm安装hexo">1.3 使用npm安装Hexo</a></li><li><a href="#14-创建本地服务">1.4 创建本地服务</a></li><li><a href="#15-主题配置">1.5 主题配置</a></li></ul></li><li><a href="#二-配置你的github">二、 配置你的github</a><ul><li><a href="#21-创建一个新项目">2.1 创建一个新项目</a></li><li><a href="#22-填写正确的项目名称">2.2 填写正确的项目名称</a></li><li><a href="#23-配置你的项目">2.3 配置你的项目</a></li></ul></li><li><a href="#三激动人心的博客">三、激动人心的博客</a><ul><li><a href="#31-修改hexo配置文件">3.1 修改hexo配置文件</a></li><li><a href="#32-部署成功">3.2 部署成功</a></li></ul></li><li><a href="#四个性化配置你的博客">四、个性化配置你的博客</a><ul><li><a href="#41-配置博客名博客描述等信息">4.1 配置博客名，博客描述等信息</a></li><li><a href="#42-添加头像">4.2 添加头像</a></li><li><a href="#43-添加日志列表">4.3 添加日志列表</a></li><li><a href="#42-其他">4.2 其他</a></li></ul></li><li><a href="#五配置你的hexo可以插入图片">五、配置你的hexo可以插入图片</a></li><li><a href="#附加速npm">附：加速npm</a></li><li><a href="#引用">引用</a></li></ul><hr><h1 id="一、搭建本地-hexo"><a href="#一、搭建本地-hexo" class="headerlink" title="一、搭建本地 hexo"></a>一、搭建本地 hexo</h1><h2 id="1-1-安装nodejs"><a href="#1-1-安装nodejs" class="headerlink" title="1.1 安装nodejs"></a>1.1 安装nodejs</h2><p>到nodejs官网下载安装 <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></p><h2 id="1-2-安装git"><a href="#1-2-安装git" class="headerlink" title="1.2 安装git"></a>1.2 安装git</h2><p>到git官网下载安装 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h2 id="1-3-使用npm安装Hexo"><a href="#1-3-使用npm安装Hexo" class="headerlink" title="1.3 使用npm安装Hexo"></a>1.3 使用npm安装Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>备注： 如果npm下载比较慢可以跳到 <a href="#附加速npm">附：加速npm</a></p><h2 id="1-4-创建本地服务"><a href="#1-4-创建本地服务" class="headerlink" title="1.4 创建本地服务"></a>1.4 创建本地服务</h2><p>创建一个文件夹，此处为blog，执行以下命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo i blog //init的缩写 blog是项目名</span><br><span class="line"><span class="built_in">cd</span> blog //切换到站点根目录</span><br><span class="line">hexo g //generetor的缩写</span><br><span class="line">hexo s //server的缩写</span><br></pre></td></tr></table></figure><p></p><p><img src="/配置像我一样的hexo博客/20180812012524.png" alt="本地hexo"><br>访问本地服务<code>localhost:4000</code>证明成功,为什么和我的不一样，因为我修改了hexo的主题配置可以跳到 <a href="#四个性化配置你的博客">四、个性化配置你的博客</a><br><img src="/配置像我一样的hexo博客/20180812012807.png" alt="本地hexo"><br>有页面出来证明你的配置已经成功了，原始的主题不是很喜欢，我这里也使用了最火的nexT主题</p><h2 id="1-5-主题配置"><a href="#1-5-主题配置" class="headerlink" title="1.5 主题配置"></a>1.5 主题配置</h2><p>在站点根目录输入<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p></p><p>完成后，打开根目录下的_config.yml， 找到 theme 字段，并将其值更改为 next<br><img src="/配置像我一样的hexo博客/20180812013802.png" alt="本地hexo"><br>next有三种主题，我选择的是双栏 Scheme，找到 <code>站点根目录/themes/next/_congig.yml</code> 文件，再找到<code>schme</code>字段，将其值改为<code>Pisces</code>,其他两种可以参考<a href="#引用">引用</a>里所写的<br><img src="/配置像我一样的hexo博客/20180812014827.png" alt="next主题"></p><p>使配置生效<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  //清除缓存</span><br><span class="line">hexo g  //重新生成代码</span><br><span class="line">hexo s  //部署到本地</span><br></pre></td></tr></table></figure><p></p><p>这样你的会有一套和我一样主题的博客了，如果你不喜欢这套主题，或者想自己来开发一套定制自己的主题参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a>,下面让我们把他推到github上，变成独一无二的网站</p><h1 id="二、-配置你的github"><a href="#二、-配置你的github" class="headerlink" title="二、 配置你的github"></a>二、 配置你的github</h1><h2 id="2-1-创建一个新项目"><a href="#2-1-创建一个新项目" class="headerlink" title="2.1 创建一个新项目"></a>2.1 创建一个新项目</h2><p>如果没有注册github帐号到&gt;<a href="https://github.com/" target="_blank" rel="noopener">官网注册</a><br>点此创建项目（如果你不是程序员建议勾选上图中Initalize this repository with a README选项）：<br><img src="/配置像我一样的hexo博客/20180812020821.png" alt="next主题"></p><h2 id="2-2-填写正确的项目名称"><a href="#2-2-填写正确的项目名称" class="headerlink" title="2.2 填写正确的项目名称"></a>2.2 填写正确的项目名称</h2><p>项目名可以为<code>任意英文.github.io</code>，public设置为公开项目,点击绿色创建按钮</p><p><img src="/配置像我一样的hexo博客/20180812021131.png" alt="next主题"></p><h2 id="2-3-配置你的项目"><a href="#2-3-配置你的项目" class="headerlink" title="2.3 配置你的项目"></a>2.3 配置你的项目</h2><p>在项目里创建一个readme.md即可，这下可以在页面上访问到这个免费的网站了<br>我的网站 <a href="https://pzqu.github.io/" target="_blank" rel="noopener">https://pzqu.github.io/</a></p><h1 id="三、激动人心的博客"><a href="#三、激动人心的博客" class="headerlink" title="三、激动人心的博客"></a>三、激动人心的博客</h1><h2 id="3-1-修改hexo配置文件"><a href="#3-1-修改hexo配置文件" class="headerlink" title="3.1 修改hexo配置文件"></a>3.1 修改hexo配置文件</h2><p>修改根目录的配置文件<code>_config.yml</code>，以下部分如果没有需要手动创建，建议直接拷贝我的，repo为自己刚刚创建的那个项目的git链接（注意冒号与值之间必须有空格）<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/pzqu/pzqu.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p></p><h2 id="3-2-部署成功"><a href="#3-2-部署成功" class="headerlink" title="3.2 部署成功"></a>3.2 部署成功</h2><p>直接执行一套命令,再刷新刚刚的域名即可<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d  //  部署的命令,会生成代码并推送到github上去</span><br></pre></td></tr></table></figure><p></p><h1 id="四、个性化配置你的博客"><a href="#四、个性化配置你的博客" class="headerlink" title="四、个性化配置你的博客"></a>四、个性化配置你的博客</h1><h2 id="4-1-配置博客名，博客描述等信息"><a href="#4-1-配置博客名，博客描述等信息" class="headerlink" title="4.1 配置博客名，博客描述等信息"></a>4.1 配置博客名，博客描述等信息</h2><p>参考官方网站 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration.html</a></p><h2 id="4-2-添加头像"><a href="#4-2-添加头像" class="headerlink" title="4.2 添加头像"></a>4.2 添加头像</h2><p>在主题配置文件里修改<br><code>avatar: images/avatar.gif</code></p><h2 id="4-3-添加日志列表"><a href="#4-3-添加日志列表" class="headerlink" title="4.3 添加日志列表"></a>4.3 添加日志列表</h2><h2 id="4-2-其他"><a href="#4-2-其他" class="headerlink" title="4.2 其他"></a>4.2 其他</h2><p>添加顶部加载条,修改主题配置文件，pace_theme有好几款，自己选一款<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pace: <span class="literal">true</span></span><br><span class="line">pace_theme: pace-theme-flash</span><br></pre></td></tr></table></figure><p></p><p>添加打赏功能，修改主题配置文件，图片可以上传到<code>themes\next\source\images</code><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /images/wxpay.jpg</span><br><span class="line">alipay: /images/alipay.jpg</span><br></pre></td></tr></table></figure><p></p><p>文章阅读量<br>参考 <a href="https://www.jianshu.com/p/702a7aec4d00" target="_blank" rel="noopener">https://www.jianshu.com/p/702a7aec4d00</a></p><p>评论系统<br><a href="http://www.zhaojun.im/hexo-valine/" target="_blank" rel="noopener">http://www.zhaojun.im/hexo-valine/</a></p><p>删除底部强力驱动、统计站点网上自己查<br>添加分享<br>添加评论</p><h1 id="五、配置你的hexo可以插入图片"><a href="#五、配置你的hexo可以插入图片" class="headerlink" title="五、配置你的hexo可以插入图片"></a>五、配置你的hexo可以插入图片</h1><ol><li>把主页配置文件 _config.yml 里的post_asset_folder:这个选项设置为true</li><li>在你的hexo目录下执行<code>npm install hexo-asset-image --save</code></li><li>等待一小段时间后，再运行<code>hexo n &quot;配置像我一样的hexo博客&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>配置像我一样的hexo博客.md</code>文件还有一个同名的文件夹</li><li>最后在<code>配置像我一样的hexo博客.md</code>中想引入图片时，先把图片复制到<code>配置像我一样的hexo博客</code>这个文件夹中，然后只需要在<code>配置像我一样的hexo博客.md</code>中按照markdown的格式引入图片,注意使用相对路径：<br><code>![你想输入的替代文字](配置像我一样的hexo博客/图片名.jpg)</code></li></ol><h1 id="附：加速npm"><a href="#附：加速npm" class="headerlink" title="附：加速npm"></a>附：加速npm</h1><p>配置npm镜像<code>npm config set registry https://registry.npm.taobao.org</code><br>查看npm镜像<code>npm config get registry</code></p><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！</a><br><a href="https://blog.csdn.net/quuqu/article/details/64121812" target="_blank" rel="noopener">npm太慢， 淘宝npm镜像使用方法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq集群的各种运维操作</title>
      <link href="/first-blog/"/>
      <url>/first-blog/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Dec 22 2018 16:25:28 GMT+0800 (China Standard Time) --><p>摘要：在rabbitmq集群操作或者搭建的时候，常常会因为对于集群的不熟练而导致各种异常错误，常见的有绑定了浮动ip没有绑定实体ip导致，页面上操作mq完全没有问题，但是一到程序操作就出现问题，我们一起来学习下，rabbitmq集群的正确操作</p><a id="more"></a><ul><li><a href="#一rabbitmq集群必要条件">一、rabbitmq集群必要条件</a><ul><li><a href="#11-绑定实体ip即ifconfig所能查询到的绑定到网卡上的ip以下是绑定方法">1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</a></li><li><a href="#12-配置域名映射到实体ip">1.2. 配置域名映射到实体ip</a></li></ul></li><li><a href="#二启动停止">二、启动停止</a><ul><li><a href="#21-停止">2.1 停止</a></li><li><a href="#22-启动">2.2 启动</a></li></ul></li><li><a href="#三重建集群">三、重建集群</a><ul><li><a href="#31-使用21方法停止所有机器">3.1 使用2.1方法停止所有机器</a></li><li><a href="#32-移除rabbitmq配置记录与存储文件">3.2 移除rabbitmq配置记录与存储文件</a></li><li><a href="#33-按22方法启动所有机器">3.3 按2.2方法启动所有机器</a></li><li><a href="#34-停止被加入集群节点app">3.4 停止被加入集群节点app</a></li><li><a href="#35-建立集群">3.5 建立集群</a></li><li><a href="#36-启动集群">3.6 启动集群</a></li><li><a href="#37-检查集群状态">3.7 检查集群状态</a></li><li><a href="#38-添加集群配置-见第四">3.8 添加集群配置 （见第四）</a></li></ul></li><li><a href="#四-添加集群配置">四 添加集群配置</a><ul><li><a href="#41-创建用户">4.1 创建用户</a></li><li><a href="#42-打开15672网页管理端访问mq">4.2 打开15672网页管理端，访问mq</a></li><li><a href="#43-在底部导入json后缀的配置文件即可">4.3 在底部导入.json后缀的配置文件即可</a></li></ul></li></ul><hr><blockquote><p>以下操作都以三节点集群为例，机器名标记为机器A、机器B、机器C，如果为双节点忽略机器C，如果为各多节点则与机器C操作相同</p></blockquote><h1 id="一、rabbitmq集群必要条件"><a href="#一、rabbitmq集群必要条件" class="headerlink" title="一、rabbitmq集群必要条件"></a>一、rabbitmq集群必要条件</h1><h2 id="1-1-绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法"><a href="#1-1-绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法" class="headerlink" title="1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法"></a>1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑配置路径 /etc/rabbitmq/rabbitmq-env.conf</span></span><br><span class="line">NODE_IP_ADDRESS=172.16.136.133</span><br></pre></td></tr></table></figure><h2 id="1-2-配置域名映射到实体ip"><a href="#1-2-配置域名映射到实体ip" class="headerlink" title="1.2. 配置域名映射到实体ip"></a>1.2. 配置域名映射到实体ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#配置文件1所在路径 /etc/rabbitmq/rabbitmq.config (如果是集群，每台机器都需要修改这个绑定本机实体ip)</span><br><span class="line">#其中rabbit@master是创建集群时所配置的参数，@后面的参数为主机名，示例中为master</span><br><span class="line">[</span><br><span class="line">    &#123;rabbit, [</span><br><span class="line">    &#123;cluster_nodes, &#123;[&apos;rabbit@master&apos;], disc&#125;&#125;,</span><br><span class="line">    &#123;cluster_partition_handling, ignore&#125;,</span><br><span class="line">    &#123;default_user, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;default_pass, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;tcp_listen_options, [binary,</span><br><span class="line">        &#123;packet, raw&#125;,</span><br><span class="line">        &#123;reuseaddr, true&#125;,</span><br><span class="line">        &#123;backlog, 128&#125;,</span><br><span class="line">        &#123;nodelay, true&#125;,</span><br><span class="line">        &#123;exit_on_close, false&#125;,</span><br><span class="line">        &#123;keepalive, true&#125;]&#125;</span><br><span class="line">    ]&#125;,</span><br><span class="line">    &#123;kernel, [</span><br><span class="line">        &#123;inet_dist_listen_max, 44001&#125;,</span><br><span class="line">        &#123;inet_dist_listen_min, 44001&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#配置文件2 所在路径 /etc/hosts (如果是集群，每台机器都需要修改这个绑定本机实体ip，而且hosts文件的映射不得重复，如果重复linux系统为以最下面一条记录为准)</span><br><span class="line">172.16.136.133 master</span><br><span class="line">172.16.136.134 venus</span><br><span class="line">172.16.136.135 venus2</span><br></pre></td></tr></table></figure><h1 id="二、启动停止"><a href="#二、启动停止" class="headerlink" title="二、启动停止"></a>二、启动停止</h1><h2 id="2-1-停止"><a href="#2-1-停止" class="headerlink" title="2.1 停止"></a>2.1 停止</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器A</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br><span class="line"><span class="comment">#机器B</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br></pre></td></tr></table></figure><h2 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器A</span></span><br><span class="line">service rabbitmq-server start</span><br><span class="line"><span class="comment">#机器B</span></span><br><span class="line">service rabbitmq-server start</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure><h1 id="三、重建集群"><a href="#三、重建集群" class="headerlink" title="三、重建集群"></a>三、重建集群</h1><blockquote><p>注1：此处的mq集群重建是比较快速和有效的方法，面向的是初次安装或者可以接受mq中所存有的数据丢失的情况下，必须先有mq的.json后缀的配置文件或者有把握写入集群中exchange、queue等配置。</p></blockquote><blockquote><p>注2:如果是运行中的mq出现问题，需要在保存数据和配置的情况下恢复集群时，请跳到<a href="/rabbitmq-restart-save-data">rabbitmq集群恢复</a></p></blockquote><h2 id="3-1-使用2-1方法停止所有机器"><a href="#3-1-使用2-1方法停止所有机器" class="headerlink" title="3.1 使用2.1方法停止所有机器"></a>3.1 使用2.1方法停止所有机器</h2><h2 id="3-2-移除rabbitmq配置记录与存储文件"><a href="#3-2-移除rabbitmq配置记录与存储文件" class="headerlink" title="3.2 移除rabbitmq配置记录与存储文件"></a>3.2 移除rabbitmq配置记录与存储文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位于 /var/lib/rabbitmq/mensia</span></span><br><span class="line">mv /var/lib/rabbitmq/mensia /var/lib/rabbitmq/mensia.bak</span><br></pre></td></tr></table></figure><h2 id="3-3-按2-2方法启动所有机器"><a href="#3-3-按2-2方法启动所有机器" class="headerlink" title="3.3 按2.2方法启动所有机器"></a>3.3 按2.2方法启动所有机器</h2><h2 id="3-4-停止被加入集群节点app"><a href="#3-4-停止被加入集群节点app" class="headerlink" title="3.4 停止被加入集群节点app"></a>3.4 停止被加入集群节点app</h2><blockquote><p>比如A、B、C三台机器，将B和C加入到A中去，需要执行以下命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="3-5-建立集群"><a href="#3-5-建立集群" class="headerlink" title="3.5 建立集群"></a>3.5 建立集群</h2><blockquote><p>注意此处master为唯一没有执行<code>rabbitmqctl stop_app</code>的机器<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="3-6-启动集群"><a href="#3-6-启动集群" class="headerlink" title="3.6 启动集群"></a>3.6 启动集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h2 id="3-7-检查集群状态"><a href="#3-7-检查集群状态" class="headerlink" title="3.7 检查集群状态"></a>3.7 检查集群状态</h2><p>在任意一台机器上执行<code>rabbitmqctl cluster_status</code>命令即可检查，输出包含集群中的节点与运行中的节点，兼以主机名标志</p><h2 id="3-8-添加集群配置-（见第四）"><a href="#3-8-添加集群配置-（见第四）" class="headerlink" title="3.8 添加集群配置 （见第四）"></a>3.8 添加集群配置 （见第四）</h2><h1 id="四-添加集群配置"><a href="#四-添加集群配置" class="headerlink" title="四 添加集群配置"></a>四 添加集群配置</h1><h2 id="4-1-创建用户"><a href="#4-1-创建用户" class="headerlink" title="4.1 创建用户"></a>4.1 创建用户</h2><blockquote><p>例子中创建了两个用户<br>添加用户<code>add_user</code>,设置角色<code>set_user_tags</code>,添加rabbitmq虚拟主机<code>add_vhost</code>，设置访问权限<code>set_permissions</code>,以下是详细用法<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建第一个用户</span></span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名 administrator</span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p /  用户名 <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line"><span class="comment"># 创建第二个用户</span></span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名2 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名2 management </span><br><span class="line">/usr/sbin/rabbitmqctl add_vhost sip_ext </span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p sip_ext 用户名2 <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br></pre></td></tr></table></figure><p></p></blockquote><pre><code>备注：RabbitMQ 虚拟主机，RabbitMQ 通过虚拟主机（vhost）来分发消息。拥有自己独立的权限控制，不同的vhost之间是隔离的，单独的。权限控制的基本单位：vhost。用户只能访问与之绑定的vhost。vhost是AMQP中唯一无法通过协议来创建的基元。只能通过rabbitmqctl工具来创建。 </code></pre><h2 id="4-2-打开15672网页管理端，访问mq"><a href="#4-2-打开15672网页管理端，访问mq" class="headerlink" title="4.2 打开15672网页管理端，访问mq"></a>4.2 打开15672网页管理端，访问mq</h2><p><code>/usr/sbin/rabbitmq-plugins enable rabbitmq_management</code><br>备注：如果发现命令执行完毕没有打开此服务，15672端口没有监听，则是由于没有重启mq导致的</p><h2 id="4-3-在底部导入-json后缀的配置文件即可"><a href="#4-3-在底部导入-json后缀的配置文件即可" class="headerlink" title="4.3 在底部导入.json后缀的配置文件即可"></a>4.3 在底部导入.json后缀的配置文件即可</h2><p><img src="/first-blog/rabbitmq.jpg" alt="rabbitmq更新配置"></p><p>如果覆盖了用户需要使用以下命令修改mq用户密码<br><code>/usr/sbin/rabbitmqctl change_password 用户名 密码</code></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq集群 </tag>
            
            <tag> rabbitmq教程 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
