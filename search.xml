<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>rabbitmq 原理、集群、基本运维操作、常见故障处理</title>
      <link href="/rabbitmq-learn01/"/>
      <url>/rabbitmq-learn01/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Mar 04 2019 19:14:59 GMT+0800 (China Standard Time) --><p>摘要:本次学习主要针对运维人员，和对rabbitmq不熟悉的开发人员。通过本次学习你将掌握rabbitmq 的基本原理、集群、基本运维操作、常见故障处理</p><p>用时：25 分钟</p><a id="more"></a><h2 id="原理与概念"><a href="#原理与概念" class="headerlink" title="原理与概念"></a>原理与概念</h2><p>用时：9 分钟</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。</p><p>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>RabbitMQ就是当前最主流的消息中间件之一。</p><ul><li>两个（多个）系统间需要通过定时任务来同步某些数据</li><li>异构系统的不同进程间相互调用、通讯的问题</li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue（队列）是RabbitMQ的内部对象，用于存储消息，用下图表示。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/2rmxyd3keu.png" alt=""></p><p>RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/7qb2l35nds.png" alt=""></p><p>多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ndf2dmmehz.png" alt=""></p><h3 id="技术术语"><a href="#技术术语" class="headerlink" title="技术术语"></a>技术术语</h3><ul><li>Broker：简单来说就是消息队列服务器实体。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作权限分离，把不同的系统使用的rabbitmq区分开，共用一个消息队列服务器，但看上去就像各自在用不用的rabbitmq服务器一样。</li><li>Connection:一个网络连接，比如TCP/IP套接字连接。</li><li>channel：消息通道，是建立在真实的TCP连接内的虚拟连接（是我们与RabbitMQ打交道的最重要的一个接口）。仅仅创建了客户端到Broker之间的连接后，客户端还是不能发送消息的,需要为每一个Connection创建Channel，AMQP协议规定只有通过Channel才能执行AMQP的命令。AMQP的命令都是通过信道发送出去的（我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。）。每条信道都会被指派一个唯一ID。在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务,理论上无限制，减少TCP创建和销毁的开销，实现共用TCP的效果。之所以需要Channel，是因为TCP连接的建立和释放都是十分昂贵的，如果一个客户端每一个线程都需要与Broker交互，如果每一个线程都建立一个TCP连接，暂且不考虑TCP连接是否浪费，就算操作系统也无法承受每秒建立如此多的TCP连接。<br>注1：一个生产者或一个消费者与MQ服务器之间只有一条TCP连接<br>注2：RabbitMQ建议客户端线程之间不要共用Channel，至少要保证共用Channel的线程发送消息必须是串行的，但是建议尽量共用Connection。</li><li>Exchange：消息交换机，生产者不是直接将消息投递到Queue中的，实际上是生产者将消息发送到Exchange（交换器，下图中的X），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。<br><img src="https://ask.qcloudimg.com/http-save/3097464/b65ot5xw2u.png" alt="exchange"></li><li>Exchange Types<br>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述），之后会分别进行介绍。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。<br><img src="https://ask.qcloudimg.com/http-save/3097464/47j88fen2g.png" alt="binding"></li><li>Routing Key：路由关键字，生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。<br><img src="https://ask.qcloudimg.com/http-save/3097464/vnt5k2zqlg.png" alt=""><br>在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。</li><li>Prefetch count<br>前面我们讲到如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。<br><img src="https://ask.qcloudimg.com/http-save/3097464/iq9ntw3nvn.png" alt="prefetchCount"></li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/00aas67oy3.png" alt="prefetchCount"></p><h3 id="消息队列的使用过程"><a href="#消息队列的使用过程" class="headerlink" title="消息队列的使用过程"></a>消息队列的使用过程</h3><p>在AMQP模型中，Exchange是接受生产者消息并将消息路由到消息队列的关键组件。ExchangeType和Binding决定了消息的路由规则。所以生产者想要发送消息，首先必须要声明一个Exchange和该Exchange对应的Binding。</p><p>在Rabbit MQ中，声明一个Exchange需要三个参数：ExchangeName，ExchangeType和Durable。ExchangeName是该Exchange的名字，该属性在创建Binding和生产者通过publish推送消息时需要指定。ExchangeType，指Exchange的类型，在RabbitMQ中，有三种类型的Exchange：direct ，fanout和topic，不同的Exchange会表现出不同路由行为。Durable是该Exchange的持久化属性，这个会在消息持久化章节讨论。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/vpppdwmyg2.png" alt="声明一个Exchange"></p><p>声明一个Binding需要提供一个QueueName，ExchangeName和BindingKey。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/vnt5k2zqlg.png" alt="声明一个Binding"></p><p>下面是消息发送的过程</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/v5ihkivlz8.png" alt=""></p><ol><li>建立连接Connection。由producer和consumer创建连接，连接到broker的物理节点上。</li><li>建立消息Channel。Channel是建立在Connection之上的，一个Connection可以建立多个Channel。producer连接Virtual Host 建立Channel，Consumer连接到相应的queue上建立Channel。</li><li>发送消息。由Producer发送消息到Broker中的Exchange中。</li><li>路由转发。生产者Producer在发送消息时，都需要指定一个RoutingKey和Exchange，Exchange收到消息后可以看到消息中指定的RoutingKey，再根据当前Exchange的ExchangeType,按一定的规则将消息转发到相应的queue中去。</li><li>消息接收。Consumer会监听相应的queue，一旦queue中有可以消费的消息，queue就将消息发送给Consumer端。</li><li>消息确认。当Consumer完成某一条消息的处理之后，需要发送一条ACK消息给对应的Queue。Queue收到ACK信息后，才会认为消息处理成功，并将消息从Queue中移除；如果在对应的Channel断开后，Queue没有收到这条消息的ACK信息，该消息将被发送给另外的Channel。至此一个消息的发送接收流程走完了。消息的确认机制提高了通信的可靠性。</li></ol><h3 id="exchange-与-Queue-的路由机制"><a href="#exchange-与-Queue-的路由机制" class="headerlink" title="exchange 与 Queue 的路由机制"></a>exchange 与 Queue 的路由机制</h3><p><img src="https://ask.qcloudimg.com/http-save/3097464/2dad7dbmhd.png" alt="exchange type"></p><p>exchange 将消息发送到哪一个queue是由exchange type 和bing 规则决定的，目前常用的有3种exchange，Direct exchange, Fanout exchange, Topic exchange 。</p><ul><li>Direct exchange 直接转发路由，其实现原理是通过消息中的routkey，与queue 中的routkey 进行比对，若二者匹配，则将消息发送到这个消息队列。通常使用这个。<br><img src="https://ask.qcloudimg.com/http-save/3097464/pvw1l5nz1j.png" alt="Direct"><br>以上图的配置为例，我们以routingKey=”error”发送消息到Exchange，则消息会路由到Queue1（amqp.gen-S9b…，这是由RabbitMQ自动生成的Queue名称）和Queue2（amqp.gen-Agl…）；如果我们以routingKey=”info”或routingKey=”warning”来发送消息，则消息只会路由到Queue2。如果我们以其他routingKey发送消息，则消息不会路由到这两个Queue中。</li><li>Fanout exchange 复制分发路由，该路由不需要routkey，当exchange收到消息后，将消息复制多份转发给与自己绑定的消息队列。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/qrhh0rwx28.png" alt="Fanout"></p><p>上图中，生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。</p><ul><li>topic exchange 通配路由，是direct exchange的通配符模式，消息中的routkey可以写成通配的模式，exchange支持“#”和“*” 的通配。收到消息后，将消息转发给所有符合匹配表达式的queue。<br><img src="https://ask.qcloudimg.com/http-save/3097464/qiitbakkc1.png" alt="topic"><br>以上图中的配置为例，routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。</li></ul><p>需要注意的一点只有queue具有</p><p>保持消息的功能，exchange不能保存消息。</p><ul><li>headers<br>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。<br>该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。</li></ul><h3 id="durability-持久化与非持久化队列"><a href="#durability-持久化与非持久化队列" class="headerlink" title="durability 持久化与非持久化队列"></a>durability 持久化与非持久化队列</h3><p><img src="https://ask.qcloudimg.com/http-save/3097464/7iyjx2zc1d.png" alt="如何识别"></p><ol><li>如何识别？<br>如上图，在Features字段里有一个<code>D</code>,就是持久化队列，英文durable（持久的）</li><li>持久化队列和非持久化队列的区别是什么？<br>持久化队列会被保存在磁盘中，固定并持久的存储，当Rabbit服务重启后，该队列会保持原来的状态在RabbitMQ中被管理，而非持久化队列不会被保存在磁盘中，Rabbit服务重启后队列就会消失。</li><li>如何选择？<br>如果需要队列的完整性，数据在队列中的保存是必须不允许丢失的，那么可以使用持久化。而当需要获取的信息是实时的，或者是随机的信息，不需要信息的精确性或完整性，但是追求获取性能，可以选择非持久化队列。</li></ol><h2 id="分布式集群架构和高可用性"><a href="#分布式集群架构和高可用性" class="headerlink" title="分布式集群架构和高可用性"></a>分布式集群架构和高可用性</h2><p>用时：5 分钟</p><h3 id="设计集群的目的"><a href="#设计集群的目的" class="headerlink" title="设计集群的目的"></a>设计集群的目的</h3><ul><li>允许消费者和生产者在RabbitMQ节点崩溃的情况下继续运行</li><li>通过增加更多的节点来扩展消息通信的吞吐量</li></ul><h3 id="集群配置方式"><a href="#集群配置方式" class="headerlink" title="集群配置方式"></a>集群配置方式</h3><p>RabbitMQ可以通过三种方法来部署分布式集群系统，分别是：cluster,federation,shovel</p><ul><li>cluster:<ol><li>不支持跨网段，用于同一个网段内的局域网</li><li>可以随意的动态增加或者减少</li><li>节点之间需要运行相同版本的RabbitMQ和Erlang</li></ol></li><li>federation:应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器上交换机或队列的消息，可以是单独机器或集群。federation队列类似于单向点对点连接，消息会在联盟队列之间转发任意次，直到被消费者接受。通常使用federation来连接internet上的中间服务器，用作订阅分发消息或工作队列。</li><li>shovel:连接方式与federation的连接方式类似，但它工作在更低层次。可以应用于广域网</li></ul><h4 id="RabbitMQ-cluster-集群同步原理"><a href="#RabbitMQ-cluster-集群同步原理" class="headerlink" title="RabbitMQ cluster 集群同步原理"></a>RabbitMQ cluster 集群同步原理</h4><p><img src="https://ask.qcloudimg.com/http-save/3097464/iy7916utbo.png" alt="rabbitmq cluster"></p><p>上面图中采用三个节点组成了一个RabbitMQ的集群，Exchange A的元数据信息在所有节点上是一致的，而Queue（存放消息的队列）的完整数据则只会存在于它所创建的那个节点上。，其他节点只知道这个queue的metadata信息和一个指向queue的owner node的指针。</p><h5 id="RabbitMQ集群元数据的同步"><a href="#RabbitMQ集群元数据的同步" class="headerlink" title="RabbitMQ集群元数据的同步"></a>RabbitMQ集群元数据的同步</h5><p>RabbitMQ集群会始终同步四种类型的内部元数据（类似索引）：</p><ol><li>队列元数据：队列名称和它的属性；</li><li>交换器元数据：交换器名称、类型和属性；</li><li>绑定元数据：一张简单的表格展示了如何将消息路由到队列；</li><li>vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性；<br>因此，当用户访问其中任何一个RabbitMQ节点时，通过rabbitmqctl查询到的queue／user／exchange/vhost等信息都是相同的。</li></ol><h6 id="为何RabbitMQ集群仅采用元数据同步的方式"><a href="#为何RabbitMQ集群仅采用元数据同步的方式" class="headerlink" title="为何RabbitMQ集群仅采用元数据同步的方式"></a>为何RabbitMQ集群仅采用元数据同步的方式</h6><p>一，存储空间，如果每个集群节点都拥有所有Queue的完全数据拷贝，那么每个节点的存储空间会非常大，集群的消息积压能力会非常弱（无法通过集群节点的扩容提高消息积压能力）；</p><p>二，性能，消息的发布者需要将消息复制到每一个集群节点，对于持久化消息，网络和磁盘同步复制的开销都会明显增加。</p><h4 id="RabbitMQ-cluster-集群的两种模式"><a href="#RabbitMQ-cluster-集群的两种模式" class="headerlink" title="RabbitMQ cluster 集群的两种模式"></a>RabbitMQ cluster 集群的两种模式</h4><ol><li>普通模式：默认的集群模式。</li><li>镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/b7ejh8fgjq.png" alt="普通模式同步方式"></p><p><strong>普通模式</strong>：当消息进入A节点的Queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer，所以consumer应平均连接每一个节点，从中取消息。该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。如果做了队列持久化或消息持久化，那么得等A节点恢复，然后才可被消费，并且在A节点恢复之前其它节点不能再创建A节点已经创建过的持久队列；如果没有持久化的话，消息就会失丢。这种模式更适合非持久化队列，只有该队列是非持久的，客户端才能重新连接到集群里的其他节点，并重新创建队列。假如该队列是持久化的，那么唯一办法是将故障节点恢复起来。</p><p>为什么RabbitMQ不将队列复制到集群里每个节点呢？这与它的集群的设计本意相冲突，集群的设计目的就是增加更多节点时，能线性的增加性能（CPU、内存）和容量（内存、磁盘）。当然RabbitMQ新版本集群也支持队列复制（有个选项可以配置）。比如在有五个节点的集群里，可以指定某个队列的内容在2个节点上进行存储，从而在性能与高可用性之间取得一个平衡（应该就是指镜像模式）。</p><p><strong>镜像模式</strong>：其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用.</p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul><li>RAM node:内存节点将所有的队列、交换机、绑定、用户、权限和vhost的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。</li><li>Disk node:将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启RabbitMQ的时候，丢失系统的配置信息。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/gaauyabn3s.png" alt="如何查看是何种节点"></p><p>如果是内存结点这里就显示为RAM</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>RabbitMQ要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。</li><li>如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作(包括创建队列、交换器、绑定，添加用户、更改权限、添加和删除集群结点)，直到节点恢复。</li><li>解决方案：设置两个磁盘节点，至少有一个是可用的，可以保存元数据的更改。</li></ul><h3 id="Erlang-Cookie"><a href="#Erlang-Cookie" class="headerlink" title="Erlang Cookie"></a>Erlang Cookie</h3><p>Erlang Cookie是保证不同节点可以相互通信的密钥，要保证集群中的不同节点相互通信必须共享相同的Erlang Cookie。具体的目录存放在<code>/var/lib/rabbitmq/.erlang.cookie</code>。</p><h2 id="基本运维操作"><a href="#基本运维操作" class="headerlink" title="基本运维操作"></a>基本运维操作</h2><p>用时：8 分钟</p><h3 id="rabbitmq集群必要条件"><a href="#rabbitmq集群必要条件" class="headerlink" title="rabbitmq集群必要条件"></a>rabbitmq集群必要条件</h3><h4 id="绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法"><a href="#绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法" class="headerlink" title="绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法"></a>绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#编辑配置路径 /etc/rabbitmq/rabbitmq-env.conf</span><br><span class="line">NODE_IP_ADDRESS=172.16.136.133</span><br></pre></td></tr></table></figure><h4 id="配置域名映射到实体ip"><a href="#配置域名映射到实体ip" class="headerlink" title="配置域名映射到实体ip"></a>配置域名映射到实体ip</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#配置文件1所在路径 /etc/rabbitmq/rabbitmq.config (如果是集群，每台机器都需要修改这个绑定本机实体ip)</span><br><span class="line">#其中rabbit@master是创建集群时所配置的参数，@后面的参数为主机名，示例中为master</span><br><span class="line">[</span><br><span class="line">    &#123;rabbit, [</span><br><span class="line">    &#123;cluster_nodes, &#123;[&apos;rabbit@master&apos;], disc&#125;&#125;,</span><br><span class="line">    &#123;cluster_partition_handling, ignore&#125;,</span><br><span class="line">    &#123;default_user, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;default_pass, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;tcp_listen_options, [binary,</span><br><span class="line">        &#123;packet, raw&#125;,</span><br><span class="line">        &#123;reuseaddr, true&#125;,</span><br><span class="line">        &#123;backlog, 128&#125;,</span><br><span class="line">        &#123;nodelay, true&#125;,</span><br><span class="line">        &#123;exit_on_close, false&#125;,</span><br><span class="line">        &#123;keepalive, true&#125;]&#125;</span><br><span class="line">    ]&#125;,</span><br><span class="line">    &#123;kernel, [</span><br><span class="line">        &#123;inet_dist_listen_max, 44001&#125;,</span><br><span class="line">        &#123;inet_dist_listen_min, 44001&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#配置文件2 所在路径 /etc/hosts (如果是集群，每台机器都需要修改这个绑定本机实体ip，而且hosts文件的映射不得重复，如果重复linux系统为以最下面一条记录为准)</span><br><span class="line">172.16.136.133 master</span><br><span class="line">172.16.136.134 venus</span><br><span class="line">172.16.136.135 venus2</span><br></pre></td></tr></table></figure><h3 id="启动停止"><a href="#启动停止" class="headerlink" title="启动停止"></a>启动停止</h3><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#机器A</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器C</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>方式1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#机器A</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器C</span><br><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure><p>方式2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><h3 id="集群重启顺序"><a href="#集群重启顺序" class="headerlink" title="集群重启顺序"></a>集群重启顺序</h3><p>集群重启的顺序是固定的，并且是相反的。 如下所述：</p><p>启动顺序：磁盘节点 =&gt; 内存节点</p><p>关闭顺序：内存节点 =&gt; 磁盘节点</p><p>最后关闭必须是磁盘节点，不然可能回造成集群启动失败、数据丢失等异常情况。</p><h3 id="重建集群"><a href="#重建集群" class="headerlink" title="重建集群"></a>重建集群</h3><blockquote><p>注1：此处的mq集群重建是比较快速和有效的方法，面向的是初次安装或者可以接受mq中所存有的数据丢失的情况下，必须先有mq的.json后缀的配置文件或者有把握写入集群中exchange、queue等配置。</p></blockquote><h4 id="按顺序停止所有机器中的rabbitmq"><a href="#按顺序停止所有机器中的rabbitmq" class="headerlink" title="按顺序停止所有机器中的rabbitmq"></a>按顺序停止所有机器中的rabbitmq</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#机器A</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br><span class="line">#机器C</span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -kill</span><br></pre></td></tr></table></figure><h4 id="移除rabbitmq配置记录与存储文件"><a href="#移除rabbitmq配置记录与存储文件" class="headerlink" title="移除rabbitmq配置记录与存储文件"></a>移除rabbitmq配置记录与存储文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#位于 /var/lib/rabbitmq/mensia</span><br><span class="line">mv /var/lib/rabbitmq/mensia /var/lib/rabbitmq/mensia.bak</span><br></pre></td></tr></table></figure><h4 id="按顺序启动所有机器中的rabbitmq"><a href="#按顺序启动所有机器中的rabbitmq" class="headerlink" title="按顺序启动所有机器中的rabbitmq"></a>按顺序启动所有机器中的rabbitmq</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#机器C</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器B</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#机器A</span><br><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure><h4 id="停止被加入集群节点app"><a href="#停止被加入集群节点app" class="headerlink" title="停止被加入集群节点app"></a>停止被加入集群节点app</h4><blockquote><p>比如A、B、C三台机器，将B和C加入到A中去，需要执行以下命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#机器B</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">#机器C</span><br><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><h4 id="建立集群"><a href="#建立集群" class="headerlink" title="建立集群"></a>建立集群</h4><blockquote><p>注意此处master为唯一没有执行<code>rabbitmqctl stop_app</code>的机器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#机器B</span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br><span class="line">#机器C</span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br></pre></td></tr></table></figure><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#机器B</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">#机器C</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h4 id="检查集群状态"><a href="#检查集群状态" class="headerlink" title="检查集群状态"></a>检查集群状态</h4><p>在任意一台机器上执行<code>rabbitmqctl cluster_status</code>命令即可检查，输出包含集群中的节点与运行中的节点，兼以主机名标志</p><h4 id="添加集群配置"><a href="#添加集群配置" class="headerlink" title="添加集群配置"></a>添加集群配置</h4><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><blockquote><p>例子中创建了两个用户</p></blockquote><p>添加用户<code>add_user</code>,设置角色<code>set_user_tags</code>,添加rabbitmq虚拟主机<code>add_vhost</code>，设置访问权限<code>set_permissions</code>,以下是详细用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建第一个用户</span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名 administrator</span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p /  用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"># 创建第二个用户</span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名2 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名2 management </span><br><span class="line">/usr/sbin/rabbitmqctl add_vhost sip_ext </span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p sip_ext 用户名2 &apos;.*&apos; &apos;.*&apos; &apos;.*&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">备注：RabbitMQ 虚拟主机，RabbitMQ 通过虚拟主机（vhost）来分发消息。拥有自己独立的权限控制，不同的vhost之间是隔离的，单独的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限控制的基本单位：vhost。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户只能访问与之绑定的vhost。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vhost是AMQP中唯一无法通过协议来创建的基元。只能通过rabbitmqctl工具来创建。</span><br></pre></td></tr></table></figure><h5 id="打开15672网页管理端，访问mq"><a href="#打开15672网页管理端，访问mq" class="headerlink" title="打开15672网页管理端，访问mq"></a>打开15672网页管理端，访问mq</h5><p><code>/usr/sbin/rabbitmq-plugins enable rabbitmq_management</code></p><p>备注：如果发现命令执行完毕没有打开此服务，15672端口没有监听，则是由于没有重启mq导致的</p><h5 id="在底部导入-json后缀的配置文件即可"><a href="#在底部导入-json后缀的配置文件即可" class="headerlink" title="在底部导入.json后缀的配置文件即可"></a>在底部导入.json后缀的配置文件即可</h5><p><a href="http://localhost:4000/first-blog/rabbitmq.jpg" target="_blank" rel="noopener">http://localhost:4000/first-blog/rabbitmq.jpg</a></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/8izjwkkyiy.png" alt=""></p><p>如果覆盖了用户需要使用以下命令修改mq用户密码</p><p><code>/usr/sbin/rabbitmqctl change_password 用户名 密码</code></p><h3 id="修改节点类型"><a href="#修改节点类型" class="headerlink" title="修改节点类型"></a>修改节点类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line">rabbitmqctl change_cluster_node_type dist</span><br><span class="line"></span><br><span class="line">rabbitmqctl change_cluster_node_type ram</span><br><span class="line"></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://ask.qcloudimg.com/http-save/3097464/nnpdnkn0vi.png" alt="常用命令"></p><h2 id="常见故障"><a href="#常见故障" class="headerlink" title="常见故障"></a>常见故障</h2><p>用时：3 分钟</p><ul><li>集群状态异常<ol><li><code>rabbitmqctl cluster_status</code>检查集群健康状态，不正常节点重新加入集群</li><li>分析是否节点挂掉，手动启动节点。</li><li>保证网络连通正常</li></ol></li><li>队列阻塞、数据堆积<ol><li>保证网络连通正常</li><li>保证消费者正常消费，消费速度大于生产速度</li><li>保证服务器TCP连接限制合理</li></ol></li><li>脑裂<ol><li>按正确顺序重启集群</li><li>保证网络连通正常</li><li>保证磁盘空间、cpu、内存足够</li></ol></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.2cto.com/kf/201804/736770.html" target="_blank" rel="noopener">RabbitMQ简介、信道（channel）</a></p><p><a href="https://www.cnblogs.com/diegodu/p/4971586.html" target="_blank" rel="noopener">RabbitMQ基础概念详细介绍</a></p><p><a href="https://www.cnblogs.com/luxiaoxun/p/3918054.html" target="_blank" rel="noopener">RabbitMQ的几种典型使用场景</a></p><p><a href="https://blog.csdn.net/qq_33314107/article/details/80172042" target="_blank" rel="noopener">AMQP介绍</a></p><p><a href="https://blog.csdn.net/WoogeYu/article/details/51119101" target="_blank" rel="noopener">RabbitMQ分布式集群架构</a></p><p><a href="https://juejin.im/post/5b586b125188257bcb59005e#heading-1" target="_blank" rel="noopener">RabbitMQ系列（六）你不知道的RabbitMQ集群架构全解</a></p><p><a href="https://www.jianshu.com/p/6376936845ff" target="_blank" rel="noopener">消息中间件—RabbitMQ（集群原理与搭建篇)</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git合并不同url的项目</title>
      <link href="/git-merge-remote-url/"/>
      <url>/git-merge-remote-url/</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jan 24 2019 13:39:42 GMT+0800 (China Standard Time) --><p>摘要：为了让项目能实现Git+Gerrit+Jenkin的持续集成，我们把项目从Git上迁移到了Gerrit上，发现有的同事在老Git提交代码，因为Gerrit做了同步，在Gerrit上有新提交的时候就会刷新老git，这样就会把他提交的代码冲掉。这个时候我就必须要在两个相似项目之间合并提交了。</p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="添加以共存"><a href="#添加以共存" class="headerlink" title="添加以共存"></a>添加以共存</h2><p><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686ef20b711672e?w=1092&amp;h=90&amp;f=png&amp;s=10526" alt="将老Git url加到我们新Git的本地"></p><ul><li>使用命令<code>git remote add [shortname] [url]</code>将老Git url加到我们新Git的本地</li><li>这里我把他取名为gitoa_web（随便取）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686ef22d105ee28?w=576&amp;h=143&amp;f=png&amp;s=21949" alt="查看"></p><ul><li>使用命令<code>git remot -v</code>查看远程仓库的情况</li><li>可以看到此处我们有三个远程仓库分别名为<code>gerrit</code>、 <code>gitoa_web</code>、<code>origin</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686ef2485e022a2?w=486&amp;h=125&amp;f=png&amp;s=16805" alt="同步代码"></p><ul><li>使用命令<code>git fetch gitoa_web</code>刷新远程仓库到本地</li><li>字符串 <code>gitoa_web</code> 指代对应的仓库地址了.比如说,要抓取所有 <code>gitoa_web</code> 有的,但本地仓库没有的信息,可以用</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686ef2c91c6e074?w=567&amp;h=340&amp;f=png&amp;s=43531" alt="合并项目"></p><ul><li>使用命令<code>git merge gitoa_web/master</code>合并项目</li><li><code>gitoa_web</code>是指代仓库，<code>master</code>指代分支，当然如果有需要也可以合并别的分支过来<br><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686ef4ab42b6dae?w=2062&amp;h=1062&amp;f=png&amp;s=1064087" alt="报错"></li><li>发现不同email地址错误不能成功提交</li><li>因为这个<code>commit</code>不是我的</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686ef622820472e?w=2048&amp;h=370&amp;f=png&amp;s=356101" alt="修正错误"></p><ul><li>把email地址更新成我的</li><li>再提交就成功了</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>知识点：</p><ol><li><code>git merge</code>还可以合并其他项目的到本项目</li><li><code>git fetch 仓库名</code>可以指定同步哪个仓库</li><li><code>git remot -v</code>查看本地有哪些远程仓库的情况，包含各个仓库url</li></ol><p>本次我们对以下命令加深了理解<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote                                    <span class="comment">#不带参数，列出已经存在的远程分支</span></span><br><span class="line">git remote -v                                 <span class="comment">#(-v是–verbose 的简写,取首字母)列出详细信息，在每一个名字后面列出其远程url</span></span><br><span class="line">git remote add [shortname] [url]              <span class="comment">#添加远程仓库</span></span><br><span class="line">git fetch origin                              <span class="comment">#字符串 origin 指代对应的仓库地址了.比如说,要抓取所有 origin 有的,但本地仓库没有的信息,可以用</span></span><br></pre></td></tr></table></figure><p></p><p>ps: 这里<code>git remote add</code>以后，我认为还能用<code>cherry-pick</code>来加不同仓库的<code>commit</code>过来，有兴趣的朋友可以自己尝试。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> git教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络虚拟化技术——虚拟专用网 VPN</title>
      <link href="/VPN/"/>
      <url>/VPN/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jan 21 2019 14:21:12 GMT+0800 (China Standard Time) --><p>摘要：在虚拟化技术中，网络是必不可少的一个，它从上到下贯穿全局；它建网快速方便、容易对网络维护和管理、高可用、租户隔离等优点是企业管理、节约成本的秘诀，是网络安全的守门员。我们这一章说VPN，利用公用网络架设专用网络，实现在远程也可以安全的访问内部网络，可以理解为虚拟出来的企业内部专线，是一种安全性很高的技术。当然了，私人可以使用他来做科学上网的工具。</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p></blockquote><h1 id="常见的vpn协议"><a href="#常见的vpn协议" class="headerlink" title="常见的vpn协议"></a>常见的vpn协议</h1><p>VPN的隧道协议主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在<a href="https://baike.baidu.com/item/OSI/5520" target="_blank" rel="noopener">OSI</a>模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="远程访问虚拟网（AccessVPN）"><a href="#远程访问虚拟网（AccessVPN）" class="headerlink" title="远程访问虚拟网（AccessVPN）"></a>远程访问虚拟网（AccessVPN）</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/iqa9rmt2ro.jpeg" alt="外网vpn访问公司内网"></p><p>利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。原理是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。这中间为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。</p><p>有了数据加密，就可以认为数据是在一条<strong>专用的数据链路</strong>上进行安全传输，就如同专门架设了一个专用网络一样，但<strong>实际上</strong>VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其<strong>实质上</strong>就是利用加密技术在公网上封装出一个数据通讯隧道。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/yxq28hh8i0.png" alt="vpn访问外网"></p><p>另一个场景就是我们比较常见的，由于我国<a href="https://zh.wikipedia.org/wiki/%25E4%25B8%25AD%25E8%258F%25AF%25E4%25BA%25BA%25E6%25B0%2591%25E5%2585%25B1%25E5%2592%258C%25E5%259C%258B%25E7%25B6%25B2%25E7%25B5%25A1%25E5%25AF%25A9%25E6%259F%25A5" target="_blank" rel="noopener">对海外网络的限制及屏蔽</a>,很多时候个人用户、外资公司、学术单位想要连回海外网站就要自行架设VPN或采用付费的VPN服务。</p><h2 id="企业内部虚拟网（IntranetVPN）"><a href="#企业内部虚拟网（IntranetVPN）" class="headerlink" title="企业内部虚拟网（IntranetVPN）"></a>企业内部虚拟网（IntranetVPN）</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/80ft38ci9g.jpeg" alt="企业内部虚拟网"></p><p>Intranet VPN服务即企业的总部与分支机构间通过VPN虚拟网进行网络连接。随着企业的跨地区、国际化经营，这是绝大多数大、中型企业所必需的。如果要进行企业内部各分支机构的互联，使用Intranet VPN是很好的方式。这种VPN是通过<strong>公用因特网或者第三方专用网</strong>进行连接的，有条件的企业可以采用光纤作为传输介质。它的特点就是容易建立连接、连接速度快，最大特点就是它为各分支机构提供了整个网络的访问权限。</p><p>IntranetVPN通过一个使用专用连接的共享基础设施，连接企业总部、远程办事处和分支机构。企业拥有与专用网络的相同政策，包括安全、服务质量(QoS)、可管理性和可靠性。</p><h2 id="企业扩展虚拟网（ExtranetVPN）"><a href="#企业扩展虚拟网（ExtranetVPN）" class="headerlink" title="企业扩展虚拟网（ExtranetVPN）"></a>企业扩展虚拟网（ExtranetVPN）</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/3sgnujfzvy.jpeg" alt=""></p><p>Extranet VPN服务即企业间发生收购、兼并或企业间建立战略联盟后，使不同企业网通过公网来构筑的虚拟网。如果是需要提供B2B电子商务之间的安全访问服务，则可以考虑选用Extranet VPN。上图中下面那个人就代表客户、合作伙伴。</p><blockquote><p>随着信息时代的到来，各个企业越来越重视各种信息的处理。希望可以提供给客户最快捷方便的信息服务，通过各种方式了解客户的需要各个企业之间的合作关系也越来越多，信息交换日益频繁。因特网为这样的一种发展趋势提供了良好的基础，而如何利用因特网进行有效的信息管理，是企业发展中不可避免的一个关键问题。利用VPN技术可以组建安全的Extranet，既可以向客户、合作伙伴提供有效的信息服务，又可以保证自身的内部网络的安全。<br>Extranet VPN通过一个使用专用连接的共享基础设施，将客户、供应商、合作伙伴或兴趣群体连接到企业内部网。企业拥有与专用网络的相同政策，包括安全、服务质量(QoS)、可管理性和可靠性。<br>Extranet VPN服务对用户的吸引力在于:能容易地对外部网进行部署和管理，外部网的连接可以使用与部署内部网和远端访问VPN相同的架构和协议进行部署。主要的不同是接入许可，外部网的用户被许可只有一次机会连接到其合作人的网络，并且只拥有部分网络资源访问权限，这要求企业用户对各外部用户进行相应访问权限的设定。</p></blockquote><h1 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>VPN能够让移动员工、远程员工、商务合作伙伴和其他人利用本地可用的高速宽带网连接（如DSL、有线电视或者WiFi网络）连接到企业网络。</li><li>设计良好的宽带VPN是模块化的和可升级的。这种能力意味着企业不用增加额外的基础设施就可以提供大量的容量和应用。</li><li>VPN能提供高水平的安全，使用高级的加密和身份识别协议保护数据避免受到窥探，阻止数据窃贼和其他非授权用户接触这种数据。</li><li>完全控制，虚拟专用网使用户可以利用ISP的设施和服务，同时又完全掌握着自己网络的控制权。用户只利用ISP提供的网络资源，对于其它的安全设置、网络管理变化可由自己管理。在企业内部也可以自己建立虚拟专用网。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>企业不能直接控制基于互联网的VPN的可靠性和性能。机构必须依靠提供VPN的互联网服务提供商保证服务的运行。这个因素使企业与互联网服务提供商签署一个服务级协议非常重要，要签署一个保证各种性能指标的协议。</li><li>企业创建和部署VPN线路并不容易。这种技术需要高水平地理解网络和安全问题，需要认真的规划和配置。因此，应该大多数选择互联网服务提供商负责运行VPN。</li><li>不同厂商的VPN产品和解决方案总是不兼容的，因为许多厂商不愿意或者不能遵守VPN技术标准。因此，混合使用不同厂商的产品可能会出现技术问题。另一方面，使用一家供应商的设备可能会提高成本。</li><li>当使用无线设备时，VPN有安全风险。在接入点之间漫游特别容易出问题。当用户在接入点之间漫游的时候，任何使用高级加密技术的解决方案都可能被攻破。</li></ul><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ul><li>VPN服务器：在大型局域网中，可以通过在网络中心搭建VPN服务器的方法实现VPN。（vpn服务上使用openvpn easy-rsa或其他方式 ）</li><li>软件VPN：可以通过专用的软件实现VPN。</li><li>硬件VPN：可以通过专用的硬件实现VPN。</li><li>集成VPN：某些硬件设备，如交换机、路由器、防火墙等，都含有VPN功能，但是一般拥有VPN功能的硬件设备通常都比没有这一功能的要贵。</li></ul><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><blockquote><p>L2TP协议和PPTP协议在数据传输过程中都存在一定安全隐患，基于IPSec协议的VPN技术可有效防止黑客入侵，保护用户的通信信息。因此，对于保密性要求较高的重要部门，建议选择使用基于IPSec协议实现的VPN，保证通信安全。</p></blockquote><h1 id="腾讯公有云产品-与-VPN"><a href="#腾讯公有云产品-与-VPN" class="headerlink" title="腾讯公有云产品 与 VPN"></a>腾讯公有云产品 与 VPN</h1><p><img src="https://ask.qcloudimg.com/http-save/3097464/y6rrquemwj.svg" alt="弹性混合云"></p><p>上图是腾讯云使用vpn连接私有云和公有云实现的弹性混合云服务，可以根据业务压力大小弹性伸缩。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/lklz746jud.svg" alt="云上灾备"></p><p>通过 VPN 连接同步云端和本地数据中心的数据，实现云上容灾，保证业务数据安全。</p><h1 id="法律上"><a href="#法律上" class="headerlink" title="法律上"></a>法律上</h1><ul><li>按我国法律规定不能以盈利为目的搭建vpn来连接internet</li><li>使用vpn上外网不能违背中国社会主义的法律或者违规道德规范</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://zh.wikipedia.org/wiki/%25E8%2599%259B%25E6%2593%25AC%25E7%25A7%2581%25E4%25BA%25BA%25E7%25B6%25B2%25E8%25B7%25AF" target="_blank" rel="noopener">wiki 虛擬私人網路</a></p><p><a href="https://baike.baidu.com/item/%25E8%2599%259A%25E6%258B%259F%25E4%25B8%2593%25E7%2594%25A8%25E7%25BD%2591%25E7%25BB%259C/8747869?fromtitle=VPN&amp;fromid=382304&amp;fr=aladdin#2" target="_blank" rel="noopener">百度百科 虚拟专用网络</a></p><p><a href="https://baijiahao.baidu.com/s?id=1617357848025009719&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">虚拟专用网络(VPN)的安全性</a></p><p><a href="http://www.rfwireless-world.com/Terminology/Intranet-VPN-vs-Extranet-VPN.html" target="_blank" rel="noopener">Difference between Intranet VPN and Extranet VPN | Intranet VPN vs Extranet VPN</a></p><p><a href="http://netsecurity.51cto.com/art/201009/225085.htm" target="_blank" rel="noopener">简析三种VPN服务类型</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 虚拟网络 </category>
          
          <category> vpn </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
            <tag> 网络 </tag>
            
            <tag> 虚拟网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>qq邮箱高频率邮件来源自动屏蔽的信任办法</title>
      <link href="/qqmail-filter/"/>
      <url>/qqmail-filter/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：我们在使用QQ邮箱作为告警接收邮箱的时候，用了一段时间发现，告警邮箱再也没办法发出来了，非常的困惑，检查了全部的网络策略、dns、smtp服务器配置都没有问题，原来是qq邮箱的自动策略，在此记录。</p><a id="more"></a><h1 id="python-测试smtp脚本"><a href="#python-测试smtp脚本" class="headerlink" title="python 测试smtp脚本"></a>python 测试smtp脚本</h1><p>我们使用python的测试smtp脚本，无密码时使用，有密码时去掉注释<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr(( \</span><br><span class="line">        Header(name, <span class="string">'utf-8'</span>).encode(), \</span><br><span class="line">        addr.encode(<span class="string">'utf-8'</span>) <span class="keyword">if</span> isinstance(addr, unicode) <span class="keyword">else</span> addr))</span><br><span class="line"></span><br><span class="line">from_addr = <span class="string">'root@mymail.com'</span></span><br><span class="line">to_addr = [<span class="string">'xxxx@163.com'</span>,<span class="string">'xxx.qq.com'</span>] </span><br><span class="line"><span class="comment">#password = ''</span></span><br><span class="line">smtp_server = <span class="string">'mymail'</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">'hello, send by Python...'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">u'monitorcloud &lt;%s&gt;'</span> % from_addr)</span><br><span class="line">msg[<span class="string">'To'</span>] = _format_addr(<span class="string">u'管理员 &lt;%s&gt;'</span> % to_addr)</span><br><span class="line">msg[<span class="string">'Subject'</span>] = Header(<span class="string">u'来自SMTP的问候……'</span>, <span class="string">'utf-8'</span>).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#server.starttls()</span></span><br><span class="line"><span class="comment">#server.login(from_addr, password)</span></span><br><span class="line">server.sendmail(from_addr, to_addr, msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure><p></p><h1 id="发送情景"><a href="#发送情景" class="headerlink" title="发送情景"></a>发送情景</h1><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f72ea19a9a74?w=2552&amp;h=930&amp;f=png&amp;s=1092939" alt="发送到163邮箱"></p><ul><li>发送到163邮箱是成功的</li><li>但是发送到qq邮箱不行了</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f752c9eb74d3?w=2838&amp;h=268&amp;f=png&amp;s=244975" alt="maillog"></p><ul><li>查/var/log/maillog 发现有如上报错信息</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f73e2c8c9ccd?w=2576&amp;h=896&amp;f=png&amp;s=630368" alt="qqfilter"></p><ul><li>查QQ邮箱没有收到邮件</li><li>有如上拦截信息</li></ul><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f76b9333d01c?w=2984&amp;h=2036&amp;f=png&amp;s=1709222" alt="反垃圾"></p><ul><li>进入反垃圾设置地址白名单和域名白名单</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f7c026c9c2d2?w=1180&amp;h=946&amp;f=png&amp;s=254506" alt="域名白名单"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f7d025cab767?w=1194&amp;h=630&amp;f=png&amp;s=230034" alt="地址白名单"></p><h1 id="测试成功"><a href="#测试成功" class="headerlink" title="测试成功"></a>测试成功</h1><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f7df3696020c?w=2536&amp;h=1130&amp;f=png&amp;s=695138" alt="qq邮箱收件结果"></p><h1 id="附SMTP错误码"><a href="#附SMTP错误码" class="headerlink" title="附SMTP错误码"></a>附SMTP错误码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">·The server rejected the message: 554 DT:SPM smtp2 Cannot send message 451 MI:SFQ 0,smtp9,DcCowLD735x2fG1MgWLhAA--.11609S2 1282243</span><br><span class="line">邮件服务器拒绝发送邮件，判断为发送垃圾邮件。建议您检查邮件内容，是否包含一些比较敏感的内容。</span><br><span class="line">·Cannot send message data: 550 5.4.5 Daily sending quota exceeded. q31sm4299413ybk.1</span><br><span class="line">不能发送邮件，每日发送额度用完。建议您控制此邮箱每天的发送量，今天发送量已经用完，需要明天才能继续发送。</span><br><span class="line">·Recipient rejected: &lt;xxx@yahoo.com&gt;: 553 5.7.1 &lt; xx@xx.com &gt;: Sender address rejected: not owned by user xx@xx.com</span><br><span class="line">发送邮箱地址被拒绝。建议您换个邮箱发送。</span><br><span class="line">·Recipient rejected: &lt;xxx@yahoo.co.uk&gt;: 550 Your mailbox is full？</span><br><span class="line">您的邮箱空间已满不能再发送邮件。建议您整理邮箱中的邮件。</span><br><span class="line">·Cannot send message: 451 sorry, server closed？</span><br><span class="line">不能发送，服务器已经关闭。建议您稍候再尝试邮件发送操作 。</span><br><span class="line">·Recipient rejected: &lt;xxx@yahoo.com&gt;: 500 Error: bad syntax</span><br><span class="line">收件人地址格式不正确。请核实收件人地址是否正确。</span><br><span class="line">·421 Service not available, closing transmission channel (This may be a reply to any <span class="built_in">command</span> <span class="keyword">if</span> the service knows it must shut down)</span><br><span class="line">服务暂时不可用！建议您稍候再尝试发送。</span><br><span class="line">·450 Requested mail action not taken: mailbox unavailable (E.g., mailbox busy)</span><br><span class="line">邮件发送请求没有发生：邮箱不可用（例如，邮箱忙）！建议您稍候再尝试！</span><br><span class="line">·451 Requested action aborted: <span class="built_in">local</span> error <span class="keyword">in</span> processing</span><br><span class="line">请求的邮件操作被中止：本地进程错误。建议您重新启动邮件营销助手来尝试发送</span><br><span class="line">·550 Requested action not taken: mailbox unavailable (E.g., mailbox not found, no access)？</span><br><span class="line">请求的操作未被执行：邮箱不可用（例如，邮箱未找到，不能访问）。建议您稍候再尝试。</span><br><span class="line">·552 Requested mail action aborted: exceeded storage allocation</span><br><span class="line">请求的邮件操作中止：超出存储分配。建议您整理邮箱中的邮件。</span><br><span class="line">· 553 Requested action not taken: mailbox name not allowed (E.g., mailbox syntax incorrect)</span><br><span class="line">请求的操作未被执行：不允许的邮箱名称（例如，邮箱的语法不正确的）；</span><br><span class="line">·550 5.3.4 Requested action not taken; This account is currently blocked from sending messages. If you don<span class="string">'t think you'</span>ve violated the Windows Live Terms of Use, please contact customer support</span><br><span class="line">请求不采取行动，这是目前从帐户发送的邮件被阻止。如果您不认为您已经违反了Windows Live的使用条款，请联系其客户支持。</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/a11085013/article/details/10528121" target="_blank" rel="noopener">常见SMTP发送失败原因列表</a><br><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832745198026a685614e7462fb57dbf733cc9f3ad000" target="_blank" rel="noopener">SMTP发送邮件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> qq邮箱策略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smtp </tag>
            
            <tag> qq邮箱 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何用RSS订阅？</title>
      <link href="/how_to_subscribe_RSS/"/>
      <url>/how_to_subscribe_RSS/</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jan 24 2019 13:39:42 GMT+0800 (China Standard Time) --><p>摘要：我们常常会有订阅别人文章的需求，有更新的时候希望能有提醒的功能，RSS就是这样一个订阅的方式。很多网站上看到RSS的入口，点进去以后总是显示一堆的XML代码，我们来看看怎么使用这个功能。在本次的学习过后你将学会使用RSS来订阅别人的网站，而且你还能学会给不能用RSS网站的创建订阅，比如学校的教务网站发布重要的通知、新闻通知、公司网站通知、包括好看的电视剧更新就都能被你订阅了。</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。<br>Really Simple Syndication“简易信息聚合”就是RSS的英文原意。把新闻标题、摘要（Feed）、内容按照用户的要求，“送”到用户的桌面就是RSS的目的。RSS一词有时候大体上意为社会性书签，包括各种RSS的不同格式。例如，Blogspace对使用网摘于一集成器内之动作标为RSS info和RSS reader。虽然它的第一个句子就包含明确的Atom格式：“RSS和Atom文件能够用简单的格式从网站更新消息至你的计算机！”</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>可以有选择地浏览您感兴趣的以及与您的工作相关的新闻。</li><li>通过使用 RSS，您可以把需要的信息从不需要的信息（兜售信息，垃圾邮件等）中分离出来。</li><li>通过使用 RSS，您可以创建自己的新闻频道，并将之发布到因特网。</li><li>使用客户端，可以在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。</li></ul><h1 id="如何订阅"><a href="#如何订阅" class="headerlink" title="如何订阅"></a>如何订阅</h1><h2 id="浏览器方式"><a href="#浏览器方式" class="headerlink" title="浏览器方式"></a>浏览器方式</h2><p>这里介绍chrome的扩展程序，其他的浏览器大同小异。</p><ol><li>打开<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">Chrome网上商店</a>,并按装feeder插件</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/4cwq1yx9bw.png" alt="Chrome网上商店"></p><ol><li>安装完成后会自动提示注册一个账号，按照提示注册完成登录即可。</li><li>完成插件安装之后，在浏览博客或者其他网站时，点击RSS订阅图标，就可以正常订阅成功。</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/81z2j064qu.png" alt="RSS按钮"></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ikutrx9x73.png" alt="点击订阅"></p><ol><li>当有文章更新的时候，就会在浏览器右上角提示,打开后就可以看到全部订阅者了</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/n711xwqvvb.png" alt="chrome浏览器右上角提示"></p><ol><li>可以在<a href="https://feeder.co/reader" target="_blank" rel="noopener">reader</a>看到比较舒服的阅读方式，也可以直接右上角打开文章来看<br><img src="https://ask.qcloudimg.com/http-save/3097464/zd7rgqhacx.png" alt="优雅的阅读"></li><li>在feeder的设置页面可以针对每个订阅者设置,可以选择刷新周期，提示方式（不过Email提示是要收费的），还可以导出你的订阅让好友来导入</li></ol><p><img src="https://ask.qcloudimg.com/http-save/3097464/jx4wlaq7hk.png" alt="配置"></p><h2 id="客户端方式"><a href="#客户端方式" class="headerlink" title="客户端方式"></a>客户端方式</h2><h3 id="阅读器推荐"><a href="#阅读器推荐" class="headerlink" title="阅读器推荐"></a>阅读器推荐</h3><p>因为我觉得浏览器端的就够我用了，就没用过客户端的，下面是网上摘录的客户端阅读器</p><ul><li>irreade<br>最好用，支持多平台。</li><li>NewsGator Online<br>一个免费的在线 RSS 阅读器。包含 Outlook 同步，通过 Media Center Edition 查看电视内容，以及 blog 和标题的发布。</li><li>RssReade<br>基于 Windows 的免费 RSS 阅读器。支持 RSS versions 0.9x、1.0 以及 2.0 和 Atom 0.1, 0.2 以及 0.3。</li><li>FeedDemon<br>基于 Windows 的 RSS 阅读器。使用很简便，界面很有条理。可以免费下载！</li><li>blogbot<br>一个针对 Outlook 或 Internet Explorer 的 RSS 阅读器插件。针对 Internet Explorer 的简化版是免费的。</li></ul><h3 id="我已经有一个-RSS-阅读器了，接下来怎么做呢？"><a href="#我已经有一个-RSS-阅读器了，接下来怎么做呢？" class="headerlink" title="我已经有一个 RSS 阅读器了，接下来怎么做呢？"></a>我已经有一个 RSS 阅读器了，接下来怎么做呢？</h3><p>点击您希望阅读的 RSS feed 旁边的橙色小图标 或 ，把浏览器窗口的 URL 拷贝粘贴到您的 RSS 阅读器即可。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>事实上我们根本不用关心RSS的语法是什么，因为多的是自动RSS的工具，如果使用的开源blog通常也会提供RSS自动生成的插件，以下是2.0版本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">rss</span> <span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">channel</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>pzqu的自言自语<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span>&gt;</span>https://qupzhi.com<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>我的描述<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>如何用RSS订阅？<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span>&gt;</span>https://qupzhi.com/how_to_subscribe_RSS<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>摘要.....<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span>...略<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">channel</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">rss</span>&gt;</span></span><br></pre></td></tr></table></figure><p>感兴趣的同学可以看看<a href="http://www.rssboard.org/rss-2-0-1" target="_blank" rel="noopener">官网</a>,不同的版本语法可能略有差异。</p><h1 id="如何让你的网站支持RSS"><a href="#如何让你的网站支持RSS" class="headerlink" title="如何让你的网站支持RSS"></a>如何让你的网站支持RSS</h1><p>建议使用一些直接就支持自动生成RSS的开源blog，像WordPress、Blogger、Radio、Hexo，这里提供一个自动给网站生成RSS的方法，有了这种神器以后任何东西你都可以订阅了，比如电影网站，新闻网站，公司网站，学校通知。</p><ul><li>注意科学上网<br><a href="http://www.feed43.com" target="_blank" rel="noopener">http://www.feed43.com</a>提取HTML中关键内容进入创建页面，输入你想生成RSS的网址，这样可以拿到这个网站的HTML</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/i1un2urb77.png" alt="输入你想生成RSS的网址"></p><h2 id="找到内容所在-HTML-字段规律。不同的文章会有相同的代码段落，比如我这里-为了好看我格式化了下"><a href="#找到内容所在-HTML-字段规律。不同的文章会有相同的代码段落，比如我这里-为了好看我格式化了下" class="headerlink" title="找到内容所在 HTML 字段规律。不同的文章会有相同的代码段落，比如我这里(为了好看我格式化了下)"></a>找到内容所在 HTML 字段规律。不同的文章会有相同的代码段落，比如我这里(为了好看我格式化了下)</h2><p><strong>标题和url</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;</span><br><span class="line">    &lt;a class=&quot;post-title-link&quot; href=&quot;https://qupzhi.com/mariadb-better/&quot; itemprop=&quot;url&quot;&gt;</span><br><span class="line">        mariadb 内存占用优化</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><strong>创建时间</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">title</span>=<span class="string">"创建于"</span> <span class="attr">itemprop</span>=<span class="string">"dateCreated datePublished"</span> <span class="attr">datetime</span>=<span class="string">"2019-01-09T22:25:00+08:00"</span>&gt;</span></span><br><span class="line">    2019-01-09</span><br><span class="line"><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>摘要</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body"</span> <span class="attr">itemprop</span>=<span class="string">"articleBody"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        摘要：我们在使用mariadb的时候发现有时候不能启动起来，在使用过程中mariadb占用的内存很大，在这里学习下mariadb与内存相关的配置项，对mariadb进行调优。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>我们取到了标题、创建时间、摘要等比较关键的东西</li></ul><h2 id="精简提取规则代码"><a href="#精简提取规则代码" class="headerlink" title="精简提取规则代码"></a>精简提取规则代码</h2><p>定义规则找到网页中你想要看的项目的列表代码(也就是文章的代码)，将你想要的字段用&#123;%&#125;代替为参数，不需要的可以用&#123;*&#125;代替，点击Extract，改到满意为止。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/g0ykq5na2b.png" alt="输入规则"></p><p>这里的规则让我试到头疼，但是慢慢试就是能试出来的要注意</p><ul><li>一行一个规则比较清晰，这个系统也支持</li><li>每行结束加一个&#123;*&#125;来忽略规则间不要的东西，如果有空格回车的也加上</li><li>一个规则试好了再试另一个规则</li><li>可以借助<a href="http://www.bejson.com/jshtml_format/" target="_blank" rel="noopener">HTML格式化工具</a></li></ul><p><strong>我的匹配结果</strong></p><p><img src="https://ask.qcloudimg.com/http-save/3097464/ccv3f6jjo9.png" alt="我的匹配结果"></p><p>如上图所示，每一篇文章的标题、链接、摘要、时间都已经成功抓取了。</p><h2 id="完善RSS源格式"><a href="#完善RSS源格式" class="headerlink" title="完善RSS源格式"></a>完善RSS源格式</h2><p>我们要完善好源格式，才能正确的输出源，在上面的语法那一节我们也说过了，一个完整的源要有网站title，link，description还要有每个文章的tile,link,time,description。</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/mvj8nl1hns.png" alt="网站"></p><p>来看文章的要怎么填</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/flbly0vpja.png" alt="变量"></p><p>变化的字段用 &#123;%+数字&#125; 的形式标示出来,也就是上面我的匹配结果里展示的内容，不同的 &#123;%+数字&#125; 之间可以填写随意的文字、符号过渡，如下</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/gkcak955h0.png" alt="文章"></p><p>ok的话点Preview就可以生成了</p><p>看看结果</p><p><img src="https://ask.qcloudimg.com/http-save/3097464/twrpg9yd72.png" alt="结果"></p><h2 id="获得你的RSS-URL"><a href="#获得你的RSS-URL" class="headerlink" title="获得你的RSS URL"></a>获得你的RSS URL</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/uc4h1o5ylr.png" alt="我的RSS URL"></p><ul><li>Feed URL就是你的RSS地址了，你可以放在任何地方</li><li>Edit URL就是以后用来编辑你RSS的页面了</li><li>下面可以把这个url的好记一些<br>好了，这个url放到文章你的rss订阅器里就可以订阅了</li></ul><p><img src="https://ask.qcloudimg.com/http-save/3097464/q0dhs7s55x.png" alt=""></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p><img src="https://ask.qcloudimg.com/http-save/3097464/pgqmtke7w8.png" alt=""></p><ul><li>你可以免费使用 Feed43 做 RSS 源</li><li>免费版不限制创建多少个rss源但是会有广告，每个源最大只能有250KB，更新后6小时才能刷新一次，最多100篇文章，匹配规则在30个内。</li><li>其实大部分都够用了，这个是<a href="https://feed43.com/upgrade.html#personal" target="_blank" rel="noopener">付费页面</a></li></ul><h2 id="提供RSS"><a href="#提供RSS" class="headerlink" title="提供RSS"></a>提供RSS</h2><p>在希望向外界提供 RSS的页面放一个RSS的图标，然后向这个按钮添加一个指向 RSS 文件的链接。代码应该类似这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://qupzhi.com/atom.xml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://user-gold-cdn.xitu.io/2019/1/11/1683b8918abb8f90?w=36&amp;h=14&amp;f=gif&amp;s=1036"</span> <span class="attr">width</span>=<span class="string">"36"</span> <span class="attr">height</span>=<span class="string">"14"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="附Hexo匹配规则"><a href="#附Hexo匹配规则" class="headerlink" title="附Hexo匹配规则"></a>附Hexo匹配规则</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"post-title-link"</span> <span class="attr">href</span>=<span class="string">"&#123;%&#125;"</span> <span class="attr">itemprop</span>=<span class="string">"url"</span>&gt;</span>&#123;%&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#123;*&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">title</span>=<span class="string">"创建于"</span> <span class="attr">itemprop</span>=<span class="string">"dateCreated datePublished"</span> <span class="attr">datetime</span>=<span class="string">"&#123;*&#125;"</span>&gt;</span>&#123;%&#125;<span class="tag">&lt;/<span class="name">time</span>&gt;</span>&#123;*&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body"</span> <span class="attr">itemprop</span>=<span class="string">"articleBody"</span>&gt;</span>&#123;*&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;%&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#123;*&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>找到一个非常非常好用的，rss源基本所有主要的网站都能用了<br><a href="https://docs.rsshub.app" target="_blank" rel="noopener">rsshub</a></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://zh.wikipedia.org/wiki/RSS" target="_blank" rel="noopener">wiki RSS</a></p><p><a href="http://www.runoob.com/rss/rss-tutorial.html" target="_blank" rel="noopener">RSS 教程</a></p><p><a href="https://ihaoming.top/archives/644dacb3.html" target="_blank" rel="noopener">使用RSS订阅</a></p><p><a href="https://baijiahao.baidu.com/s?id=1617627976106767760&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">自动生成RSS</a></p><p><a href="https://sspai.com/post/34320" target="_blank" rel="noopener">利用 Feed43，将任意网页制作成 RSS 订阅源 | 一日一技</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> RSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> RSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mariadb 内存占用优化</title>
      <link href="/mariadb-better/"/>
      <url>/mariadb-better/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：我们在使用mariadb的时候发现有时候不能启动起来，在使用过程中mariadb占用的内存很大，在这里学习下mariadb与内存相关的配置项，对mariadb进行调优。</p><a id="more"></a><h1 id="查询最高内存占用"><a href="#查询最高内存占用" class="headerlink" title="查询最高内存占用"></a>查询最高内存占用</h1><p>使用以下命令可以知道mysql的配置使用多少 RAM<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT ( @@key_buffer_size</span><br><span class="line">+ @@query_cache_size</span><br><span class="line">+ @@innodb_buffer_pool_size</span><br><span class="line">+ @@innodb_additional_mem_pool_size</span><br><span class="line">+ @@innodb_log_buffer_size</span><br><span class="line">+ @@max_connections * ( @@read_buffer_size</span><br><span class="line">+ @@read_rnd_buffer_size</span><br><span class="line">+ @@sort_buffer_size</span><br><span class="line">+ @@join_buffer_size</span><br><span class="line">+ @@binlog_cache_size</span><br><span class="line">+ @@thread_stack</span><br><span class="line">+ @@tmp_table_size</span><br><span class="line">)</span><br><span class="line">) / (1024 * 1024 * 1024) AS MAX_MEMORY_GB;</span><br></pre></td></tr></table></figure><p></p><p>可以使用<a href="http://www.mysqlcalculator.com/" target="_blank" rel="noopener">mysql计算器</a>来计算内存使用</p><p>下面是理论，可以直接到<a href="#mariadb 推荐配置">推荐配置</a></p><h1 id="如何调整配置"><a href="#如何调整配置" class="headerlink" title="如何调整配置"></a>如何调整配置</h1><h2 id="key-buffer-size（MyISAM索引用）"><a href="#key-buffer-size（MyISAM索引用）" class="headerlink" title="key_buffer_size（MyISAM索引用）"></a>key_buffer_size（MyISAM索引用）</h2><blockquote><p>指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。为了最小化磁盘的 I/O ， MyISAM 存储引擎的表使用键高速缓存来缓存索引，这个键高速缓存的大小则通过 key-buffer-size 参数来设置。如果应用系统中使用的表以 MyISAM 存储引擎为主，则应该适当增加该参数的值，以便尽可能的缓存索引，提高访问的速度。</p></blockquote><h3 id="怎么设"><a href="#怎么设" class="headerlink" title="怎么设"></a>怎么设</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'key_read%'</span>;</span><br><span class="line"></span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Key_read_requests | 27813678764 |</span><br><span class="line">| Key_reads | 6798830 |</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。</li><li>比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'%created_tmp_disk_tables%'</span>;</span><br></pre></td></tr></table></figure><ul><li>key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。</li><li>对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M）</li></ul><p><strong>另一个参考如下</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show global status like <span class="string">'key_blocks_u%'</span>;</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------------+-------------+</span><br><span class="line">| Key_blocks_unused | 0 |</span><br><span class="line">| Key_blocks_used | 413543 |</span><br><span class="line">+------------------------+-------------+</span><br></pre></td></tr></table></figure><p></p><p>Key_blocks_unused表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置：</p><ul><li>可以根据此工式来动态的调整<code>Key_blocks_used / (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><ul><li>查询存储引擎</li></ul><h2 id="innodb-buffer-pool-size-（innodb索引用）"><a href="#innodb-buffer-pool-size-（innodb索引用）" class="headerlink" title="innodb_buffer_pool_size （innodb索引用）"></a>innodb_buffer_pool_size （innodb索引用）</h2><blockquote><p>这个参数和MyISAM的<code>key_buffer_size</code>有相似之处，但也是有差别的。这个参数主要缓存innodb表的索引，数据，插入数据时的缓冲。为Innodb加速优化首要参数。<br>该参数分配内存的原则：这个参数默认分配只有8M，可以说是非常小的一个值。</p><ul><li>如果是专用的DB服务器，且以InnoDB引擎为主的场景，通常可设置物理内存的50%，这个参数不能动态更改，所以分配需多考虑。分配过大，会使Swap占用过多，致使Mysql的查询特慢。</li><li>如果是非专用DB服务器，可以先尝试设置成内存的1/4，如果有问题再调整</li></ul></blockquote><h2 id="query-cache-size（查询缓存）"><a href="#query-cache-size（查询缓存）" class="headerlink" title="query_cache_size（查询缓存）"></a>query_cache_size（查询缓存）</h2><blockquote><p>缓存机制简单的说就是缓存sql文本及查询结果，如果运行相同的sql，服务器直接从缓存中取到结果，而不需要再去解析和执行sql。如果表更改了，那么使用这个表的所有缓冲查询将不再有效，查询缓存值的相关条目被清空。更改指的是表中任何数据或是结构的改变，包括INSERT、UPDATE、DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE等，也包括那些映射到改变了的表的使用MERGE表的查询。显然，这对于频繁更新的表，查询缓存是不适合的，而对于一些不常改变数据且有大量相同sql查询的表，查询缓存会节约很大的性能。</p><ul><li>注意：如果你查询的表更新比较频繁，而且很少有相同的查询，最好不要使用查询缓存。因为这样会消耗很大的系统性能还没有任何的效果</li></ul></blockquote><h3 id="要不要打开？"><a href="#要不要打开？" class="headerlink" title="要不要打开？"></a>要不要打开？</h3><p>先设置成这样跑一段时间<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_size=128M </span><br><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure><p></p><p>看看命中结果来进行进一步的判断<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'%Qcache%'</span>;</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Qcache_free_blocks      | 669       |</span><br><span class="line">| Qcache_free_memory      | 132519160 |</span><br><span class="line">| Qcache_hits             | 1158      |</span><br><span class="line">| Qcache_inserts          | 284824    |</span><br><span class="line">| Qcache_lowmem_prunes    | 2741      |</span><br><span class="line">| Qcache_not_cached       | 1755767   |</span><br><span class="line">| Qcache_queries_in_cache | 579       |</span><br><span class="line">| Qcache_total_blocks     | 1853      |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>Qcache_free_blocks:表示查询缓存中目前还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能在一定的时间进行整理。<br>Qcache_free_memory:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。<br>Qcache_hits:表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。<br>Qcache_inserts: 表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数，次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。<br>Qcache_lowmem_prunes:该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。<br>Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。<br>Qcache_queries_in_cache:当前缓存中缓存的查询数量。<br>Qcache_total_blocks:当前缓存的block数量。</p></blockquote><ul><li><p>我们可以看到现网命中1158，未缓存的有1755767次，说明我们这个系统命中的太少了，表变动比较多，不什么开启这个功能</p><h3 id="涉及参数"><a href="#涉及参数" class="headerlink" title="涉及参数"></a>涉及参数</h3></li><li><p>query_cache_limit：允许 Cache 的单条 Query 结果集的最大容量，默认是1MB，超过此参数设置的 Query 结果集将不会被 Cache</p></li><li>query_cache_min_res_unit：设置 Query Cache 中每次分配内存的最小空间大小，也就是每个 Query 的 Cache 最小占用的内存空间大小</li><li>query_cache_size：设置 Query Cache 所使用的内存大小，默认值为0，大小必须是1024的整数倍，如果不是整数倍，MySQL 会自动调整降低最小量以达到1024的倍数</li><li>query_cache_type：控制 Query Cache 功能的开关，可以设置为0(OFF),1(ON)和2(DEMAND)三种，意义分别如下：<br>0(OFF)：关闭 Query Cache 功能，任何情况下都不会使用 Query Cache<br>1(ON)：开启 Query Cache 功能，但是当 SELECT 语句中使用的 SQL_NO_CACHE 提示后，将不使用Query Cache<br>2(DEMAND)：开启 Query Cache 功能，但是只有当 SELECT 语句中使用了 SQL_CACHE 提示后，才使用 Query Cache</li><li>query_cache_wlock_invalidate：控制当有写锁定发生在表上的时刻是否先失效该表相关的 Query Cache，如果设置为 1(TRUE)，则在写锁定的同时将失效该表相关的所有 Query Cache，如果设置为0(FALSE)则在锁定时刻仍然允许读取该表相关的 Query Cache。</li></ul><h2 id="innodb-additional-mem-pool-size（InnoDB内部目录大小）"><a href="#innodb-additional-mem-pool-size（InnoDB内部目录大小）" class="headerlink" title="innodb_additional_mem_pool_size（InnoDB内部目录大小）"></a>innodb_additional_mem_pool_size（InnoDB内部目录大小）</h2><p>InnoDB 字典信息缓存主要用来存放 InnoDB 存储引擎的字典信息以及一些 internal 的共享数据结构信息，也就是存放Innodb的内部目录，所以其大小也与系统中所使用的 InnoDB 存储引擎表的数量有较大关系。</p><p>这个值不用分配太大，通常设置16Ｍ够用了，默认8M，如果设置的内存大小不够，InnoDB 会自动申请更多的内存，并在 MySQL 的 Error Log 中记录警告信息。</p><h2 id="innodb-log-buffer-size-（日志缓冲）"><a href="#innodb-log-buffer-size-（日志缓冲）" class="headerlink" title="innodb_log_buffer_size （日志缓冲）"></a>innodb_log_buffer_size （日志缓冲）</h2><p>表示InnoDB写入到磁盘上的日志文件时使用的缓冲区的字节数，默认值为16M。一个大的日志缓冲区允许大量的事务在提交之前不用写日志到磁盘，所以如果有更新，插入或删除许多行的事务，则使日志缓冲区更大一些可以节省磁盘IO</p><p>通常最大设为64M足够</p><h2 id="max-connections-最大并发连接"><a href="#max-connections-最大并发连接" class="headerlink" title="max_connections (最大并发连接)"></a>max_connections (最大并发连接)</h2><p>MySQL的max_connections参数用来设置最大连接（用户）数。每个连接MySQL的用户均算作一个连接，max_connections的默认值为100。</p><ul><li>这个参数实际起作用的最大值（实际最大可连接数）为16384，即该参数最大值不能超过16384，即使超过也以16384为准；</li><li>增加max_connections参数的值，不会占用太多系统资源。系统资源（CPU、内存）的占用主要取决于查询的密度、效率等；</li><li>该参数设置过小的最明显特征是出现”Too many connections”错误</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'%max_connect%'</span>;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| extra_max_connections | 1     |</span><br><span class="line">| max_connect_errors    | 100   |</span><br><span class="line">| max_connections       | 2048  |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like <span class="string">'Threads%'</span>;</span><br><span class="line">+-------------------+---------+</span><br><span class="line">| Variable_name     | Value   |</span><br><span class="line">+-------------------+---------+</span><br><span class="line">| Threads_cached    | 0       |</span><br><span class="line">| Threads_connected | 1       |</span><br><span class="line">| Threads_created   | 9626717 |</span><br><span class="line">| Threads_running   | 1       |</span><br><span class="line">+-------------------+---------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到此时的并发数也就是Threads_connected=1，还远远达不到2048</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'open_files_limit'</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| open_files_limit | 65535 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>max_connections 还取决于操作系统对单进程允许打开最大文件数的限制<br>也就是说如果操作系统限制单个进程最大可以打开100个文件<br>那么 max_connections 设置为200也没什么用<br>MySQL 的 open_files_limit 参数值是在MySQL启动时记录的操作系统对单进程打开最大文件数限制的值<br>可以使用 show variables like ‘open_files_limit’; 查看 open_files_limit 值<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n</span><br><span class="line">65535</span><br></pre></td></tr></table></figure><p></p><p>或者直接在 Linux 下通过ulimit -n命令查看操作系统对单进程打开最大文件数限制 ( 默认为1024 )</p><h1 id="connection级内存参数-线程独享"><a href="#connection级内存参数-线程独享" class="headerlink" title="connection级内存参数(线程独享)"></a>connection级内存参数(线程独享)</h1><p>connection级参数，是在每个connection第一次需要使用这个buffer的时候，一次性分配设置的内存。</p><h2 id="排序性能"><a href="#排序性能" class="headerlink" title="排序性能"></a>排序性能</h2><p>mysql对于排序,使用了两个变量来控制sort_buffer_size和 max_length_for_sort_data, 不象oracle使用SGA控制. 这种方式的缺点是要单独控制,容易出现排序性能问题.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS like <span class="string">'%sort%'</span>;</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">| Variable_name             | Value  |</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">| Sort_merge_passes         | 0      |</span><br><span class="line">| Sort_priority_queue_sorts | 1409   |</span><br><span class="line">| Sort_range                | 0      |</span><br><span class="line">| Sort_rows                 | 843479 |</span><br><span class="line">| Sort_scan                 | 13053  |</span><br><span class="line">+---------------------------+--------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>如果发现<code>Sort_merge_passes</code>的值比较大，你可以考虑增加<code>sort_buffer_size</code> 来加速ORDER BY 或者GROUP BY 操作,不能通过查询或者索引优化的。我们这为0，那就没必要设置那么大。</li></ul><h2 id="读取缓存"><a href="#读取缓存" class="headerlink" title="读取缓存"></a>读取缓存</h2><p>read_buffer_size = 128K(默认128K)为需要全表扫描的MYISAM数据表线程指定缓存<br>read_rnd_buffer_size = 4M：(默认256K)首先，该变量可以被任何存储引擎使用，当从一个已经排序的键值表中读取行时，会先从该缓冲区中获取而不再从磁盘上获取。</p><h2 id="大事务binlog"><a href="#大事务binlog" class="headerlink" title="大事务binlog"></a>大事务binlog</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">'binlog_cache%'</span>;</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Variable_name         | Value    |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Binlog_cache_disk_use | 220840   |</span><br><span class="line">| Binlog_cache_use      | 67604667 |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p>Binlog_cache_disk_use表示因为我们binlog_cache_size设计的内存不足导致缓存二进制日志用到了临时文件的次数</p></li><li><p>Binlog_cache_use 表示 用binlog_cache_size缓存的次数</p></li><li><p>当对应的Binlog_cache_disk_use 值比较大的时候 我们可以考虑适当的调高 binlog_cache_size 对应的值</p></li><li><p>如上图，现网是32K，我们加到64K</p></li></ul><h2 id="join语句内存影响"><a href="#join语句内存影响" class="headerlink" title="join语句内存影响"></a>join语句内存影响</h2><p>如果应用中，很少出现join语句，则可以不用太在乎join_buffer_size参数的设置大小。</p><p>如果join语句不是很少的话，个人建议可以适当增大join_buffer_size到1MB左右，如果内存充足可以设置为2MB。</p><h2 id="线程内存影响"><a href="#线程内存影响" class="headerlink" title="线程内存影响"></a>线程内存影响</h2><p>Thread_stack：每个连接线程被创建时，MySQL给它分配的内存大小。当MySQL创建一个新的连接线程时，需要给它分配一定大小的内存堆栈空间，以便存放客户端的请求的Query及自身的各种状态和处理信息。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'%threads%'</span>;</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Variable_name           | Value   |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Delayed_insert_threads  | 0       |</span><br><span class="line">| Slow_launch_threads     | 0       |</span><br><span class="line">| Threadpool_idle_threads | 0       |</span><br><span class="line">| Threadpool_threads      | 0       |</span><br><span class="line">| Threads_cached          | 0       |</span><br><span class="line">| Threads_connected       | 1       |</span><br><span class="line">| Threads_created         | 9649301 |</span><br><span class="line">| Threads_running         | 1       |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like <span class="string">'connections'</span>;</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Variable_name | Value   |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Connections   | 9649311 |</span><br><span class="line">+---------------+---------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><p>如上：系统启动到现在共接受到客户端的连接9649311次，共创建了9649301个连接线程，当前有1个连接线程处于和客户端连接的状态。而在Thread Cache池中共缓存了0个连接线程(Threads_cached)。</p><p>Thread Cache 命中率：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread_Cache_Hit = (Connections - Threads_created) / Connections * 100%;</span><br></pre></td></tr></table></figure><p></p><p>一般在系统稳定运行一段时间后，Thread Cache命中率应该保持在90%左右才算正常。</p><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><p>tmp_table_size 控制内存临时表的最大值,超过限值后就往硬盘写，写的位置由变量 tmpdir 决定<br>max_heap_table_size 用户可以创建的内存表(memory table)的大小.这个值用来计算内存表的最大行数值。<br>Order By 或者Group By操作多的话，加大这两个值，默认16M<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'Created_tmp_%'</span>;</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Created_tmp_disk_tables | 0     |</span><br><span class="line">| Created_tmp_files       | 626   |</span><br><span class="line">| Created_tmp_tables      | 3     |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>如上图，写入硬盘的为0，3次中间表，说明我们的默认值足够用了</li></ul><h1 id="mariadb-推荐配置"><a href="#mariadb-推荐配置" class="headerlink" title="mariadb 推荐配置"></a>mariadb 推荐配置</h1><ul><li>注意这里只推荐innodb引擎</li><li>内存配置只关注有注释的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">user=mysql</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># global settings</span></span><br><span class="line">table_cache=65535</span><br><span class="line">table_definition_cache=65535</span><br><span class="line"></span><br><span class="line">max_allowed_packet=4M</span><br><span class="line">net_buffer_length=1M</span><br><span class="line">bulk_insert_buffer_size=16M</span><br><span class="line"></span><br><span class="line">query_cache_type=0<span class="comment">#是否使用查询缓冲,0关闭</span></span><br><span class="line">query_cache_size=0<span class="comment">#0关闭，因为改表操作多，命中低，开启消耗cpu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shared</span></span><br><span class="line">key_buffer_size=8M<span class="comment">#保持8M MyISAM索引用</span></span><br><span class="line">innodb_buffer_pool_size=4G        <span class="comment">#DB专用mem*50%，非DB专用mem*15%到25%</span></span><br><span class="line">myisam_sort_buffer_size=32M</span><br><span class="line">max_heap_table_size=16M<span class="comment">#最大中间表大小</span></span><br><span class="line">tmp_table_size=16M<span class="comment">#中间表大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># per-thread</span></span><br><span class="line">sort_buffer_size=256K<span class="comment">#加速排序缓存大小</span></span><br><span class="line">read_buffer_size=128k<span class="comment">#为需要全表扫描的MYISAM数据表线程指定缓存</span></span><br><span class="line">read_rnd_buffer_size=4M<span class="comment">#已排序的表读取时缓存，如果比较大内存就到6M</span></span><br><span class="line">join_buffer_size=1M<span class="comment">#join语句多时加大，1-2M</span></span><br><span class="line">thread_stack=256k<span class="comment">#线程空间，256K or 512K</span></span><br><span class="line">binlog_cache_size=64K<span class="comment">#大事务binlog</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># big-tables</span></span><br><span class="line">innodb_file_per_table = 1</span><br><span class="line">skip-external-locking</span><br><span class="line">max_connections=2048<span class="comment">#最大连接数</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line"><span class="comment"># slow_query_log</span></span><br><span class="line">slow_query_log_file = /var/<span class="built_in">log</span>/mysql-slow.log</span><br><span class="line">long_query_time = 30</span><br><span class="line">group_concat_max_len=65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># according to tuning-primer.sh</span></span><br><span class="line">thread_cache_size = 8</span><br><span class="line">thread_concurrency = 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># set variables</span></span><br><span class="line">concurrent_insert=2</span><br></pre></td></tr></table></figure><h1 id="运行时修改"><a href="#运行时修改" class="headerlink" title="运行时修改"></a>运行时修改</h1><p>使用以下命令来修改变量<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global &#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br><span class="line"><span class="built_in">set</span> @@&#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br><span class="line"><span class="built_in">set</span> @@global.&#123;要改的key&#125; = &#123;值&#125;; （立即生效重启后失效）</span><br></pre></td></tr></table></figure><p></p><p>试验<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @@global.innodb_buffer_pool_size=4294967296;</span><br><span class="line">ERROR 1238 (HY000): Variable 'innodb_buffer_pool_size' is a read only variable</span><br><span class="line">mysql&gt; set @@global.thread_stack=262144;</span><br><span class="line">ERROR 1238 (HY000): Variable 'thread_stack' is a read only variable</span><br><span class="line">mysql&gt; set @@global.binlog_cache_size=65536;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@join_buffer_size=1048576;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@read_rnd_buffer_size=4194304;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@sort_buffer_size=262144;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set @@read_buffer_size=131072;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global key_buffer_size=8388608;</span><br><span class="line">Query OK, 0 rows affected (0.39 sec)</span><br></pre></td></tr></table></figure><p></p><ul><li>我们可以看到<code>innodb_buffer_pool_size</code>和<code>thread_stack</code>报错了，他们只能改配置文件，在运行时是只读的。<br>以下直接复制使用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@global.binlog_cache_size=<span class="number">65536</span>;</span><br><span class="line"><span class="keyword">set</span> @@join_buffer_size=<span class="number">1048576</span>;</span><br><span class="line"><span class="keyword">set</span> @@read_rnd_buffer_size=<span class="number">4194304</span>;</span><br><span class="line"><span class="keyword">set</span> @@sort_buffer_size=<span class="number">262144</span>;</span><br><span class="line"><span class="keyword">set</span> @@read_buffer_size=<span class="number">131072</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> key_buffer_size=<span class="number">8388608</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/dc666/article/details/78901341" target="_blank" rel="noopener">记一次Mysql占用内存过高的优化过程</a><br><a href="https://blog.csdn.net/rainysia/article/details/8767946" target="_blank" rel="noopener">mysql 优化技巧心得一(key_buffer_size设置)</a><br><a href="https://snippetinfo.net/mobile/media/1596" target="_blank" rel="noopener">mysql内存计算</a><br><a href="http://www.mysqlcalculator.com/" target="_blank" rel="noopener">mysql计算器</a><br><a href="https://mariadb.com/kb/en/library/documentation/" target="_blank" rel="noopener">mariadb官网</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql调优 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vimdiff</title>
      <link href="/vimdiff/"/>
      <url>/vimdiff/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：我们在windows平台上用过beyond compare来进行文件比较，在linux平台上也有类似的东西，还是免费的。那就是vimdiff，它是vim的diff模式，依赖于diff命令。在文件比较方便比diff要强大的多，它有简单明了的界面以及对比结果一目了然的特点，容易对多处差异进行对比和合并。</p><a id="more"></a><h1 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h1><p>保证安装了vim和diff命令<br>使用以下方法启动<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1 file2    <span class="comment">#垂直</span></span><br><span class="line">vimdiff -o file1 file2 <span class="comment">#水平</span></span><br></pre></td></tr></table></figure><p></p><h1 id="切换视角"><a href="#切换视角" class="headerlink" title="切换视角"></a>切换视角</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-w w <span class="comment">#在不同窗口间跳转</span></span><br><span class="line">Ctrl-w K <span class="comment">#把当前窗口移到最上边</span></span><br><span class="line">Ctrl-w H <span class="comment">#把当前窗口移到最左边</span></span><br><span class="line">Ctrl-w J <span class="comment">#把当前窗口移到最下边</span></span><br><span class="line">Ctrl-w L <span class="comment">#把当前窗口移到最右边</span></span><br></pre></td></tr></table></figure><p>其中K和J两个操作会把窗口改成水平分割方式。</p><h1 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h1><p><img src="/vimdiff/vimdiff_show1.png" alt="upload successful"></p><ul><li>只在某一文件中存在的行的背景色被设置为蓝色，而在另一文件中的对应位置被显示为绿色。</li><li>两个文件中都存在，但是包含差异的行显示为粉色背景，引起差异的文字用红色背景加以突出。</li><li><p><code>+-- 7 lines: #include &lt;stdio.h&gt;-------------------</code> 表示折叠的行 可以用<code>zo</code>（open）可以把折叠的行打开,使用<code>zc</code>(close)可以把折叠的行关闭</p></li><li><p><code>-------------------------------------------</code> 表示删除的行</p></li><li>上下文的展开和查看：比较和合并文件的时候经常需要结合上下文来确定最终要采取的操作。Vimdiff 缺省是会把不同之处上下各 6 行的文本都显示出来以供参考。其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数，可以这样设置(设置上下文为3行)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> diffopt=context:3</span><br></pre></td></tr></table></figure></li></ul><h1 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h1><p>可以使用快捷键在各个差异点之间快速移动。</p><ul><li><code>]c</code> 跳转到下一个差异点</li><li><code>[c</code> 跳转到上一个差异点</li><li><code>2]c</code>如果在命令前加上数字的话，可以跳过一个或数个差异点，从而实现跳的更远。比如如果在位于第一个差异点的行输入<code>2]c</code>，将越过下一个差异点，跳转到第三个差异点。</li></ul><h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><p>用到的命令：</p><ul><li><p><code>dp</code> （diff “put”）<br>如果希望把另一个文件的内容复制到当前行中，可以使用命令</p></li><li><p><code>do</code> (diff “get”，之所以不用dg，是因为dg已经被另一个命令占用了)</p></li><li><p><code>:diffupdate</code> 在修改一个或两个文件之后，vimdiff会试图自动来重新比较文件，来实时反映比较结果。但是也会有处理失败的情况，这个时候需要手工来刷新比较结果</p></li><li><p><code>&lt;ESC&gt;, u</code> 如果希望撤销修改，可以和平常用vim编辑一样，直接但是要注意一定要将<strong>光标移动到需要撤销修改的文件窗口</strong>中。</p></li></ul><p>备注： 如果有多个窗口的话只要在<code>dp</code>、<code>do</code>命令前加数字代表把当前行复制到哪个窗口中或者把哪个窗口中的复制到当前窗口</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://my.oschina.net/alphajay/blog/108834" target="_blank" rel="noopener">vimdiff的常用命令</a><br><a href="https://www.cnblogs.com/motoyang/p/6091281.html" target="_blank" rel="noopener">技巧：Vimdiff 使用</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用腾讯云服务器搭建vpn</title>
      <link href="/create_vpn/"/>
      <url>/create_vpn/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：最近腾讯云发了优惠券那就给自己搭建一个vpn吧，便于随时上外网。</p><a id="more"></a><h1 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h1><p>腾讯云centos7.2 64位</p><h1 id="服务器上配置"><a href="#服务器上配置" class="headerlink" title="服务器上配置"></a>服务器上配置</h1><p>首先查看系统是否支持pptpd服务：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe ppp-compress-18 &amp;&amp; <span class="built_in">echo</span> yes</span><br></pre></td></tr></table></figure><p></p><p>安装ppp , pptpd，iptables<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ppp pptpd iptables</span><br><span class="line">systemctl mask firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p></p><p>修改配制<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pptpd.conf    <span class="comment">#找到配制文件中默认的值，去掉注释即可</span></span><br><span class="line">localip 192.168.0.2-238,192.168.0.245</span><br><span class="line">remoteip 192.168.1.2-238,192.168.1.245</span><br></pre></td></tr></table></figure><p></p><ul><li>需要注意的是：remoteip最好不用和VPN client本身所在的局域网的ip冲突。<br>修改DNS</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/options.pptpd      <span class="comment">#末尾添加dns</span></span><br><span class="line">ms-dns  8.8.8.8</span><br><span class="line">ms-dns  114.114.114.114</span><br></pre></td></tr></table></figure><p>添加vpn账户<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/chap-secrets</span><br><span class="line"><span class="comment"># client        server  secret                  IP addresses</span></span><br><span class="line">  user          pptpd   passwd                  *</span><br></pre></td></tr></table></figure><p></p><p>开启路由转发<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1 <span class="comment">#添加在配制文件的末尾即可</span></span><br><span class="line">sysctl -p    <span class="comment">#运行这个命令会输出上面添加的那一行信息，意思是使内核修改生效</span></span><br></pre></td></tr></table></figure><p></p><p>在防火墙上开启nat转发<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE  <span class="comment">#IP和网口根据实际情况修改即可</span></span><br></pre></td></tr></table></figure><p></p><p>开启服务<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service iptables save <span class="comment">#正常来说要做这个来使iptables生效</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line">systemctl restart pptpd</span><br></pre></td></tr></table></figure><p></p><p>检查是否成功<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -anlpt  | grep pptp</span><br><span class="line">tcp        0      0 0.0.0.0:1723            0.0.0.0:*               LISTEN      27202/pptpd</span><br></pre></td></tr></table></figure><p></p><p>如果不能访问的话，看系统日志位置</p><h1 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h1><p>加一个入站规则</p><p><img src="/create_vpn/ser.png" alt="upload successful"></p><h1 id="手机上连接"><a href="#手机上连接" class="headerlink" title="手机上连接"></a>手机上连接</h1><p><img src="/create_vpn/phone_vpn.png" alt="upload successful"></p><ul><li>手机上找到vpn</li><li>新建，pptp协议</li><li>服务器ip: 你的服务器ip</li><li>用户名：你刚刚设置的用户名<code>/etc/ppp/chap-secrets下</code></li><li>密码: 你刚刚设置的密码<code>/etc/ppp/chap-secrets下</code></li></ul><h1 id="mac上连接"><a href="#mac上连接" class="headerlink" title="mac上连接"></a>mac上连接</h1><p>我发现新的MacOS不支持PPTP协议，先用shimo，等试用期到了再看要不要加L2TP</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> vpn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
            <tag> PPTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>base64</title>
      <link href="/base64/"/>
      <url>/base64/</url>
      
        <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="欢迎来到我的博客, 请输入密码来访问这篇文章." />    <label for="pass">欢迎来到我的博客, 请输入密码来访问这篇文章.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> base64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base64 </tag>
            
            <tag> 编码 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本控制工具——Git常用命令 </title>
      <link href="/git-start2/"/>
      <url>/git-start2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jan 21 2019 14:21:12 GMT+0800 (China Standard Time) --><p>摘要：我们说过了git的几乎全部的常用情况，相信基本已经可以在平时团队协作开发的过程中游刃有余了。我熟悉了git的使用以后，这里给出git常用的命令，以下的命令几乎覆盖了所有的git常用操作，在此记录便于快速查找使用。</p><a id="more"></a><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git init                                              <span class="comment"># 初始化本地git仓库（创建新仓库）</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span>                   <span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@xxx.com"</span>          <span class="comment"># 配置邮件</span></span><br><span class="line">// git status等命令自动着色</span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         </span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line"></span><br><span class="line">// 查看当前代理设置</span><br><span class="line">git config --global http.proxy</span><br><span class="line">// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080</span><br><span class="line">git config --global http.proxy <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span> </span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy    <span class="comment">#删除 proxy git config</span></span><br></pre></td></tr></table></figure><h2 id="代码文件与提交相关"><a href="#代码文件与提交相关" class="headerlink" title="代码文件与提交相关"></a>代码文件与提交相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></span><br><span class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></span><br><span class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></span><br><span class="line">git commit -m <span class="string">'xxx'</span>                                       <span class="comment"># 提交</span></span><br><span class="line">git commit --amend -m <span class="string">'xxx'</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit -am <span class="string">'xxx'</span>                                      <span class="comment"># 将add和commit合为一步</span></span><br><span class="line">git rm xxx                                                <span class="comment"># 删除index中的文件</span></span><br><span class="line">git rm -r *                                               <span class="comment"># 递归删除</span></span><br><span class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></span><br><span class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></span><br><span class="line">git <span class="built_in">log</span> -5</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></span><br><span class="line">git <span class="built_in">log</span> -p -m</span><br><span class="line">git <span class="built_in">log</span> -- filename                                       <span class="comment"># 查看文件的修改日志 </span></span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></span><br><span class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></span><br><span class="line">git show HEAD                                             <span class="comment"># 显示HEAD提交日志</span></span><br><span class="line">git show HEAD^                                            <span class="comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span></span><br><span class="line">git whatchanged                                           <span class="comment"># 显示提交历史对应的文件修改</span></span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span></span><br></pre></td></tr></table></figure><h2 id="tag相关"><a href="#tag相关" class="headerlink" title="tag相关"></a>tag相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag                                                   <span class="comment"># 显示已存在的tag</span></span><br><span class="line">git tag -a v2.0 -m <span class="string">'xxx'</span>                                  <span class="comment"># 增加v2.0的tag</span></span><br><span class="line">git show v2.0                                             <span class="comment"># 显示v2.0的日志及详细内容</span></span><br><span class="line">git <span class="built_in">log</span> v2.0                                              <span class="comment"># 显示v2.0的日志</span></span><br><span class="line">git push --tags                                           <span class="comment"># 把所有tag推送到远程仓库</span></span><br><span class="line">git tag -d tag_name                                       <span class="comment"># 本地删除名为tag_name的tag</span></span><br><span class="line">git push origin :refs/tags/tag_name                       <span class="comment"># 远程删除名为tag_name的tag</span></span><br></pre></td></tr></table></figure><h2 id="差异比较相关"><a href="#差异比较相关" class="headerlink" title="差异比较相关"></a>差异比较相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff                                                  <span class="comment"># 显示所有未添加至index的变更</span></span><br><span class="line">git diff --cached                                         <span class="comment"># 显示所有已添加index但还未commit的变更</span></span><br><span class="line">git diff HEAD^                                            <span class="comment"># 比较与上一个版本的差异</span></span><br><span class="line">git diff HEAD -- ./lib                                    <span class="comment"># 比较与HEAD版本lib目录的差异</span></span><br><span class="line">git diff origin/master..master                            <span class="comment"># 比较远程分支master上有本地分支master上没有的</span></span><br><span class="line">git diff origin/master..master --<span class="built_in">stat</span>                     <span class="comment"># 只显示差异的文件，不显示具体内容</span></span><br></pre></td></tr></table></figure><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git <span class="comment"># 增加远程定义（用于push/pull/fetch）</span></span><br><span class="line">git branch                                                <span class="comment"># 显示本地分支</span></span><br><span class="line">git branch --contains 50089                               <span class="comment"># 显示包含提交50089的分支</span></span><br><span class="line">git branch -a                                             <span class="comment"># 显示所有分支</span></span><br><span class="line">git branch -r                                             <span class="comment"># 显示所有原创分支</span></span><br><span class="line">git branch --merged                                       <span class="comment"># 显示所有已合并到当前分支的分支</span></span><br><span class="line">git branch --no-merged                                    <span class="comment"># 显示所有未合并到当前分支的分支</span></span><br><span class="line">git branch -m master master_copy                          <span class="comment"># 本地分支改名</span></span><br><span class="line">git checkout -b master_copy                               <span class="comment"># 从当前分支创建新分支master_copy并检出</span></span><br><span class="line">git checkout -b master master_copy                        <span class="comment"># 上面的完整版</span></span><br><span class="line">git checkout features/performance                         <span class="comment"># 检出已存在的features/performance分支</span></span><br><span class="line">git checkout --track hotfixes/BJVEP933                    <span class="comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span></span><br><span class="line">git checkout v2.0                                         <span class="comment"># 检出版本v2.0</span></span><br><span class="line">git checkout -b devel origin/develop                      <span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">git checkout -- README                                    <span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git merge origin/master                                   <span class="comment"># 合并远程master分支至当前分支</span></span><br><span class="line">git cherry-pick ff44785404a8e                             <span class="comment"># 合并提交ff44785404a8e的修改</span></span><br><span class="line">git push origin master                                    <span class="comment"># 将当前分支push到远程master分支</span></span><br><span class="line">git push origin :hotfixes/BJVEP933                        <span class="comment"># 删除远程仓库的hotfixes/BJVEP933分支</span></span><br><span class="line">git fetch                                                 <span class="comment"># 获取所有远程分支（不更新本地分支，另需merge）</span></span><br><span class="line">git fetch --prune                                         <span class="comment"># 获取所有原创分支并清除服务器上已删掉的分支</span></span><br><span class="line">git pull origin master                                    <span class="comment"># 获取远程分支master并merge到当前分支</span></span><br><span class="line">git mv README README2                                     <span class="comment"># 重命名文件README为README2</span></span><br><span class="line">git reset --hard HEAD                                     <span class="comment"># 将当前版本重置为HEAD（通常用于merge失败回退）</span></span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           <span class="comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span></span><br><span class="line">git branch -D hotfixes/BJVEP933                           <span class="comment"># 强制删除分支hotfixes/BJVEP933，小心操作</span></span><br><span class="line">git ls-files                                              <span class="comment"># 列出git index包含的文件</span></span><br><span class="line">git show-branch                                           <span class="comment"># 图示当前分支历史</span></span><br><span class="line">git show-branch --all                                     <span class="comment"># 图示所有分支历史</span></span><br></pre></td></tr></table></figure><h2 id="图示命令"><a href="#图示命令" class="headerlink" title="图示命令"></a>图示命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git ls-tree HEAD                                          <span class="comment"># 内部命令：显示某个git对象</span></span><br><span class="line">git rev-parse v2.0                                        <span class="comment"># 内部命令：显示某个ref对于的SHA1 HASH</span></span><br><span class="line">git reflog                                                <span class="comment"># 显示所有提交，包括孤立节点</span></span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               <span class="comment"># 显示master分支昨天的状态</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph                   <span class="comment"># 图示提交日志</span></span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br></pre></td></tr></table></figure><h2 id="暂存相关"><a href="#暂存相关" class="headerlink" title="暂存相关"></a>暂存相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash                                                 <span class="comment"># 暂存当前修改，将所有至为HEAD状态</span></span><br><span class="line">git stash list                                            <span class="comment"># 查看所有暂存</span></span><br><span class="line">git stash show -p stash@&#123;0&#125;                               <span class="comment"># 参考第一次暂存</span></span><br><span class="line">git stash apply stash@&#123;0&#125;                                 <span class="comment"># 应用第一次暂存</span></span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git grep <span class="string">"delete from"</span>                                    <span class="comment">#查找当前分支下的文件内容，可以git grep --help看具体用法</span></span><br><span class="line">git grep <span class="string">"delete from"</span> v2.0                               <span class="comment">#指定tag来查找</span></span><br></pre></td></tr></table></figure><h2 id="git-index操作"><a href="#git-index操作" class="headerlink" title="git index操作"></a>git index操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git update-index —assume-unchanged 文件名                  <span class="comment">#取消本地跟踪</span></span><br><span class="line">git update-index —no-assume-unchanged 文件名               <span class="comment">#恢复本地跟踪</span></span><br><span class="line">git ls-files -v| grep <span class="string">'^h\ '</span>                              <span class="comment">#可以看到本地不跟踪的文件</span></span><br></pre></td></tr></table></figure><h1 id="管理远程分支"><a href="#管理远程分支" class="headerlink" title="管理远程分支"></a>管理远程分支</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote                                    <span class="comment">#不带参数，列出已经存在的远程分支</span></span><br><span class="line">git remote -v                                 <span class="comment">#(-v是–verbose 的简写,取首字母)列出详细信息，在每一个名字后面列出其远程url</span></span><br><span class="line">git remote add [shortname] [url]              <span class="comment">#添加远程仓库</span></span><br><span class="line">git fetch origin                              <span class="comment">#字符串 origin 指代对应的仓库地址了.比如说,要抓取所有 origin 有的,但本地仓库没有的信息,可以用</span></span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> git教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本控制工具——Git常用操作（下）</title>
      <link href="/git-start3/"/>
      <url>/git-start3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Feb 13 2019 14:19:20 GMT+0800 (China Standard Time) --><p>摘要：上一集我们一起入门学习了git的基本概念和git常用的操作，包括提交和同步代码、使用分支、出现代码冲突的解决办法、紧急保存现场和恢复现场的操作。学会以后已经足够我们使用Git参加协作开发了，但是在开发的过程中难免会出错，本文主要介绍版本控制的过程中出错了的场景，以及Git开发的一些技巧，让我们用的更流畅。</p><a id="more"></a><p>上集回顾：</p><ul><li>Git的基本概念</li><li>一个人使用Git时的代码版本控制–（提交、拉代码、分支操作）</li><li>多人合作时的代码版本控制–（合并冲突、暂存代码）</li></ul><p>上集传送门：<a href="/git-start" target="view_window">版本控制工具——Git常用操作（上）</a></p><p>本文核心：</p><ul><li>后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）</li><li>哎呀，提交的时候漏了文件</li><li>tag操作</li><li>git忽略不想提交的文件</li></ul><h1 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h1><h2 id="撤消当前commit"><a href="#撤消当前commit" class="headerlink" title="撤消当前commit"></a>撤消当前commit</h2><p>如果你发现刚刚的操作一不小心commit了，所幸你还没有推送到远程仓库，你可以用<code>reset</code>命令来撤消你的这次提交。<br><code>reset</code>命令的作用：重置HEAD(当前分支的版本顶端）到另外一个commit。</p><blockquote><p>我们的撤消当前提交的时候往往不希望我们此次提交的代码发生任何丢失，只是撤消掉commit的操作，以便我们继续修改文件。如果我们是想直接不要了这次commit的全部内容的任何修改我们将在下一小节讨论。</p></blockquote><p>来，我们先说一句蠢话来diss老板<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ touch to_boss.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a bad guy!'</span> &gt; to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git add to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"[+]骂了我的boss"</span></span><br><span class="line">[master 3d113a7] [+]骂了我的boss</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 to_boss.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>创建to_boss.txt文件，并向其写入了<code>my boss is a bad guy!</code></li><li><code>add</code>然后<code>status</code>查看新文件已经加入跟踪</li><li><code>commit</code>提交了这次的修改</li></ul><p>好了，刚刚我们“不小心”diss了我们的老板，要是被发现就完了，所幸还没有<code>push</code>，要快点撤消这些提交，再换成一些好话才行。<br>我们使用以下命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft head^</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line"></span><br><span class="line">$ cat to_boss.txt</span><br><span class="line">my boss is a bad guy!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a good boy!'</span></span><br><span class="line">my boss is a good boy!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'my boss is a good boy!'</span> &gt; to_boss.txt</span><br><span class="line"></span><br><span class="line">$ cat to_boss.txt</span><br><span class="line">my boss is a good boy!</span><br><span class="line"></span><br><span class="line">$ git add to_boss.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   to_boss.txt</span><br><span class="line">    </span><br><span class="line">$ git commit -m <span class="string">"[*]夸了我的boss"</span></span><br><span class="line">[master 8be46aa] [*]夸了我的boss</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 to_boss.txt</span><br></pre></td></tr></table></figure><p></p><ul><li><code>git reset --soft head^</code>撤消了本次提交，将工作区恢复到了提交前但是已经<code>add</code>的状态</li><li>将<code>to_boss.txt</code>的内容改成了<code>my boss is a good boy!</code></li><li><code>add</code>然后<code>commit</code>提交</li></ul><p>好了，有惊无险，这就是撤消commit的操作。另一种情况是如果你想撤消commit的时候支持舍弃这次全部的修改就把<code>git reset --soft head^</code>改成<code>git reset --hard head^</code>，这样你本地修改就彻底丢掉了(慎用)，如果真用了想找回来怎么办？见<a href="#救命的后悔药">救命的后悔药</a>。</p><p>当然了，你只要开心不加<code>soft</code>或<code>hard</code>参数也是安全的(相当于使用了<code>--mixed</code>参数)，只不过是撤消以后你的本次修改就会回到<code>add</code>之前的状态，你可以重新检视然后再做修改和<code>commit</code>。</p><h2 id="回退远程仓库"><a href="#回退远程仓库" class="headerlink" title="回退远程仓库"></a>回退远程仓库</h2><p>要是我们做的更过分一点，直接把这次<code>commit</code>直接给<code>push</code>怎么办？要是被发现就全完了,我们来看看github上的远程仓库。</p><p><img src="/git-start3/rollback_push.png" alt="upload successful"></p><p>完了，真的提交了（我刚刚push的）让我们冷静下来，用<a href="#撤消当前commit">撤消当前commit</a>的方法先撤消本地的<code>commit</code>,这次我们来试试用<code>hard</code>参数来撤消</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard head^</span><br><span class="line">HEAD is now at 3f22a06 [+]add file time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind <span class="string">'origin/master'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git push origin master --force</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> + 3d113a7...3f22a06 master -&gt; master (forced update)</span><br></pre></td></tr></table></figure><ul><li>使用<code>git reset --hard head^</code>回滚到上一个<code>commit</code></li><li>使用<code>git status</code>查看现在的工作区情况，提示<code>Your branch is behind &#39;origin/master&#39; by 1 commit</code>,代表成功表了上一次的提示状态，<code>nothing to commit, working tree clean</code>代表这次的修改全没了，清理的算是一个彻底。如果还想找回来怎么办，我们还真是有办法让你找回来的，见<a href="#救命的后悔药">救命的后悔药</a>。</li><li><code>git push origin master --force</code> 命令强制提交到远程仓库(注意，如果是在团队合作的情况下，不到迫不得已不要给命令加–force参数)<br>让我们看看<code>github</code></li></ul><p><img src="/git-start3/rollback_push2.png" alt="upload successful"></p><p>真的撤消了远程仓库，长舒一口气。</p><h2 id="暂存区（Stage）到工作区（Working-Directory）"><a href="#暂存区（Stage）到工作区（Working-Directory）" class="headerlink" title="暂存区（Stage）到工作区（Working Directory）"></a>暂存区（Stage）到工作区（Working Directory）</h2><p>如果我们刚刚执行了<code>git reset --soft</code>或者<code>add</code>等的操作，把一些东西加到了我们的暂存区，比如日志文件,我们就要把他们从暂存区拿出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   mysql.log</span><br><span class="line">    </span><br><span class="line">$ git reset -- mysql.log</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">mysql.log</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><ul><li><code>status</code>查看暂存区，里面有一个mysql.log被放进去了</li><li><code>git reset -- mysql.log</code>把<code>mysql.log</code>取出来</li><li><code>status</code>可以看到真的取出来了<br>然后如果不要想这个文件的话再rm掉就好啦,但是如果这些文件每次自动生成都要用这种方式取出暂存区真的好累，我们可以用 <a href="#git忽略不想提交的文件">git忽略不想提交的文件</a></li></ul><h2 id="回滚文件到某个提交"><a href="#回滚文件到某个提交" class="headerlink" title="回滚文件到某个提交"></a>回滚文件到某个提交</h2><p>当我们想要把某个文件任意的回滚到某次提交上，而不改变其他文件的状态我们要怎么做呢？<br>我们有两种情况，一种是，只是想在工作区有修改的文件，直接丢弃掉他现在的修改；第二种是想把这个文件回滚到以前的某一次提交。我们先来说第一种：</p><h3 id="取消文件在工作区的修改"><a href="#取消文件在工作区的修改" class="headerlink" title="取消文件在工作区的修改"></a>取消文件在工作区的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 18:51 &gt; time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   time.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">18:51</span><br><span class="line"></span><br><span class="line">$ git checkout -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br></pre></td></tr></table></figure><ul><li>更新<code>time.txt</code>的内容，可以<code>status</code>看到他发生了变化</li><li><code>git checkout -- time.txt</code> , 取消这次在工作区的修改，如果他已经被<code>add</code>加到了暂存区，那么这个命令就没有用了，他的意思是取消本次在工作区的修改，去上一次保存的地方。如果没有<code>add</code>就回到和版本库一样的状态；如果已经加到了暂存区，又做了修改，那么就回加到暂存区后的状态<h3 id="将文件回滚到任意的版本"><a href="#将文件回滚到任意的版本" class="headerlink" title="将文件回滚到任意的版本"></a>将文件回滚到任意的版本</h3>我们这里说的把文件回滚到以前的某个版本的状态，完整的含义是保持其他文件的内容不变，改变这个文件到以前的某个版本，然后修改到自己满意的样子和做下一次的提交。</li></ul><p>核心命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;options&gt;] [&lt;branch&gt;] -- &lt;file&gt;...</span><br></pre></td></tr></table></figure><p></p><p>我们还是用<code>time.txt</code>这个文件来做试验,先搞三个版本出来，在这里我已经搞好了，来看看：<br>版本1，time.txt内容00:50<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line">    [*]update time to 00:50</span><br></pre></td></tr></table></figure><p></p><p>版本2，time.txt内容18:51<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line">    [*]update time to 18:51</span><br></pre></td></tr></table></figure><p></p><p>版本3，time.txt内容10:41<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 3f22a0639f8d79bd4e329442f181342465dbf0b6</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Tue Dec 18 10:42:29 2018 +0800</span><br><span class="line">    [+]add file time.txt</span><br></pre></td></tr></table></figure><p></p><p>现在的是版本1，我们把版本3检出试试。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 3f22a0639f8d -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">10:41</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">modified:   time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>使用<code>checkout</code>+<code>commit id</code>+<code>-- filename</code>的组合，横跨版本2把历史版本3的<code>time.txt</code>搞出来了</li><li>查看状态,time.txt被改变了</li></ul><p>我们来把time.txt恢复到版本1，同样的方法，因为版本1是上一次提交我们可以省略掉版本号<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- time.txt</span><br><span class="line"></span><br><span class="line">$ cat time.txt</span><br><span class="line">00:50</span><br></pre></td></tr></table></figure><p></p><p>看到了吧！只要用<code>git checkout commit_id -- filename</code>的组合，想搞出哪个文件历史版本就搞出哪个。</p><p>到了这里，你可能会很懵比,<code>reset</code>和<code>checkout</code>命令真的好像啊！都可以用来做撤消</p><ul><li><code>checkout</code>语义上是把什么东西取出来，所以此命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</li><li><code>reset</code>语义上是重新设置，所以此命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</li></ul><p>还想不通可以给我发邮件：<a href="mailto:pzqu@qq.com" target="_blank" rel="noopener">pzqu@qq.com</a></p><h2 id="救命的后悔药"><a href="#救命的后悔药" class="headerlink" title="救命的后悔药"></a>救命的后悔药</h2><p>来到这里我已经很清楚的你的现况了，你的代码丢了现在一定非常的着急，不要慌，总是有办法找回他们的。但是前提是要保证你的项目根目录下.git文件夹是完整的，要是手动删除了里面的一些东西那就真完了。还要保证一点，你的代码以前是有过git追踪的，最少<code>add</code>过</p><h3 id="找回你丢失的历史记录"><a href="#找回你丢失的历史记录" class="headerlink" title="找回你丢失的历史记录"></a>找回你丢失的历史记录</h3><p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令，贴个图吧直观点：<br><img src="/git-start3/help1.png" alt="upload successful"></p><ul><li>有没有发现，<code>git reflog</code>里的全部都是和改变目录树有关的，比如<code>commit rebase reset merge</code>，也就是说一定要有改变目录树的操作才恢复的回来</li><li>像add这种操作就不能恢复了吗？那肯定不是，只是要用更麻烦点的方式来恢复</li><li><p><code>git log</code>是一样的，也可以看到所有分支的历史提交，不一样的是看不到已经被删除的 <code>commit</code> 记录和 <code>reset rebase merge</code> 的操作<br>我们可以看到<code>git reflog</code>前面的就是<code>commit id</code>，现在我们就可以用之前介绍过的方法来回滚版本了，<a href="#撤消当前commit">撤消当前commit</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 856a740</span><br><span class="line">HEAD is now at 856a740 [*]update time to 18:51</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff (HEAD -&gt; master)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 18:51</span><br><span class="line"> </span><br><span class="line">$ git reset --hard 35b66ed</span><br><span class="line">HEAD is now at 35b66ed [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit 35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">commit 856a74084bbf9b678467b2615b6c1f6bd686ecff</span><br><span class="line">Author: pzqu &lt;pzqu@example.com&gt;</span><br><span class="line">Date:   Sat Dec 22 19:39:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    [*]update time to 18:51</span><br></pre></td></tr></table></figure></li><li><p>根据<code>git reflog</code>返回的结果，用<code>git reset --hard commit_id</code>回退到<code>856a740</code>这个版本</p></li><li><code>git log -1</code>看近一行的日志，可以看到目前就在这了</li><li>再根据<code>git reflog</code>的结果，用<code>git reset --hard 35b66ed</code>跑到这次提交</li><li><code>git log -2</code>看到两次提交的日志，我们就这么再穿梭过来了，就是这么爽<br>但是我们如果只是想把此提交给找回来，恢复他，那还是不要用<code>reset</code>的方式，可以用<code>cherry-pick</code>或者<code>merge</code>来做合并</li></ul><h3 id="找回忘记提交的历史记录"><a href="#找回忘记提交的历史记录" class="headerlink" title="找回忘记提交的历史记录"></a>找回忘记提交的历史记录</h3><p>你之前没有commit过的文件，被删除掉了，或者被<code>reset --hard</code>的时候搞没了,这种情况可以说是相当的难搞了，所幸你以前做过<code>add</code>的操作把他放到过暂存区，那我们来试试找回来,先来创建一个灾难现场<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'my lose message'</span> &gt; lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git add lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   lose_file.txt</span><br><span class="line"></span><br><span class="line">$ git reset --hard 35b66ed8</span><br><span class="line">HEAD is now at 35b66ed [*]update time to 00:50</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">README.md      need_stash.txt share_file.txt time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>创建一个叫<code>lose_file.txt</code>的文件并写入内容<code>my lose message</code>，并把他加到暂存区</li><li>用<code>git reset --hard 35b66ed8</code>用丢弃一切修改的方式来使现在的工作区恢复到<code>35b66ed8</code>版本，因为还没提交所以也就是恢复到当前的（<code>head</code>）版本。</li><li>我们用<code>status</code>和<code>ls</code>再看，这个叫<code>lose_file.txt</code>的文件真的没了，完蛋了,第一反应用刚刚学到的命令<code>git reflow</code>会发现根本就不好使</li></ul><p>核心命令：<code>git fsck --lost-found</code>,他会通过一些神奇的方式把历史操作过的文件以某种算法算出来加到<code>.git/lost-found</code>文件夹里<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">dangling blob 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">dangling commit fdbb19cf4c5177003ea6610afd35cda117a41109</span><br><span class="line">dangling commit 8be46aa83f0fe90317b0c6b9c201ad994f8caeaf</span><br><span class="line">dangling blob 11400c1d56142615deba941a7577d18f830f4d85</span><br><span class="line">dangling tree 3bd4c055afedc51df0326def49cf85af15994323</span><br><span class="line">dangling commit 3d113a773771c09b7c3bf34b9e974a697e04210a</span><br><span class="line">dangling commit bfdc065df8adc44c8b69fa6826e75c5991e6cad0</span><br><span class="line">dangling tree c96ff73cb25b57ac49666a3e1e45e0abb8913296</span><br><span class="line">dangling blob d6d03143986adf15c806df227389947cf46bc6de</span><br><span class="line">dangling commit 7aa21bc382cdebe6371278d1af1041028b8a2b09</span><br></pre></td></tr></table></figure><p></p><p>这里涉及到git的一些低层的知识，我们可以看到这里有<code>blob、commit、tree</code>类型的数据，还有<code>tag</code>等类型的。他们是什么含义呢？</p><p><img src="/git-start3/losefile.png" alt="upload successful"></p><ul><li><code>blob</code>组件并不会对文件信息进行存储，而是对文件的内容进行记录</li><li><code>commit</code>组件在每次提交之后都会生成，当我们进行<code>commit</code>之后，首先会创建一个<code>commit</code>组件，之后把所有的文件信息创建一个<code>tree</code>组件,所以哪个<code>blob</code>代表什么文件都可以在<code>tree</code> 里找到<br>我们来看看怎么恢复刚刚不见了的<code>lose_file.txt</code>文件，在上面执行完<code>git fsck --lost-found</code>命令，返回的第一行<code>blob</code>我们看看他的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git show 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">my lose message</span><br><span class="line"></span><br><span class="line">git show 7f5965523d2b9e850b39eb46e8e0f7c5755f6719 &gt; lose_file.txt</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">README.md      lose_file.txt  need_stash.txt share_file.txt time.txt</span><br></pre></td></tr></table></figure><ul><li><p>看到没有，就是我们丢失的文件内容，这样就找回来了！<br>我们再来看看<code>commit tree</code>的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p fdbb19cf4c5177003ea6610afd35cda117a41109</span><br><span class="line">tree 673f696143eb74ac5e82a46ca61438b2b2d3bbf4</span><br><span class="line">parent e278392ccbf4361f27dc338c854c8a03daab8c49</span><br><span class="line">parent 7b54a8ae74be7192586568c6e36dc5a813ff47cf</span><br><span class="line">author pzqu &lt;pzqu@example.com&gt; 1544951197 +0800</span><br><span class="line">committer pzqu &lt;pzqu@example.com&gt; 1544951197 +0800</span><br><span class="line"></span><br><span class="line">Merge branch <span class="string">'master'</span> of github.com:pzqu/git_test</span><br><span class="line"></span><br><span class="line">$ git ls-tree 3bd4c055afedc51df0326def49cf85af15994323</span><br><span class="line">100644 blob c44be63b27a3ef835a0386a62ed168c91e680e87share_file.txt</span><br></pre></td></tr></table></figure></li><li><p>用<code>git cat-file -p</code>可以看到commit的内容，可以选择把这个commit合并到我们的分支里，还是<code>reset merge rebase cherry-pick</code>这些命令来合<code>commit</code></p></li><li><code>git ls-tree</code>列出tree下面的文件名和<code>id</code>的记录信息，然后就可以根据这些来恢复文件了</li></ul><p>后记：<br>如果你发现执行<code>git fsck --lost-found</code>的输出找不到你想要的，那么在执行完<code>git fsck --lost-found</code>后会出现一堆文件 在 .git/lost-found 文件夹里,我们不管他。可以用以下命令来输出近期修改的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$  find .git/objects -<span class="built_in">type</span> f | xargs ls -lt | sed 3q</span><br><span class="line">-r--r--r--  1 pzqu  staff    32 12 23 12:19 .git/objects/7f/5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">-r--r--r--  1 pzqu  staff    15 12 23 01:51 .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">-r--r--r--  1 pzqu  staff   162 12 23 00:51 .git/objects/35/b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</span><br><span class="line">my lose message</span><br><span class="line"></span><br><span class="line">$ git cat-file -t b2484b5ab58c5cb6ecd92dacc09b41b78e9b0001</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p b2484b5ab58c5cb6ecd92dacc09b41b78e9b0001</span><br><span class="line">100644 blob f9894f4195f4854cfc3e3c55960200adebbc3ac5README.md</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391need_stash.txt</span><br><span class="line">100644 blob 83f50ec84c00f5935da8089bac192171cfda8621share_file.txt</span><br><span class="line">100644 blob f0664bd6a49e268d3db47c508b08d865bc25f7bbtime.txt</span><br></pre></td></tr></table></figure><ul><li>这里用<code>find .git/objects -type f | xargs ls -lt | sed 3q</code>返回了近3个修改的文件,想要更多就改<code>3q</code>这个数值，比如你想输出100个就用<code>100q</code></li><li><code>git cat-file -t 7f5965523d2b9e850b39eb46e8e0f7c5755f6719</code> 就能看见文件类型 把最后一个/去掉 复制从objects/ 后面的所有东西放在-t后面</li><li><code>git cat-file -p id</code>就能看见文件内容，是不是很爽</li></ul><h1 id="漏提交"><a href="#漏提交" class="headerlink" title="漏提交"></a>漏提交</h1><p>有时候会碰到我们已经commit但是有修改忘记了提交，想把他们放在刚刚的<code>commit</code>里面，这种时候怎么做呢？<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --name-status --pretty=oneline -1</span><br><span class="line">35b66ed8e3ae2c63cc4ebf323831e3b917d2b1d4 (HEAD -&gt; master, origin/master, origin/HEAD) [*]update time to 00:50</span><br><span class="line">M       time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   lose_file.txt</span><br><span class="line">new file:   test_amend.txt</span><br><span class="line">    </span><br><span class="line">$ git commit --amend --no-edit</span><br><span class="line">[master 31cc277] [*]update time to 00:50</span><br><span class="line"> Date: Sun Dec 23 00:51:54 2018 +0800</span><br><span class="line"> 3 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 lose_file.txt</span><br><span class="line"> create mode 100644 test_amend.txt</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --name-status --pretty=oneline -1</span><br><span class="line">31cc2774f0668b5b7c049a404284b19e9b40dc5d (HEAD -&gt; master) [*]update time to 00:50</span><br><span class="line">A       lose_file.txt</span><br><span class="line">A       test_amend.txt</span><br><span class="line">M       time.txt</span><br></pre></td></tr></table></figure><p></p><ul><li>查看文件提交日志只有<code>time.txt</code></li><li>stage里还有新的修改在</li><li>使用<code>git commit --amend --no-edit</code>合并到上一个提交里，如果不加<code>--no-edit</code>参数的话，会提示你来修改commit提示信息(这个命令也可以用在重复编辑<code>commit message</code>)。</li><li>查看日志，合并提交成功！</li></ul><h1 id="tag标签"><a href="#tag标签" class="headerlink" title="tag标签"></a>tag标签</h1><h2 id="创建一个tag"><a href="#创建一个tag" class="headerlink" title="创建一个tag"></a>创建一个tag</h2><p>标签是一个类似于快照的东西，常常用于测试和发布版本。所以我们常常把<code>tag</code>名以版本号来命名，比如：v1.0beat1这样<br>我们怎么创建标签呢？首先先切换到想打标签的分支，然后直接打就可以了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev/pzqu</span><br><span class="line">  master</span><br><span class="line">* release_v1.0</span><br><span class="line"></span><br><span class="line">$ git tag -a release_v1.0 -m <span class="string">"release v1.0"</span></span><br><span class="line"></span><br><span class="line">$ git tag release_v1.1</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">release_v1.0</span><br><span class="line">release_v1.1</span><br><span class="line"></span><br><span class="line">$ git push --tags</span><br><span class="line">Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 158 bytes | 158.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new tag]         release_v1.0 -&gt; release_v1.0</span><br><span class="line"> * [new tag]         release_v1.1 -&gt; release_v1.1</span><br></pre></td></tr></table></figure><p></p><ul><li>切换到想打<code>tag</code>的分支</li><li>创建名为<code>release_v1.0</code>带有信息<code>release v1.0</code>的<code>tag</code></li><li>创建的不带有<code>tag</code>的提交信息的<code>release_v1.1</code></li><li><code>git tag</code>查看<code>tag</code></li><li>推送本地全部<code>tag</code></li></ul><p>也可以推送单个tag<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin release_v1.1</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new tag]         release_v1.1 -&gt; release_v1.1</span><br></pre></td></tr></table></figure><p></p><p>我们来删除tag<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d release_v1.0</span><br><span class="line">Deleted tag <span class="string">'release_v1.0'</span> (was eb5d177)</span><br><span class="line"></span><br><span class="line">$ git push origin :refs/tags/release_v1.0</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> - [deleted]         release_v1.0</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">release_v1.1</span><br></pre></td></tr></table></figure><p></p><ul><li>本地删除名为<code>release_v1.0</code>的<code>tag</code></li><li>远程删除名为<code>release_v1.0</code>的<code>tag</code></li></ul><h2 id="对历史提交打tag"><a href="#对历史提交打tag" class="headerlink" title="对历史提交打tag"></a>对历史提交打tag</h2><p>先看看当前的log<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">31cc277 (HEAD -&gt; release_v1.0, tag: release_v1.1, origin/release_v1.0, master) [*]update time to 00:50</span><br><span class="line">856a740 [*]update time to 18:51</span><br><span class="line">3f22a06 [+]add file time.txt</span><br><span class="line">4558a25 (origin/dev/pzqu, dev/pzqu) [*]test stash</span><br><span class="line">d9e018e [*]merge master to dev/pzqu</span><br></pre></td></tr></table></figure><p></p><p>比方说要对<code>[*]update time to 18:51</code>这次提交打标签，它对应的commit id是<code>856a740</code>，敲入命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v.9 856a740</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">31cc277 (HEAD -&gt; release_v1.0, tag: release_v1.1, origin/release_v1.0, master) [*]update time to 00:50</span><br><span class="line">856a740 (tag: v0.9) [*]update time to 18:51</span><br></pre></td></tr></table></figure><p></p><ul><li>成功打上</li></ul><h1 id="git忽略不想提交的文件"><a href="#git忽略不想提交的文件" class="headerlink" title="git忽略不想提交的文件"></a>git忽略不想提交的文件</h1><p>我们有两种情况，一种是我们根本就不想这些文件出现在git库里比如日志文件；另一种是git远程仓库里有这些文件，就像通用的配置文件，我们必须要在本地修改配置来适应运行环境，这种情况下我们不想每次提交的时候都去跟踪这些文件。</p><h2 id="忽略自动生成的垃圾文件、中间文件、敏感信息文件"><a href="#忽略自动生成的垃圾文件、中间文件、敏感信息文件" class="headerlink" title="忽略自动生成的垃圾文件、中间文件、敏感信息文件"></a>忽略自动生成的垃圾文件、中间文件、敏感信息文件</h2><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>我们要怎么做呢？</p><blockquote><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"*.log"</span> &gt; .gitignore</span><br><span class="line"></span><br><span class="line">$ touch test.log</span><br><span class="line"></span><br><span class="line">$ touch test2.log</span><br><span class="line"></span><br><span class="line">$ ls -a</span><br><span class="line">.              .git           README.md      need_stash.txt test.log       test_amend.txt</span><br><span class="line">..             .gitignore     lose_file.txt  share_file.txt test2.log      time.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch release_v1.0</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p></p></blockquote><ul><li>创建并写入忽略规则<code>*.log</code>忽略全部以<code>.log</code>为后缀的文件</li><li>创建了<code>test.log</code>和<code>test2.log</code></li><li><code>status</code>查看，真是工作区是<code>clean</code>，新创建的文件没有被跟踪</li></ul><h2 id="忽略远程存在，本地不想与远程同步的文件"><a href="#忽略远程存在，本地不想与远程同步的文件" class="headerlink" title="忽略远程存在，本地不想与远程同步的文件"></a>忽略远程存在，本地不想与远程同步的文件</h2><h3 id="添加跟踪忽略"><a href="#添加跟踪忽略" class="headerlink" title="添加跟踪忽略"></a>添加跟踪忽略</h3><p>核心命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index —assume-unchanged 文件名</span><br></pre></td></tr></table></figure><p></p><p><img src="/git-start3/ignore1.png" alt="upload successful"></p><ul><li>创建<code>time.txt</code>文件并写入<code>10:41</code>,提交到远程仓库</li><li>使用命令<code>git update-index —assume-unchanged</code>加<code>time.txt</code>加到忽略名单里</li><li>修改<code>time.txt</code>的内容为<code>10:43</code></li><li><code>status</code>查看确实没有被跟踪<br>看远程仓库</li></ul><p><img src="/git-start3/ignore2.png" alt="upload successful"></p><h3 id="取消跟踪忽略"><a href="#取消跟踪忽略" class="headerlink" title="取消跟踪忽略"></a>取消跟踪忽略</h3><p>核心命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index —no-assume-unchanged 文件名</span><br></pre></td></tr></table></figure><p></p><p><img src="/git-start3/ignore3.png" alt="upload successful"></p><ul><li><code>pull</code>同步远程仓库，真的没有更新刚刚被添加跟踪忽略的文件</li><li><code>git update-index —no-assume-unchanged</code>取消跟踪忽略</li><li><code>status</code>查看，出现文件的跟踪</li></ul><h3 id="查看跟踪记录"><a href="#查看跟踪记录" class="headerlink" title="查看跟踪记录"></a>查看跟踪记录</h3><p>如果忘记了哪些文件被自己本地跟踪</p><p><img src="/git-start3/ignore4.png" alt="upload successful"></p><ul><li>使用命令<code>git update-index —assume-unchanged</code>加<code>time.txt</code>加到忽略名单里</li><li>使用<code>git ls-files -v| grep &#39;^h\ &#39;</code>命令可以看到小写h代表本地不跟踪的文件</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>学完本文章，你将学会</p><ul><li>撤消commit,回滚暂存区，回滚工作区、回退远程仓库</li><li>两种方法找回不小心丢失的文件</li><li>提交的时候漏了文件，修改commit的提交信息</li><li>tag操作，创建、创建有描述信息的tag、删除tag、删除远程tag、推送本地单个tag和全部tag</li><li>git忽略自动生成的垃圾文件、中间文件、敏感信息文件；忽略远程存在，本地不想与远程同步的文件并恢复跟踪和查看哪些文件被跟踪</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="下集"><a href="#下集" class="headerlink" title="下集"></a>下集</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><p><a href="https://www.cnblogs.com/hope-markup/p/6683522.html" target="_blank" rel="noopener">关于git reset –hard这个命令的惨痛教训</a></p><p><a href="https://www.cnblogs.com/Calvino/p/5930656.html" target="_blank" rel="noopener">Git 基础再学习之：git checkout – file</a></p><p><a href="https://www.cnblogs.com/instona/p/4243009.html" target="_blank" rel="noopener">如何理解git checkout – file和git reset HEAD – file</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> git教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本控制工具——Git常用操作（上）</title>
      <link href="/git-start/"/>
      <url>/git-start/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。</p><a id="more"></a><p>本文核心点：</p><ul><li>Git的基本概念</li><li>一个人使用Git时的代码版本控制–（提交、拉代码、分支操作）</li><li>多人合作时的代码版本控制–（合并冲突、暂存代码）</li></ul><h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>git是世界上目前最先进的分布式版本控制系统,致力于团队、个人进行项目版本管理，完美的解决难以比较代码、难以合并代码、难以取消修改、难以在写当前代码的过程中保存未完成的修改去修改线上版本的bug等的痛点。<br>git是一个非常强大的工具，但作为一个git使用者来说，不用完全学习Git的知识点与命令，因为有的命令的使用频率非常的低甚至数年都不会用到，让我们来由浅入深进行学习。</p><h2 id="git的历史"><a href="#git的历史" class="headerlink" title="git的历史"></a>git的历史</h2><p>git是linux的创始人linus，在付费版本控制工具BitMover收回对Linux社区免费使用权利的时候，一怒之下花费两个星期的时间写出来的。（牛笔的人）</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>选择自己的操作系统对应的git版本安装，安装成功后运行<code>git version</code>后，输出git版本则安装正确。<br>git 官方： <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>使用<code>git config</code>命令来配置用户名和邮箱<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "pzqu" </span><br><span class="line">git config --global user.email pzqu@example.com</span><br></pre></td></tr></table></figure><p></p><blockquote><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p></blockquote><p>使用<code>git config user.name</code>和<code>git config user.email</code>来检查是否成功，也可以直接用<code>git config --list</code>来列出全部git配置信息来查看</p><p><img src="/git-start/85838584.png" alt=""></p><h2 id="创建git托管的项目"><a href="#创建git托管的项目" class="headerlink" title="创建git托管的项目"></a>创建git托管的项目</h2><p>假如我们创建一个项目叫make_money，先创建一个文件夹叫make_money，再使用<code>git init</code>命令创建git项目。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:05:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:24]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">make_money</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span> [0:06:29]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> make_money</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money [0:07:10]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /Users/pzqu/Documents/code/test/make_money/.git/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pzqu @ pzqu-pc <span class="keyword">in</span> ~/Documents/code/<span class="built_in">test</span>/make_money on git:master o [0:07:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -al</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:07 .</span><br><span class="line">drwxr-xr-x  3 pzqu  staff   96 11  7 00:06 ..</span><br><span class="line">drwxr-xr-x  9 pzqu  staff  288 11  7 00:07 .git</span><br></pre></td></tr></table></figure><p></p><p>创建成功以后，会出现一个叫.git的隐藏文件夹，这个就是你的git仓库，以后所有的git操作历史提交记录信息就全部记录在此了，只要这个文件夹在就可以记住我们的全部git操作</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>在使用git的时候还要清楚暂存区和工作区的含义，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇-工作区和暂存区</a></p><h1 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h1><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><h3 id="新文件与修改"><a href="#新文件与修改" class="headerlink" title="新文件与修改"></a>新文件与修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:37:50]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:42:02]</span></span><br><span class="line">$ touch file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:15]</span></span><br><span class="line">$ git add file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:23]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   file1.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:56:38]</span></span><br><span class="line">$ git commit -m <span class="string">"[+]add new file1.txt"</span></span><br><span class="line">[master 66cc488] [+]add new file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>add 添加修改的内容到索引</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p><code>git add .</code> ：监控工作区的状态树，此命令会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p><p><code>git add -u</code>：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写）</p><p><code>git add -A</code> ：是上面两个功能的合集（git add –all的缩写）</p><p><img src="/git-start/pasted-0.png" alt="upload successful"></p><pre><code>git show 列出最近一次的提交</code></pre><blockquote><p>对于commit：像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:24]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:25]</span></span><br><span class="line">$ git rm file1.txt</span><br><span class="line">rm <span class="string">'file1.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:30]</span></span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:32]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">deleted:    file1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:40] C:128</span></span><br><span class="line">$ git commit -m <span class="string">"[-]delete file1.txt"</span></span><br><span class="line">[master e278392] [-]delete file1.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 file1.txt</span><br></pre></td></tr></table></figure><p>上图操作包含:</p><ul><li>创建新文件file1.txt</li><li>git rm 删除file1.txt文件</li><li>status 查看修改的内容</li><li>commit 把索引提交到本地分支</li></ul><p>tip1: 如果没有用git rm删除文件，在本地删除文件后，git add一下再提交可以达到同样的效果</p><p>tip2: 要是你加班太晚，头晕不小心删除了不想删除的文件怎么办？见<br><a href="/git-start3/#后悔药" target="view_window">版本控制工具——Git常用操作（下）-后悔药</a></p><h2 id="拉代码"><a href="#拉代码" class="headerlink" title="拉代码"></a>拉代码</h2><h3 id="方法一-pull"><a href="#方法一-pull" class="headerlink" title="方法一 pull"></a>方法一 pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [17:01:13]</span></span><br><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:pzqu/git_test</span><br><span class="line">   5fd4d8f..7b54a8a  master     -&gt; origin/master</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 share_file.txt</span><br></pre></td></tr></table></figure><p>上图命令：</p><ul><li>git pull</li></ul><p>查看本地仓库变化<code>git log</code></p><p><img src="/git-start/git_pull.png" alt="upload successful"></p><p>上图可以看到向远程仓库pull的时候，出现了两个新的commit，<code>commit 7b54a8ae74...</code>的提交信息为<code>Create share_file.txt</code>,另一个<code>commit fdbb19cf4c51770</code>的提交信息为<code>Merge branch &#39;master&#39; of github.com:pzqu/git_test</code>。事实上主线只有一个提交，为什么会出现这种情况? 是因为pull其实会做两个操作</p><ul><li>拉远程仓库代码到本地</li><li>自动与当前分支合并并生成一个合并成功的提交</li></ul><p>注意这里的第二个个步骤如果远程有人和你改了同一个文件就会出现一个冲突，这个时候git会提示你哪些文件有冲突，手动改了再提交一次就可以了。详情见<a href="#合并冲突">合并冲突</a></p><h3 id="方法二-fetch"><a href="#方法二-fetch" class="headerlink" title="方法二 fetch"></a>方法二 fetch</h3><p>我在远程修改了文件，向<code>share_file.txt</code>加了一行内容<code>tom modify</code>，此时拉代码。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:07:21]</span></span><br><span class="line">$ git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:08:43]</span></span><br><span class="line">$ git rebase origin/master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: [+]add new file1.txt</span><br><span class="line">Applying: [-]delete file1.txt</span><br></pre></td></tr></table></figure><p></p><p>上图所示有以下两个操作</p><ul><li>fetch 拉取远端代码到本地</li><li>rebase 把本地代码提交基于远端分支重新replay</li></ul><p>效果如下：</p><p><img src="/git-start/fetch_log.png" alt="upload successful"></p><p>上图是<code>git log</code>所输出的提交内容，刚刚pull的时候忘记把pull自动产生的merge提交到远程，rebase的时候把本地的提交放到了远程提交之后，看起来就是一条直线，比较优雅，也是推荐的方式。</p><p>同样的，如果产生了冲突，详情见<a href="#合并冲突">合并冲突</a></p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>分支是多人协同最经典的地方所在，我们来创建一个分支<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu origin/master</span><br><span class="line">Branch <span class="string">'dev/pzqu'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p></p><ul><li><code>git checkout -b 分支名 其他分支</code>,<code>-b</code>代表创建并切换到新建的分支，<code>分支名</code>代表新创建的分支叫什么名字，这里叫<code>dev/pzqu</code> ，<code>其他分支</code>代表基于哪一个分支来创建，这里基于远程的master分支<code>origin/master</code>，如果省略则代表基于当前分支</li><li><code>git branch</code>展示本地的分支情况，加<code>-a</code>参数可以展示全部的分支，包括远程分支</li><li><code>*</code>在分支前，指明了现在所在的分支是<code>dev/pzqu</code></li></ul><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev/pzqu2</span><br><span class="line">Switched to a new branch <span class="string">'dev/pzqu2'</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  dev/pzqu</span><br><span class="line">* dev/pzqu2</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">$ git checkout dev/pzqu</span><br><span class="line">Switched to branch <span class="string">'dev/pzqu'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>基于当前分支创建了一个新的分支并自动切换过去<code>dev/pzqu2</code></li><li><code>git checkout 已存在的分支名</code>切换分支回到<code>dev/pzqu</code></li></ul><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  dev/pzqu2</span><br><span class="line">  master</span><br><span class="line">  </span><br><span class="line">$ git branch -D dev/pzqu2</span><br><span class="line">Deleted branch dev/pzqu2 (was 7c9be37).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>位于<code>dev/pzqu</code>，删除了<code>dev/pzqu2</code>分支</li></ul><h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><h3 id="合并同一个分支的冲突（常见）"><a href="#合并同一个分支的冲突（常见）" class="headerlink" title="合并同一个分支的冲突（常见）"></a>合并同一个分支的冲突（常见）</h3><p>为了产生一个冲突，我在另一个地方向远程仓库提交了代码，更改<code>share_file.txt</code>文件，加了一行内容<code>tom add for merge</code>，<br>本地修改同一个文件加了一行<code>pzqu add for merge</code>，并提交到本地，这样一来，本地和远程仓库的同一个文件就不一样了，一会拉代码一定会产生一个冲突。效果如下：</p><p><img src="/git-start/merge1.png" alt="upload successful"></p><ul><li>一般rebase或pull冲突的时候，都会出现提示，然后git status会出现上图图示</li><li>这个时候不可以进行任何分支切换和commit操作，按照他提示进行处理</li><li>git status提示哪个文件是都被修改的，both modified，然后使用编辑器修改该文件，解决冲突</li><li>解决完成后，git add 添加该冲突文件</li><li>git rebase –continue，并更新commit message，完成整个rebase流程<br>我们来看看这个冲突的文件：</li></ul><p><img src="/git-start/merge2.png" alt="upload successful"></p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><p><img src="/git-start/merge3.png" alt="upload successful"></p><p><code>git add</code>再<code>git rebase --continue</code>后完成rebase，效果如下，再<code>push</code>的远程仓库即可</p><p><img src="/git-start/merge4.png" alt="upload successful"></p><h3 id="合并不同分支的代码产生冲突"><a href="#合并不同分支的代码产生冲突" class="headerlink" title="合并不同分支的代码产生冲突"></a>合并不同分支的代码产生冲突</h3><p>关于怎么创建分支与切换分支见<a href="#创建分支和切换分支">创建分支和切换分支</a>,这里只讨论合并时产生的冲突的情况，我们已经基于<code>master</code>分支创建了一个<code>dev/pzqu</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev/pzqu</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支，加一行<code>master add for merge</code>并提交，文件内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>切换到<code>dev/pzqu</code>分支，向<code>share_file.txt</code>加入一行<code>dev/pzqu add for merge</code>并提交，现在<code>share_file.txt</code>内容如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br></pre></td></tr></table></figure><p></p><p>现在两个分支的同一个文件内容不一样了，现在我们在<code>dev/pzqu</code>分支上进行合并：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git merge master</span><br><span class="line">Auto-merging share_file.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> share_file.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:17:31] C:1</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">=======</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</span><br></pre></td></tr></table></figure><p></p><p>上图出现了一个冲突，是我们意料之中的，修改<code>share_file.txt</code>文件，解决此冲突：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat share_file.txt</span><br><span class="line">tom add</span><br><span class="line">tom modify</span><br><span class="line">tom add <span class="keyword">for</span> merge</span><br><span class="line">pzqu add <span class="keyword">for</span> merge</span><br><span class="line">dev/pzqu add <span class="keyword">for</span> merge</span><br><span class="line">master add <span class="keyword">for</span> merge</span><br><span class="line"></span><br><span class="line">$ git add share_file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:22:40]</span></span><br><span class="line">$ git commit -m <span class="string">"[*]merge master to dev/pzqu"</span></span><br><span class="line">[dev/pzqu d9e018e] [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line"><span class="comment"># pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu o [11:23:00]</span></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p></p><p>冲突解决也提交了，看看我们现在的分支内容：</p><p><img src="/git-start/merge_branch_devpzqu.png" alt="upload successful"></p><p>上图我们可以看到：</p><ul><li><p><code>master</code>分支比远程<code>origin/master</code>分支多一次提交，<code>dev/pzqu</code>分支由于是基于<code>origin/master</code>分支，合并了<code>master</code>分支的提交和当前<code>dev/pzqu</code>分支的提交，超出本地<code>master</code>两个提交，致此我们把<code>master</code>合并到<code>dev/pzqu</code>的操作就完成了。</p></li><li><p>通常我们开一个新的开发分支是为了在自己的分支上写代码，方便提交也不会把主线弄乱，现在我们用同样的方法将<code>dev/pzqu</code>合并到<code>master</code>分支，然后把两个分支都提交到远程。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge dev/pzqu</span><br><span class="line">Updating 58f047a..d9e018e</span><br><span class="line">Fast-forward</span><br><span class="line"> share_file.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line">   7c9be37..d9e018e  master -&gt; master</span><br><span class="line">   </span><br><span class="line">$ git push origin dev/pzqu</span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 887 bytes | 887.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'dev/pzqu'</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/pzqu/git_test/pull/new/dev/pzqu</span><br><span class="line">remote:</span><br><span class="line">To github.com:pzqu/git_test.git</span><br><span class="line"> * [new branch]      dev/pzqu -&gt; dev/pzqu</span><br></pre></td></tr></table></figure><ul><li>切换到<code>master</code>分支</li><li>合并<code>dev/pzqu</code>到<code>master</code>分支</li><li><code>master</code>推到远程仓库</li><li>如果<code>dev/pzqu</code>要保留，就可以推送到远程仓库。</li></ul><p><img src="/git-start/merge_branch_statuslast.png" alt="upload successful"></p><ul><li>现在我们可以看到全部的分支都在一起了，强迫症都舒服了。</li></ul><h2 id="暂存代码保存现场"><a href="#暂存代码保存现场" class="headerlink" title="暂存代码保存现场"></a>暂存代码保存现场</h2><p>这种情况一般是出现在你正在完成一个功能，但是忽然线上发现了一个Bug，必须马上开一个新的分支来修复bug，但是现在的功能没写完不打算提交(commit)，现在怎么办？？不用怕暂存代码来帮助你。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line">modified:   share_file.txt</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//省略操作：去创建一个Bug分支，修复他并完成与主线的合并，删除Bug分支。</span><br><span class="line">//省略操作：切回来当前分支继续开发</span><br><span class="line">//下面来恢复现场</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br><span class="line">On branch dev/pzqu</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   need_stash.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   share_file.txt</span><br></pre></td></tr></table></figure><p></p><ul><li><code>status</code>查看到有2个文件修改没有提交</li><li><code>stash</code>把修改放到暂存区，并生成一个id</li><li><code>stash list</code>列出暂存区所有内容</li><li><code>stash apply</code>重新把暂存区内容放到本地</li></ul><p>这里的<code>stash apply</code>成功的把暂存区的一次暂存恢复到了本地，但是暂存区还有会保存这次暂存，如果想删除这次暂存要用<code>git stash drop</code>来删除；也可以用<code>git stash pop</code>，恢复最后一次暂存的同时把stash内容也删了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (bfdc065df8adc44c8b69fa6826e75c5991e6cad0)</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>好了，暂存区清干净了。</p><pre><code>注意：要放到暂存区的文件一定要先通过git add加到index</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文阅读结束以后，我们学会了</p><ul><li>Git的基本概念，知道git的作用、历史；学会安装配置Git，使用Git创建项目托管以及工作区和暂存区的概念</li><li>学会Git的本地操作，提交、拉代码、创建切换删除分支操作，</li><li>多人合作时的代码版本控制，学会了不同情况下的合并冲突、暂存代码操作</li></ul><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>Git常用操作（下）我计划给大家介绍以下点：</p><ul><li>后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）</li><li>哎呀，提交的时候漏了文件</li><li>tag操作</li><li>git忽略不想提交的文件</li></ul><p>下集传送门：<br><a href="/git-start3" target="view_window">版本控制工具——Git常用操作（下）</a></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记</p><blockquote><p>不可使用自己不熟悉的命令<br>任何命令，不要加上-f的强制参数，否则可能导致代码丢失<br>建议多使用命令行，不要使用图形界面操作</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站-git篇</a></p><p><a href="https://ihaoming.top/archives/c9c37af.html#more" target="_blank" rel="noopener">hexo博客部署到vps</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> git教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql备份还原方案xtrabackup</title>
      <link href="/mysql-backup-xtrabackup/"/>
      <url>/mysql-backup-xtrabackup/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：mysql当数据库过大的时候，使用mysqldump的方式进行备份是一种非常慢的操作，500G的数据就够你备份一天一夜，我发现了一种mysql快速备份的方案，它使用文件存储的方式进行备份，支持全量和增量备份，这里所写为全量方式（如果可以接受备份开始到下次恢复之间的数据丢失时使用）。xtrabackup的备份速度很快，不管有多少的数据，备份速度完全是依赖于磁盘的读写速度，还支持压缩、不打断正在执行的事务、自动实现备份检验（用mysqldump会锁表，要加上可重复读–single-transaction才不会影响线上的程序写表，但是写表后的东西在还原的时候就会丢了，这也是全量备份的痛点）</p><a id="more"></a><ul><li><a href="#特点">特点</a></li><li><a href="#准备mysql备份组件需要的安装包">准备mysql备份组件需要的安装包</a></li><li><a href="#安装备份工具">安装备份工具</a><ul><li><a href="#1-上传并解压">1. 上传并解压</a></li><li><a href="#2-安装rpm包">2. 安装rpm包</a></li><li><a href="#3-检查是否安装成功">3. 检查是否安装成功</a></li></ul></li><li><a href="#开始备份">开始备份</a><ul><li><a href="#1-执行命令开始备份">1. 执行命令开始备份</a></li><li><a href="#2-检查是否备份成功">2. 检查是否备份成功</a></li></ul></li><li><a href="#还原备份">还原备份</a><ul><li><a href="#1-事务日志应用到备份">1. 事务日志应用到备份</a></li><li><a href="#2-恢复数据">2. 恢复数据</a></li><li><a href="#3-设置属主属组为mysql并启动">3. 设置属主属组为mysql并启动</a></li></ul></li><li><a href="#引用">引用</a></li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>(1)备份过程快速、可靠</p><p>(2)备份过程不会打断正在执行的事务</p><p>(3)能够基于压缩等功能节约磁盘空间和流量</p><p>(4)自动实现备份检验</p><p>(5)还原速度快</p><h1 id="准备mysql备份组件需要的安装包"><a href="#准备mysql备份组件需要的安装包" class="headerlink" title="准备mysql备份组件需要的安装包"></a>准备mysql备份组件需要的安装包</h1><p>检查服务器是centos6版本还是centos7+版本。选择安装包<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos6/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</span><br><span class="line">centos7/percona-xtrabackup/Percona-XtraBackup-2.4.12-r170eb8c-el7-x86_64-bundle.tar</span><br></pre></td></tr></table></figure><p></p><p>安装包可以在此下载 ： <a href="https://www.percona.com/downloads/XtraBackup/LATEST/" target="_blank" rel="noopener">https://www.percona.com/downloads/XtraBackup/LATEST/</a></p><h1 id="安装备份工具"><a href="#安装备份工具" class="headerlink" title="安装备份工具"></a>安装备份工具</h1><p><font color="red">以下所有操作如果是在集群下，要在一个主节点上操作，操作一次即可</font>，启动时设置主节点为被同步节点，集群的管理我们以后再讨论。</p><h2 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1. 上传并解压"></a>1. 上传并解压</h2><p>假设当前系统是centos6+,使用<code>Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</code>包，拷贝到系统<code>/tmp/backup_mariadb20181127</code>目录下(没有则创建,日期写当天)，使用<code>tar xvf Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</code>命令解压,你可以得到以下文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pwd</span><br><span class="line">/tmp/backup_mariadb20181127</span><br><span class="line"># ls</span><br><span class="line">Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar</span><br><span class="line">percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line">percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  </span><br><span class="line">percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="2-安装rpm包"><a href="#2-安装rpm包" class="headerlink" title="2. 安装rpm包"></a>2. 安装rpm包</h2><p>执行以下命令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  </span><br><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line">rpm -ivh --force --nodeps percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p></p><h2 id="3-检查是否安装成功"><a href="#3-检查是否安装成功" class="headerlink" title="3. 检查是否安装成功"></a>3. 检查是否安装成功</h2><p>按以下显示则安装成功<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -qa | grep percona</span></span><br><span class="line">percona-xtrabackup-test-24-2.4.12-1.el6.x86_64</span><br><span class="line">percona-xtrabackup-24-2.4.12-1.el6.x86_64</span><br><span class="line">percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64</span><br></pre></td></tr></table></figure><p></p><h1 id="开始备份"><a href="#开始备份" class="headerlink" title="开始备份"></a>开始备份</h1><h2 id="1-执行命令开始备份"><a href="#1-执行命令开始备份" class="headerlink" title="1. 执行命令开始备份"></a>1. 执行命令开始备份</h2><p>执行以下命令开始备份，其中<code>/etc/my.cnf</code>为mysql配置文件位置，10.123.2.4为mysql绑定的ip（写当前机器的ip）,user1为用户名，123456Abc为密码，/tmp/backup_mariadb20181127为备份文件所在目录，所有按实际环境填写。此处我们只备份cloud库所以<code>--databases</code>库就不用改动了<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --defaults-file=/etc/my.cnf --host=10.123.2.4 --databases="cloud" --use-memory=500M --user=user1 --password=123456Abc /tmp/backup_mariadb20181127</span><br></pre></td></tr></table></figure><p></p><ul><li>如果只需要备份其中一个或多个数据库，可以加参数<code>--databases=&quot;cloud test&quot;</code>,其中cloud和test是库名</li><li>可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。</li></ul><h2 id="2-检查是否备份成功"><a href="#2-检查是否备份成功" class="headerlink" title="2. 检查是否备份成功"></a>2. 检查是否备份成功</h2><p>最后一行显示completed OK！ 则备份成功，在所执行的目录下（此处是/tmp/backup_mariadb20181127）会出现备份的文件<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">181127 11:56:48 completed OK!</span><br></pre></td></tr></table></figure><p></p><p>可以看到文件结构，我们此处自动生成的备份文件夹名为<code>2018-11-27_11-52-48</code>，是一个以时间命名的文件夹<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">2018-11-27_11-52-48</span><br><span class="line"> Percona-XtraBackup-2.4.12-r170eb8c-el6-x86_64-bundle.tar  percona-xtrabackup-24-2.4.12-1.el6.x86_64.rpm  percona-xtrabackup-24-debuginfo-2.4.12-1.el6.x86_64.rpm  percona-xtrabackup-test-24-2.4.12-1.el6.x86_64.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/backup_mariadb20181127</span><br></pre></td></tr></table></figure><p></p><h1 id="还原备份"><a href="#还原备份" class="headerlink" title="还原备份"></a>还原备份</h1><h2 id="1-事务日志应用到备份"><a href="#1-事务日志应用到备份" class="headerlink" title="1. 事务日志应用到备份"></a>1. 事务日志应用到备份</h2><p>备份出的数据并不能直接使用，因为备份出的数据是不一致的，我们还需要将同时备份出的事务日志应用到备份中，才能得到一份完整、一致、可用的数据，xtrabackup称这一步操作为prepare，也就是还原数据前的”准备”工作。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --apply-log 2018-11-27_11-52-48/</span><br></pre></td></tr></table></figure><p></p><p>在事务日志容量很大的情况下，可以使用–use-memory= (例如： 1MB, 1M, 1GB, 1G)选项加速，在不指定内存大小的情况下，默认会占用100MB的内存。<br>输出最后如下就为正确<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">181127 11:56:10 completed OK!</span><br></pre></td></tr></table></figure><p></p><h2 id="2-恢复数据"><a href="#2-恢复数据" class="headerlink" title="2. 恢复数据"></a>2. 恢复数据</h2><p>方法一、此处使用该方法，适用于备份部分数据库的方法<br>数据目录在<code>/data/mariadb/data</code>，我们备份的数据库为cloud库。<br>进入mysql命令行<code>mysql -A</code>，删除cloud库<code>drop database cloud;</code>(如果无法进入命令行则到数据目录下直接干掉cloud文件夹，集群操作的话必须通过drop或者先停止集群，确定好主从模式)<br>执行命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/mariadb/data</span><br><span class="line">rm ib* -f</span><br><span class="line">rm -f cloud</span><br><span class="line">/etc/init.d/mysqld stop <span class="comment">#关闭数据库</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/backup_mariadb20181127/2018-11-27_11-52-48 <span class="comment">#进入备份目录</span></span><br><span class="line">cp ib* /data/mariadb/data</span><br><span class="line">cp -R cloud /data/mariadb/data</span><br></pre></td></tr></table></figure><p></p><p>方法二、先停止数据库服务<code>/etc/init.d/mysqld stop</code>，且对应的数据目录(此处是<code>/data/mariadb/data</code>)为空,如果不为空，手动删除，一般此方法针对全量备份的方法。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex  --datadir=/data/mariadb/data --copy-back /tmp/backup_mariadb20181127/2018-11-27_11-52-48</span><br></pre></td></tr></table></figure><p></p><p>–copy-back：对应的目录就是我们准备好的可用数据的目录。此处为<code>/tmp/backup_mariadb20181127/2018-11-27_11-52-48</code></p><p>–datadir：指定的目录就是还原后数据要存放的目录，如果my.cnf设置了datadir，可以省略–datadir，执行copyback时会读取my.cnf中的配置，datadir目录必须为空目录,如果不为空，手动删除。</p><h2 id="3-设置属主属组为mysql并启动"><a href="#3-设置属主属组为mysql并启动" class="headerlink" title="3. 设置属主属组为mysql并启动"></a>3. 设置属主属组为mysql并启动</h2><p>此时我们还不能启动mysql，因为我们是使用root用户拷贝的数据，所以数据目录中的数据文件的属主属组仍然为root，我们需要将这些文件的属主属组设置为mysql。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/mariadb/data</span><br><span class="line">chown -R mysql.mysql *</span><br><span class="line">chown -R mysql.mysql /data/mariadb/binlog</span><br><span class="line">/etc/inid.d/mysqld start</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="http://www.cnblogs.com/zhoujinyi/p/4088866.html" target="_blank" rel="noopener">Xtrabackup 安装使用</a><br><a href="https://blog.csdn.net/fanren224/article/details/79693863" target="_blank" rel="noopener">xtrabackup 原理</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备份mysql数据库 </tag>
            
            <tag> mysql教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq管理利器——rabbitmqadmin</title>
      <link href="/rabbitmqadmin/"/>
      <url>/rabbitmqadmin/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：在运维rabbitmq集群的过程中，发生了队列的严重堆积，我们在可以容忍mq消息丢失的情况下，使用常用的<code>purge_queue queue</code>命令等好长时间都清理不成功，在管理页面上直接purge导致页面卡住不动，最终都没有办法达到清理成功的效果。这个时候发现了一个python的rabbitmq管理工具，非常的好用且迅速，在此记录。</p><a id="more"></a><ul><li><a href="#如何获取rabbitmqadmin">如何获取rabbitmqadmin</a></li><li><a href="#常用命令">常用命令</a><ul><li><a href="#查看">查看</a></li><li><a href="#系统操作">系统操作</a></li><li><a href="#用户管理操作">用户管理操作</a></li><li><a href="#队列操作">队列操作</a></li></ul></li><li><a href="#其他">其他</a><ul><li><a href="#指定输出格式">指定输出格式</a></li><li><a href="#用户角色">用户角色</a></li><li><a href="#rabbitmqctl-命令">rabbitmqctl 命令</a></li></ul></li><li><a href="#参考">参考</a></li></ul><h1 id="如何获取rabbitmqadmin"><a href="#如何获取rabbitmqadmin" class="headerlink" title="如何获取rabbitmqadmin"></a>如何获取rabbitmqadmin</h1><p><strong>方法1.</strong> 直接复制出来<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cp -a /var/lib/rabbitmq/mnesia/rabbit@localhost-plugins-expand/rabbitmq_management-3.3.5/priv/www/cli/rabbitmqadmin /usr/local/bin/rabbitmqadmin</span><br><span class="line">``` </span><br><span class="line">**方法2** 从管理页面获取</span><br><span class="line"></span><br><span class="line">1. 打开`rabbitmq_management`，访问15672管理页面，方法见&lt;a href="https://qupzhi.com/first-blog" target="_blank"&gt;rabbitmq集群的各种运维操作 4.2 打开15672网页管理端，访问mq  &lt;/a&gt;</span><br><span class="line">2. 访问 ip:15672/rabbitmqadmin</span><br><span class="line">下载页面，另存为`rabbitmqadmin.py`,放到此目录：`/usr/local/bin/rabbitmqadmin`，授权`chmod +x /usr/local/bin/rabbitmqadmin`</span><br><span class="line"></span><br><span class="line">多一句废话：可以使用wget直接下载页面上的东西</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看</span></span></span><br><span class="line">```bash</span><br><span class="line">rabbitmqadmin list users                #查看用户列表</span><br><span class="line">rabbitmqadmin list vhosts               #查看vhosts</span><br><span class="line">rabbitmqadmin list connections          ###查看 connections</span><br><span class="line">rabbitmqadmin list exchanges            ##查看 exchanges</span><br><span class="line">rabbitmqadmin list bindings             ##查看 bindings</span><br><span class="line">rabbitmqadmin list permissions          ##查看 permissions</span><br><span class="line">rabbitmqadmin list channels             ##查看 channels</span><br><span class="line">rabbitmqadmin list parameters           ##查看 parameters</span><br><span class="line">rabbitmqadmin list consumers            ##查看consumers</span><br><span class="line">rabbitmqadmin list queues               ##查看queues</span><br><span class="line">rabbitmqadmin list policies             ##查看policies</span><br><span class="line">rabbitmqadmin list nodes                ##查看nodes</span><br><span class="line">rabbitmqadmin show overview             ##查看overview</span><br></pre></td></tr></table></figure><p></p><h2 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h2><h2 id="用户管理操作"><a href="#用户管理操作" class="headerlink" title="用户管理操作"></a>用户管理操作</h2><ol><li><p>新增一个用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  add_user  Username  Password</span><br><span class="line">rabbitmqadmin declare user name=wyl password=password tags=administrator</span><br></pre></td></tr></table></figure></li><li><p>删除一个用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  delete_user  Username</span><br></pre></td></tr></table></figure></li><li><p>修改用户的密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  change_password  Username  Newpassword</span><br></pre></td></tr></table></figure></li><li><p>查看当前用户列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  list_users</span><br><span class="line">rabbitmqadmin list users    # 查看 users</span><br><span class="line">rabbitmqadmin list users name # 查看 users的时候限制字段</span><br></pre></td></tr></table></figure></li><li><p>设置用户角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  User  Tag</span><br></pre></td></tr></table></figure></li></ol><p>User为用户名， Tag为角色名(对应于<code>administrator，monitoring，policymaker，management</code>，或其他自定义名称见<a href="#用户角色">用户角色</a>)。<br>也可以给同一用户设置多个角色，例如<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  set_user_tags  hncscwc  monitoring policymaker</span><br></pre></td></tr></table></figure><p></p><h2 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h2><p>添加queue<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin <span class="built_in">declare</span> queue name=<span class="built_in">test</span> durable=<span class="literal">true</span>    <span class="comment">## durable=true 代表持久化打开  declare是宣布的意思</span></span><br><span class="line">rabbitmqadmin --vhost=<span class="built_in">test</span> --username=admin --password=admin  <span class="built_in">declare</span> queue name=<span class="built_in">test</span> durable=<span class="literal">true</span> <span class="comment">#指定vhost添加队列</span></span><br></pre></td></tr></table></figure><p></p><p>查看queues<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list queues</span></span><br><span class="line"><span class="comment">#查看bindings</span></span><br><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list bindings</span></span><br></pre></td></tr></table></figure><p></p><p>添加消息到test queue<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin publish routing_key=<span class="built_in">test</span> payload=<span class="string">"this is a testing"</span>     <span class="comment">##未指定exchange默认 exchange name为空</span></span><br></pre></td></tr></table></figure><p></p><p>再次查看对列发现test有一条消息<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq1 sbin]<span class="comment"># rabbitmqadmin list queues</span></span><br></pre></td></tr></table></figure><p></p><p>从test queue消费一条信息<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin get queue=<span class="built_in">test</span> requeue=<span class="literal">true</span>   <span class="comment">#requeue=true 这条消息消费后还在，反之如果为false消费后消息就不在了。</span></span><br></pre></td></tr></table></figure><p></p><p>删除队列<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin delete queue name=<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>清除队列消息内容<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqadmin purge queue name=队列名</span><br></pre></td></tr></table></figure><p></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="指定输出格式"><a href="#指定输出格式" class="headerlink" title="指定输出格式"></a>指定输出格式</h2><p>使用 -f 可以指定格式<br>有如下几种格式 raw_json, long, pretty_json, kvp, tsv, table, bash 默认为 table,具体自己试</p><h2 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h2><ol><li>超级管理员(administrator)<br>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>监控者(monitoring)<br>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li>策略制定者(policymaker)<br>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。<br>与administrator的对比，administrator能看到这些内容</li><li>普通管理者(management)<br>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</li><li>其他<br>无法登陆管理控制台，通常就是普通的生产者和消费者。<br>了解了这些后，就可以根据需要给不同的用户设置不同的角色，以便按需管理。</li></ol><h2 id="rabbitmqctl-命令"><a href="#rabbitmqctl-命令" class="headerlink" title="rabbitmqctl 命令"></a>rabbitmqctl 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_queues：查看所有队列信息</span><br><span class="line"></span><br><span class="line">rabbitmqctl stop_app：关闭应用（关闭当前启动的节点）</span><br><span class="line"></span><br><span class="line">rabbitmqctl start_app：启动应用，和上述关闭命令配合使用，达到清空队列的目的</span><br><span class="line"></span><br><span class="line">rabbitmqctl reset：从管理数据库中移除所有数据，例如配置过的用户和虚拟宿主, 删除所有持久化的消息（这个命令要在rabbitmqctl stop_app之后使用）</span><br><span class="line"></span><br><span class="line">rabbitmqctl force_reset：作用和rabbitmqctl reset一样，区别是无条件重置节点，不管当前管理数据库状态以及集群的配置。如果数据库或者集群配置发生错误才使用这个最后的手段</span><br><span class="line"></span><br><span class="line">rabbitmqctl status：节点状态</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_user username password：添加用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_users：列出所有用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_user_permissions username：列出用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl change_password username newpassword：修改密码</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_vhost vhostpath：创建虚拟主机</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_vhosts：列出所有虚拟主机</span><br><span class="line"></span><br><span class="line">rabbitmqctl set_permissions -p vhostpath username ".*" ".*" ".*"：设置用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl list_permissions -p vhostpath：列出虚拟主机上的所有权限 </span><br><span class="line"></span><br><span class="line">rabbitmqctl clear_permissions -p vhostpath username：清除用户权限</span><br><span class="line"></span><br><span class="line">rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息</span><br><span class="line"></span><br><span class="line">rabbitmqctl delete_user username：删除用户</span><br><span class="line"></span><br><span class="line">rabbitmqctl delete_vhost vhostpath：删除虚拟主机</span><br></pre></td></tr></table></figure><p>未完待续-催更 <a href="mailto:pzqu@qq.com" target="_blank" rel="noopener">pzqu@qq.com</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/wylfengyujiancheng/article/details/67063083b" target="_blank" rel="noopener">通过rabbitmqadmin管理rabbitmq,【吴业亮】云计算开发工程师</a></p><p><a href="https://www.cnblogs.com/wuzhiyuan/p/6856985.html" target="_blank" rel="noopener">RabbitMQ学习笔记四：RabbitMQ命令（附疑难问题解决）</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq集群 </tag>
            
            <tag> 工具 </tag>
            
            <tag> rabbitmq工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq之Federation配置</title>
      <link href="/rabbitmq-federation/"/>
      <url>/rabbitmq-federation/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：当我们有多个rabbitmq集群的时候，如果想要单向的同步集群的消息，也就是说把新集群当作老集群的镜像集群，实时的同步老集群的消息，在老集群消息被消费的时候不会影响同步到新集群的消息。在外部看上去就像每次写入消息的时候，同时向新老两个集群写入一样,不论mq的跨版本，不论mq的用户。一般我们会将这种情况应用于存在两个不同的系统，但是老数据来源只能向一个队列写入数据，此时为了在新系统上也可以实时同步到老系统队列中的数据的时候。</p><a id="more"></a><ul><li><a href="#federation介绍">Federation介绍</a><ul><li><a href="#特点">特点</a><ul><li><a href="#松耦合性loose-coupling">松耦合性（Loose coupling）</a></li><li><a href="#wan-友好性wan-friendly">WAN 友好性（WAN-friendly）</a></li><li><a href="#扩展性scalability">扩展性（Scalability）</a></li></ul></li><li><a href="#federation能做什么">federation能做什么？</a></li><li><a href="#配置的种类">配置的种类</a></li><li><a href="#身份验证">身份验证</a></li></ul></li><li><a href="#操作步骤说明">操作步骤说明</a><ul><li><a href="#1-在集群的每一个node开启federation插件同步和被同步集群都需要">1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)</a></li><li><a href="#2-登录到同步集群的管理界面httpxxx15672">2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/</a></li><li><a href="#3-创建upstream">3. 创建upstream</a></li><li><a href="#4-创建policy">4. 创建policy</a></li><li><a href="#5-查看状态图">5. 查看状态图</a></li><li><a href="#6-查看连接">6. 查看连接</a></li></ul></li><li><a href="#高级">高级</a></li><li><a href="#参考">参考</a></li></ul><h1 id="Federation介绍"><a href="#Federation介绍" class="headerlink" title="Federation介绍"></a>Federation介绍</h1><blockquote><p>federation 插件的最终目标是，在不同 broker 之间进行消息传递而无需建立集群；该功能在很多场景下非常有用：</p></blockquote><p><strong>注意:当你在一个cluster中使用federation插件，所有在集群中 的nodes都需要安装federation插件</strong></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="松耦合性（Loose-coupling）"><a href="#松耦合性（Loose-coupling）" class="headerlink" title="松耦合性（Loose coupling）"></a>松耦合性（Loose coupling）</h3><ul><li>federation 插件能够在分属不同管理域的 broker 或 cluster 之间传递消息：</li><li>他们可能设置了不同的 user 和 vhost ；</li><li>他们可能运行在不同版本的 RabbitMQ 和 Erlang 上；</li></ul><h3 id="WAN-友好性（WAN-friendly）"><a href="#WAN-友好性（WAN-friendly）" class="headerlink" title="WAN 友好性（WAN-friendly）"></a>WAN 友好性（WAN-friendly）</h3><ul><li>federation 插件基于 AMQP 0-9-1 协议在不同 broker 之间进行通信，并设计成能够容忍不稳定的网络连通情况；</li></ul><h3 id="扩展性（Scalability）"><a href="#扩展性（Scalability）" class="headerlink" title="扩展性（Scalability）"></a>扩展性（Scalability）</h3><ul><li>federation 不需要在 n 个 broker 之间建立 O(n^2) 个连接（尽管这是最简单的使用模式），这也就意味着 federation 在使用时更容易扩展</li></ul><h2 id="federation能做什么？"><a href="#federation能做什么？" class="headerlink" title="federation能做什么？"></a>federation能做什么？</h2><blockquote><p>federation 插件允许你将多个 exchange 或多个 queue 进行 federate ；federated exchange 或 federated queue 能够从一个或多个 upstream 接收到消息；</p></blockquote><p>也就是说，你的队列可以和其他集群的队列建立一种关系，他们之间可以相互的同步数据，可以是我同步给你，也可以是你同步给我，不过这种关系有两个角色一个是上游一个是下游，数据流向是上游流向下流。<br>这里有三个名词，federation 插件允许你将多个 exchange 或多个 queue 进行 federate：</p><ul><li>upstream： 上游，是指位于其他 broker 上的、远端 exchange 和 queue ；</li><li>federated exchange： 到exchange的关系，能够将发给 upstream 的消息路由到本地的某个 queue 中；</li><li>federated queue： 到queue的关系，则允许一个本地消费者接收到来自 upstream queue 的消息；</li></ul><h2 id="配置的种类"><a href="#配置的种类" class="headerlink" title="配置的种类"></a>配置的种类</h2><p>关于 federation upstream 的信息全都保存在 RabbitMQ 的数据库中，其中包括了 user 信息、permission 信息、queue 信息等等；<br>在 federation 中存在 3 种界别的配置：</p><ul><li>Upstreams - 每一个 upstream 用于定义如何与另外的 broker 建立连接；</li><li>Upstream sets - 每一个 upstream set 用于针对一系列使用 federation 功能 upstream 进行了分组；</li><li>Policies - 每一种 policy 会限定（过滤）出一组 exchange ，或者一组 queue ，或者同时针对两者进行限定；policy 最终将作用于一个单独的 upstream 上，或者一个 upstream set 上，并对其他对象发挥作用；</li></ul><p><em>实际上，在最简单的使用情况下，你可以忽略已经存在的upstream设置，因为有一个隐含的默认upstream叫做“all”，他会添加所有的upstream。</em></p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>我们讨论的是免身份验证的方式，如果有身份难的需求请参考官网：<a href="http://www.rabbitmq.com/authentication.html" target="_blank" rel="noopener">http://www.rabbitmq.com/authentication.html</a></p><h1 id="操作步骤说明"><a href="#操作步骤说明" class="headerlink" title="操作步骤说明"></a>操作步骤说明</h1><blockquote><p>parameter 和 policy 可以通过 3 种方式进行设置：<br>通过 rabbitmqctl 脚本；<br>通过 management 插件提供的 HTTP API ；<br>通过 rabbitmq_federation_management 插件提供的 Web UI（更通用的方式,我们也是通过页面来配置就可以了）；注意：基于 Web UI 的方式不能提供全部功能，尤其无法针对 upstream set 进行管理；</p></blockquote><h2 id="1-在集群的每一个node开启federation插件-同步和被同步集群都需要"><a href="#1-在集群的每一个node开启federation插件-同步和被同步集群都需要" class="headerlink" title="1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)"></a>1. 在集群的每一个node开启federation插件(同步和被同步集群都需要)</h2><p>参考命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></table></figure><p></p><h2 id="2-登录到同步集群的管理界面-http-x-x-x-15672"><a href="#2-登录到同步集群的管理界面-http-x-x-x-15672" class="headerlink" title="2. 登录到同步集群的管理界面::http://x.x.x.:15672/#/"></a>2. 登录到同步集群的管理界面::<a href="http://x.x.x.:15672/#/" target="_blank" rel="noopener">http://x.x.x.:15672/#/</a></h2><h2 id="3-创建upstream"><a href="#3-创建upstream" class="headerlink" title="3. 创建upstream"></a>3. 创建upstream</h2><p>tips:在下游，也就是新队列（被同步队列）上操作</p><p><img src="/rabbitmq-federation/upstream.png" alt="upstrem"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin-&gt;Federation Upstreams-&gt;Add a new upstream Name:随意填写 URI:填被同步集群(例如:amqp://user1:xxx@x.x.x.x,xxx为连接密码) Expires:默认填写3600000 单位ms</span><br><span class="line">其余字段可不用填写</span><br></pre></td></tr></table></figure><p><strong>Expires</strong>：是代表缓存时间，如果说网络连通性不好的时候，消息会在上游的队列中缓存的时间，超时丢弃，设置为空则表示，永远缓存不会丢弃数据（但是如果长时候不恢复内存会占用越来越大，建议设置上）<br><strong>Acknowledgement Mode</strong>: 代表消息确认方式，用来防止消息在传输过程中丢失，有三个值，on-confirm、on-publish、no-ack，对传输速度的影响是从慢速到快速，对安全性是不会丢失到可能会丢失。通常使用<code>on-publish</code>，不然<code>on-confirm</code>太慢了。</p><h2 id="4-创建policy"><a href="#4-创建policy" class="headerlink" title="4. 创建policy"></a>4. 创建policy</h2><p>tips:在下游，也就是新队列（被同步队列）上操作<br><img src="/rabbitmq-federation/policy.png" alt="policy"><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin-&gt;Policies-&gt;Add / update a policy</span><br><span class="line">Name:随意填写(sync_data)</span><br><span class="line">Pattern:匹配表达式(例如:^(?!amq.).* 剔除系统队列后的所有队列)</span><br><span class="line">Apply to: 默认选择Exchange and queues Definition:federation-upstream-set = all (选定federation规则)</span><br></pre></td></tr></table></figure><p></p><h2 id="5-查看状态图"><a href="#5-查看状态图" class="headerlink" title="5. 查看状态图"></a>5. 查看状态图</h2><p>现在，所有内置的 exchange 都应该建立了 federation ，因为他们都能匹配上面的 policy，可以通过页面查看状态<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UI操作:Admin &gt; Federation Status &gt; Running Links 查看针对每个 exchange 的 federation 连接。</span><br><span class="line">配置成功可以看到匹配的Exchange / Queue， state:running</span><br></pre></td></tr></table></figure><p></p><p>也可以通过下面的命令查看状态图：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl eval 'rabbit_federation_status:status().'</span><br></pre></td></tr></table></figure><p></p><p>也可以通过 management 插件中的 exchange 列表，或者下面的命令输出，确认上述 policy 已经作用到了 exchange 上；<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_exchanges name policy | grep federate-me</span><br></pre></td></tr></table></figure><p></p><p>通常情况下，针对每个 upstream 都会有一条 federation 连接，该 federation 连接对应到一个 exchange 上；例如 3 个 exchange 与 2 个 upstream 分别建立 federation 的情况下，会有 6 条连接。</p><h2 id="6-查看连接"><a href="#6-查看连接" class="headerlink" title="6. 查看连接"></a>6. 查看连接</h2><pre><code>登录到被同步集群（上游）的管理界面::http://x.x.x.:15672/#/ 前往 Connections选项 配置成功可以看到来自同步集群的连接</code></pre><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>更复杂的配置：<a href="https://www.rabbitmq.com/federation-reference.html" target="_blank" rel="noopener">https://www.rabbitmq.com/federation-reference.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.rabbitmq.com/federation.html" target="_blank" rel="noopener">官网</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq集群 </tag>
            
            <tag> rabbitmq教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ansible_roles</title>
      <link href="/ansible-roles/"/>
      <url>/ansible-roles/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：本节主要总结ansiblerroles中常用的语法以及高级特性、例如变量、下载、解压、修改文件内容等,便于使用ansible协同开发，做更加庞大的任务。</p><a id="more"></a><ul><li><a href="#常用">常用</a><ul><li><a href="#远程执行脚本">远程执行脚本</a></li><li><a href="#设置某个参数供下文使用">设置某个参数供下文使用</a></li><li><a href="#文件是否存在和变量是否声明">文件是否存在和变量是否声明</a></li><li><a href="#解压">解压</a></li><li><a href="#下载">下载</a></li><li><a href="#修改文件内容直接替换方式">修改文件内容，直接替换方式</a></li><li><a href="#配置文件">配置文件</a></li><li><a href="#执行命令时指定脚本执行目录">执行命令时指定脚本执行目录</a></li></ul></li><li><a href="#高级">高级</a><ul><li><a href="#委托">委托</a></li></ul></li><li><a href="#统一目录结构">统一目录结构</a></li><li><a href="#引用">引用</a></li></ul><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="远程执行脚本"><a href="#远程执行脚本" class="headerlink" title="远程执行脚本"></a>远程执行脚本</h2><ol><li><p>脚本放到template里</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">init</span> <span class="string">rbac</span> <span class="string">rights</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">'init_rbac_privilege.sh'</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">'/tmp/init_rbac_privilege.sh'</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">init</span> <span class="string">rbac</span> <span class="string">rights</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"bash /tmp/init_rbac_privilege.sh"</span></span><br><span class="line"><span class="attr">  run_once:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></li><li><p>脚本放files文件里</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">copy</span> <span class="string">script</span> <span class="string">file</span> <span class="string">to</span> <span class="string">remote</span> <span class="string">server</span></span><br><span class="line"><span class="attr">  copy:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"generate_uuid.py"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">and</span> <span class="string">args</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"python <span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="设置某个参数供下文使用"><a href="#设置某个参数供下文使用" class="headerlink" title="设置某个参数供下文使用"></a>设置某个参数供下文使用</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">path</span></span><br><span class="line"><span class="attr">  set_fact:</span></span><br><span class="line"><span class="attr">    dest_script_file:</span> <span class="string">'/tmp/generate_uuid.py'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">copy</span> <span class="string">script</span> <span class="string">file</span> <span class="string">to</span> <span class="string">remote</span> <span class="string">server</span></span><br><span class="line"><span class="attr">  copy:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"generate_uuid.py"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0755</span></span><br></pre></td></tr></table></figure><h2 id="文件是否存在和变量是否声明"><a href="#文件是否存在和变量是否声明" class="headerlink" title="文件是否存在和变量是否声明"></a>文件是否存在和变量是否声明</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- stat:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">"<span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">file_result</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">set</span> <span class="string">to</span> <span class="string">execute</span> <span class="string">script</span> <span class="string">file</span> <span class="string">and</span> <span class="string">args</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"python <span class="template-variable">&#123;&#123; dest_script_file &#125;&#125;</span> <span class="template-variable">&#123;&#123; inventory_hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">p_new_host_uuid</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">host_uuid</span> <span class="string">is</span> <span class="string">not</span> <span class="string">defined</span> <span class="string">and</span> <span class="string">file_result.stat.exists</span></span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>解压tar.gz，desc所指定的目录需要提前创建<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Unarchive</span> <span class="string">ceph_report</span> <span class="string">program</span> <span class="string">package</span></span><br><span class="line"><span class="attr">  unarchive:</span></span><br><span class="line"><span class="attr">    remote_src:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"/tmp/ceph_report/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/data/monitorcloud/script/"</span></span><br></pre></td></tr></table></figure><p></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">download</span> <span class="string">ceph_report</span> <span class="string">package</span></span><br><span class="line"><span class="attr">  get_url:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"http://<span class="template-variable">&#123;&#123; tstack_repo_address &#125;&#125;</span>:<span class="template-variable">&#123;&#123; tstack_repo_port &#125;&#125;</span>/tstack/tstack-tars/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/tmp/ceph_report/ceph_report.tar.gz"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0644</span></span><br></pre></td></tr></table></figure><h2 id="修改文件内容，直接替换方式"><a href="#修改文件内容，直接替换方式" class="headerlink" title="修改文件内容，直接替换方式"></a>修改文件内容，直接替换方式</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">insert</span> <span class="string">mons</span> <span class="string">connect</span> <span class="string">message</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">"/data/monitorcloud/script/ceph_report/host_dic"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">EOF</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">"<span class="template-variable">&#123;&#123;item[0]&#125;&#125;</span> <span class="template-variable">&#123;&#123;item[1]&#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_nested:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; groups['mons'] | union( groups['osds'] )&#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">["&#123;&#123;ansible_ssh_pass&#125;&#125;"]</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>ansible中指定配置文件，.j2中可映射ansible变量<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Prepare</span> <span class="string">ceph_report_http</span> <span class="string">program</span> <span class="string">configuration</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"opts.py.j2"</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">"/data/monitorcloud/script/ceph_report/opts.py"</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="number">0644</span></span><br></pre></td></tr></table></figure><p></p><h2 id="执行命令时指定脚本执行目录"><a href="#执行命令时指定脚本执行目录" class="headerlink" title="执行命令时指定脚本执行目录"></a>执行命令时指定脚本执行目录</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">execute</span> <span class="string">ceph_report_http</span> <span class="string">install</span> <span class="string">script</span></span><br><span class="line"><span class="attr">  shell:</span> <span class="string">"/usr/bin/python  ceph_report_http.py install"</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="attr">     chdir:</span> <span class="string">'/data/monitorcloud/script/ceph_report/'</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>在当前运行ansible的机器上，委托其他机器运行<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">host</span> <span class="string">record</span> <span class="string">to</span> <span class="string">center</span> <span class="string">server</span> </span><br><span class="line"><span class="attr"> shell:</span> <span class="string">'echo "192.168.1.100 test.xyz.com " &gt;&gt; /etc/hosts'</span></span><br><span class="line"><span class="attr"> delegate_to:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p></p><p>也可以委托ansible服务端运行<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">host</span> <span class="string">record</span> <span class="string">to</span> <span class="string">center</span> <span class="string">server</span> </span><br><span class="line"><span class="attr"> shell:</span> <span class="string">'echo hello'</span></span><br><span class="line"><span class="attr"> delegate_to:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure><p></p><h1 id="统一目录结构"><a href="#统一目录结构" class="headerlink" title="统一目录结构"></a>统一目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── filter_plugins          # 自定义 filter 插件存放目录</span><br><span class="line">├── fooapp                  # Fooapp 片色目录 ( 与 common 角色目录平级)</span><br><span class="line">├── group_vars             </span><br><span class="line">│   ├── group1              # group1 自定义变量文件</span><br><span class="line">│   └── group2              # group2 自定义变量文件</span><br><span class="line">├── host_vars</span><br><span class="line">│   ├── hostname1           # hostname1 自定义变量文件</span><br><span class="line">│   └── hostname2           # hostname1 自定义变量文件</span><br><span class="line">├── library                 # 自定义模块存放目录</span><br><span class="line">├── monitoring              # Monitoring 角色目录 ( 与 common 角色目录平级)</span><br><span class="line">├── roles                   # Role 存放目录</span><br><span class="line">│   └── common              # common 角色目录</span><br><span class="line">│       ├── defaults       </span><br><span class="line">│       │   └── main.yml    # common 角色自定义文件 (优先级低)</span><br><span class="line">│       ├── files</span><br><span class="line">│       │   ├── bar.txt     # common 角色 files 资源文件</span><br><span class="line">│       │   └── foo.sh      # common 角色 files 资源文件</span><br><span class="line">│       ├── handlers</span><br><span class="line">│       │   └── main.yml    # common 角色 handlers 入口文件</span><br><span class="line">│       ├── meta</span><br><span class="line">│       │   └── main.yml    # common 角色 依赖文件</span><br><span class="line">│       ├── tasks</span><br><span class="line">│       │   └── main.yml    # common 角色 task 入口文件</span><br><span class="line">│       ├── template</span><br><span class="line">│       │   └── ntp.conf.j2 # common 角色 template 文件</span><br><span class="line">│       └── vars</span><br><span class="line">│           └── main.yml    # common 角色 变量定义文件</span><br><span class="line">├── site.yaml               # Playbook 统一入口文件</span><br><span class="line">├── stage                   # stage 环境的 inventory 文件</span><br><span class="line">├── webservers.yml          # 特殊 Playbook 文件</span><br><span class="line">└── webtier                 # webtier 角色目录 ( 与 common 角色目录平级)</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>ansible进阶技巧 <a href="https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html</a></p><p>shilei ansible 文档 <a href="https://wiki.shileizcc.com/confluence/display/AN/Ansible" target="_blank" rel="noopener">https://wiki.shileizcc.com/confluence/display/AN/Ansible</a></p><p>骏马金龙 ansible系列文章 <a href="http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible" target="_blank" rel="noopener">http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进入自动化部署的大门-ansible</title>
      <link href="/ansible%E5%88%9D%E6%8E%A2/"/>
      <url>/ansible%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：ansible是运维与实施人员的福音，其优雅的结构，丰富的模块库，简单的编程方式都让其成为自动化部署的不二语言。现在就让我们了解ansible,并使用ansible来做一些简单的任务</p><a id="more"></a><ul><li><a href="#一基本概念">一、基本概念</a><ul><li><a href="#11-如何安装及安装要求">1.1 如何安装及安装要求</a></li><li><a href="#12-专有名词解释">1.2 专有名词解释</a></li><li><a href="#13-原理图">1.3 原理图</a></li><li><a href="#14-连接机制">1.4 连接机制</a></li><li><a href="#15-常用文件及配置位置">1.5 常用文件及配置位置</a></li></ul></li><li><a href="#二简单的例子">二、简单的例子</a><ul><li><a href="#21-配置被管控机器的连接信息">2.1 配置被管控机器的连接信息</a></li><li><a href="#22-执行命令">2.2 执行命令</a></li></ul></li><li><a href="#23-讨论执行命令的四个模块有什么区别">2.3 讨论执行命令的四个模块有什么区别</a></li><li><a href="#三-完成复杂的ansible操作">三、 完成复杂的ansible操作</a></li><li><a href="#引用">引用</a></li><li><a href="#资源">资源</a></li></ul><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><blockquote><p>Ansible是一款开源软件，可自动执行软件供应，配置管理和应用程序部署。Ansible通过SSH，远程PowerShell或其他远程API连接。—-选自wikipedia</p></blockquote><p>简介：ansible有两种服务器类型，控制机器与节点。控制机器就是安装ansible服务的机器，我们在上面编写和运行ansible的程序代码，并在控制机器上通过ssh远程操作机器（下发上传、执行命令）。当ansible脚本不运行的时候，不会占用任何资源（比如saltstack在运行的时候就会启动进程来监控4505/4506端口），也正由于ansible的这个特点，每次ansible发布更新的时候，只需要更新控制机器就可以了。</p><h2 id="1-1-如何安装及安装要求"><a href="#1-1-如何安装及安装要求" class="headerlink" title="1.1 如何安装及安装要求"></a>1.1 如何安装及安装要求</h2><p>要求：</p><ul><li>控制机是linux系统，需要有python2.6/2.7</li><li>linux系统打开文件数量设置大一些（方法自行百度）</li><li>节点要求，python2.4以上版本</li></ul><p>安装方法（有很多，在此只列出常用的方法，具体安装步骤不做赘述）：</p><ul><li>源码安装 git://github.com/ansible/ansible.git</li><li>yum 方式 / apt 方式 / emerge 方式 或其他linux系统的系统安装方式</li><li>pip 方式</li></ul><h2 id="1-2-专有名词解释"><a href="#1-2-专有名词解释" class="headerlink" title="1.2 专有名词解释"></a>1.2 专有名词解释</h2><table><thead><tr><th>关键字</th><th>释义</th></tr></thead><tbody><tr><td>playbook</td><td>剧本，将要执行的步骤全部放到playbook里面</td></tr><tr><td>modules（通常指core modules）</td><td>核心模块，用于执行某些任务的已有内置插件</td></tr><tr><td>roles</td><td>角色，像演戏一样，剧本中指定在什么时候哪个角色来做什么操作，所以剧本包含角色，角色就有自己的台词，不过ansible里面的角色特殊的地方是，剧本只知识角色是干什么的，具体操作步骤是在角色本身管理（无厘头）</td></tr><tr><td>custom modules</td><td>自定义模块，在核心模块不够用的时候可以自定义编写模块</td></tr><tr><td>plugins</td><td>插件，常用于ansible的日志系统与邮件系统，还有的插件有扩展内置连接方式、扩展变量定义方式、扩展内部循环语法、扩展新的过滤器等</td></tr><tr><td>Inventory</td><td>Ansible 管理主机的清单</td></tr></tbody></table><h2 id="1-3-原理图"><a href="#1-3-原理图" class="headerlink" title="1.3 原理图"></a>1.3 原理图</h2><p><img src="/ansible初探/20180819164218.png" alt="原理图"></p><h2 id="1-4-连接机制"><a href="#1-4-连接机制" class="headerlink" title="1.4 连接机制"></a>1.4 连接机制</h2><p>ansible通常使用的是ssh协议（或者Kerberos、LDAP）来进行连接（在openssh不支持的操作系统或ansible比较老的版本，ansible使用paramiko），ansible支持的连接方式有三种SSH、Local、ZeroMQ，在规模比较大的情况下使用ZeroMQ连接方式对执行速度有显著提高</p><h2 id="1-5-常用文件及配置位置"><a href="#1-5-常用文件及配置位置" class="headerlink" title="1.5 常用文件及配置位置"></a>1.5 常用文件及配置位置</h2><table><thead><tr><th>文件</th><th>位置</th></tr></thead><tbody><tr><td>ansible应用程序的主配置文件</td><td>/etc/ansible/ansible.cfg</td></tr><tr><td>定义管控主机</td><td>/etc/ansible/hosts</td></tr></tbody></table><h1 id="二、简单的例子"><a href="#二、简单的例子" class="headerlink" title="二、简单的例子"></a>二、简单的例子</h1><p>这里我们来实现在所有被管控机器上执行<code>hostname</code>命令输出主机名</p><h2 id="2-1-配置被管控机器的连接信息"><a href="#2-1-配置被管控机器的连接信息" class="headerlink" title="2.1 配置被管控机器的连接信息"></a>2.1 配置被管控机器的连接信息</h2><p><img src="/ansible初探/20180819164958.png" alt="配置被管控机器的连接信息"></p><ul><li>备注1：在<code>/etc/ansible/hosts</code>位置写入一个主机组（分组名为<code>test</code>），以后针对这个分组操作就视为对分组内的所有主机操作。</li><li>备注2：<code>[test:vars]</code> 标签下为<code>test</code>分组的变量，<code>ansible_ssh_user</code>和<code>ansible_ssh_pass</code>是ansible的内置变量，意思为该分组下所有主机的用户和和密码，当前了也可以单独指定某台主机只需要将这两个参数追加到ip的旁边就好。这里三台主机都是同一个用户名和密码，所以像这样配置。</li><li>备注3：默认路径是在<code>/etc/ansible/hosts</code>,如果你不喜欢是可以修改的(修改配置文件<code>/etc/ansible/ansible.cfg</code>的<code>inventory=/etc/ansible/hosts</code>即可)<h2 id="2-2-执行命令"><a href="#2-2-执行命令" class="headerlink" title="2.2 执行命令"></a>2.2 执行命令</h2></li></ul><p>执行命令，输出<code>test</code>分组下的所有主机的主机名，<code>-i</code>指定主机或分组,<code>-m</code>指定使用的模块，<code>-a</code>指定传给模块的参数，这里<code>command</code>模块就是执行linux命令的模块缺省时默认使用该模块，相同作用的还有<code>shell</code>模块、<code>raw</code>模块、<code>script</code>模块（使用场景与部分细节上不同，后面探讨）<br><img src="/ansible初探/20180827230444.png" alt="20180827230444.png"></p><h1 id="2-3-讨论执行命令的四个模块有什么区别"><a href="#2-3-讨论执行命令的四个模块有什么区别" class="headerlink" title="2.3 讨论执行命令的四个模块有什么区别"></a>2.3 讨论执行命令的四个模块有什么区别</h1><p>每次在使用的时候都会有一些迷惑，为什么非要弄四个执行命令的模块出来，一开始决定没有必要，但是到后来才明白存在既合理，这里和大家探讨一下</p><table><thead><tr><th>模块</th><th>解释</th></tr></thead><tbody><tr><td><code>command模块</code></td><td>是为了安全的执行linux命令，所以不支持`”&lt;”, “&gt;”, “</td><td>“, 和 “&amp;”`等符号（没有shell注入风险），如果要一定要使用这些，则使用shell模块</td></tr><tr><td><code>shell模块</code></td><td>通过<code>/bin/sh</code>来执行，其他都和command一样</td></tr><tr><td><code>raw模块</code></td><td>用来执行低版本的linux命令，可以不需要python来执行命令，甚至支持windows命令，带来的问题是很多很特性是不能用的</td></tr><tr><td>script模块</td><td>其原理是先将脚本，复制到远程主机，再在远程主机上执行，所以要指定脚本路径以及操作方法</td></tr></tbody></table><p>结论：要安全用command，要方便用shell，要操作写好的shell脚本或者其他脚本就用script、要是以上操作都跑不了的机器就用raw</p><h1 id="三、-完成复杂的ansible操作"><a href="#三、-完成复杂的ansible操作" class="headerlink" title="三、 完成复杂的ansible操作"></a>三、 完成复杂的ansible操作</h1><p>未完待续–</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Ansible插件扩展 <a href="https://blog.csdn.net/yongchaocsdn/article/details/79271870" target="_blank" rel="noopener">https://blog.csdn.net/yongchaocsdn/article/details/79271870</a></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>插件 <a href="https://github.com/ansible/ansible/tree/stable-2.4/lib/ansible/plugins" target="_blank" rel="noopener">https://github.com/ansible/ansible/tree/stable-2.4/lib/ansible/plugins</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置像我一样的hexo博客</title>
      <link href="/%E9%85%8D%E7%BD%AE%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E9%85%8D%E7%BD%AE%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：csdn和博客园虽然用的人多、技术氛围好，但是由于csdn的广告和灌水以及博客园的简陋页面让我决定搭建一套属于自己的博客，此处用到比较火的hexo搭建，而且免费就能获得自己的网站，如果不买域名的话完全够用了<br><a id="more"></a></p><ul><li><a href="#一搭建本地-hexo">一、搭建本地 hexo</a><ul><li><a href="#11-安装nodejs">1.1 安装nodejs</a></li><li><a href="#12-安装git">1.2 安装git</a></li><li><a href="#13-使用npm安装hexo">1.3 使用npm安装Hexo</a></li><li><a href="#14-创建本地服务">1.4 创建本地服务</a></li><li><a href="#15-主题配置">1.5 主题配置</a></li></ul></li><li><a href="#二-配置你的github">二、 配置你的github</a><ul><li><a href="#21-创建一个新项目">2.1 创建一个新项目</a></li><li><a href="#22-填写正确的项目名称">2.2 填写正确的项目名称</a></li><li><a href="#23-配置你的项目">2.3 配置你的项目</a></li></ul></li><li><a href="#三激动人心的博客">三、激动人心的博客</a><ul><li><a href="#31-修改hexo配置文件">3.1 修改hexo配置文件</a></li><li><a href="#32-部署成功">3.2 部署成功</a></li></ul></li><li><a href="#四个性化配置你的博客">四、个性化配置你的博客</a><ul><li><a href="#41-配置博客名博客描述等信息">4.1 配置博客名，博客描述等信息</a></li><li><a href="#42-添加头像">4.2 添加头像</a></li><li><a href="#43-添加日志列表">4.3 添加日志列表</a></li><li><a href="#42-其他">4.2 其他</a></li></ul></li><li><a href="#五配置你的hexo可以插入图片">五、配置你的hexo可以插入图片</a></li><li><a href="#附加速npm">附：加速npm</a></li><li><a href="#引用">引用</a></li></ul><hr><h1 id="一、搭建本地-hexo"><a href="#一、搭建本地-hexo" class="headerlink" title="一、搭建本地 hexo"></a>一、搭建本地 hexo</h1><h2 id="1-1-安装nodejs"><a href="#1-1-安装nodejs" class="headerlink" title="1.1 安装nodejs"></a>1.1 安装nodejs</h2><p>到nodejs官网下载安装 <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></p><h2 id="1-2-安装git"><a href="#1-2-安装git" class="headerlink" title="1.2 安装git"></a>1.2 安装git</h2><p>到git官网下载安装 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h2 id="1-3-使用npm安装Hexo"><a href="#1-3-使用npm安装Hexo" class="headerlink" title="1.3 使用npm安装Hexo"></a>1.3 使用npm安装Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>备注： 如果npm下载比较慢可以跳到 <a href="#附加速npm">附：加速npm</a></p><h2 id="1-4-创建本地服务"><a href="#1-4-创建本地服务" class="headerlink" title="1.4 创建本地服务"></a>1.4 创建本地服务</h2><p>创建一个文件夹，此处为blog，执行以下命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo i blog //init的缩写 blog是项目名</span><br><span class="line"><span class="built_in">cd</span> blog //切换到站点根目录</span><br><span class="line">hexo g //generetor的缩写</span><br><span class="line">hexo s //server的缩写</span><br></pre></td></tr></table></figure><p></p><p><img src="/配置像我一样的hexo博客/20180812012524.png" alt="本地hexo"><br>访问本地服务<code>localhost:4000</code>证明成功,为什么和我的不一样，因为我修改了hexo的主题配置可以跳到 <a href="#四个性化配置你的博客">四、个性化配置你的博客</a><br><img src="/配置像我一样的hexo博客/20180812012807.png" alt="本地hexo"><br>有页面出来证明你的配置已经成功了，原始的主题不是很喜欢，我这里也使用了最火的nexT主题</p><h2 id="1-5-主题配置"><a href="#1-5-主题配置" class="headerlink" title="1.5 主题配置"></a>1.5 主题配置</h2><p>在站点根目录输入<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p></p><p>完成后，打开根目录下的_config.yml， 找到 theme 字段，并将其值更改为 next<br><img src="/配置像我一样的hexo博客/20180812013802.png" alt="本地hexo"><br>next有三种主题，我选择的是双栏 Scheme，找到 <code>站点根目录/themes/next/_congig.yml</code> 文件，再找到<code>schme</code>字段，将其值改为<code>Pisces</code>,其他两种可以参考<a href="#引用">引用</a>里所写的<br><img src="/配置像我一样的hexo博客/20180812014827.png" alt="next主题"></p><p>使配置生效<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  //清除缓存</span><br><span class="line">hexo g  //重新生成代码</span><br><span class="line">hexo s  //部署到本地</span><br></pre></td></tr></table></figure><p></p><p>这样你的会有一套和我一样主题的博客了，如果你不喜欢这套主题，或者想自己来开发一套定制自己的主题参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a>,下面让我们把他推到github上，变成独一无二的网站</p><h1 id="二、-配置你的github"><a href="#二、-配置你的github" class="headerlink" title="二、 配置你的github"></a>二、 配置你的github</h1><h2 id="2-1-创建一个新项目"><a href="#2-1-创建一个新项目" class="headerlink" title="2.1 创建一个新项目"></a>2.1 创建一个新项目</h2><p>如果没有注册github帐号到&gt;<a href="https://github.com/" target="_blank" rel="noopener">官网注册</a><br>点此创建项目（如果你不是程序员建议勾选上图中Initalize this repository with a README选项）：<br><img src="/配置像我一样的hexo博客/20180812020821.png" alt="next主题"></p><h2 id="2-2-填写正确的项目名称"><a href="#2-2-填写正确的项目名称" class="headerlink" title="2.2 填写正确的项目名称"></a>2.2 填写正确的项目名称</h2><p>项目名可以为<code>任意英文.github.io</code>，public设置为公开项目,点击绿色创建按钮</p><p><img src="/配置像我一样的hexo博客/20180812021131.png" alt="next主题"></p><h2 id="2-3-配置你的项目"><a href="#2-3-配置你的项目" class="headerlink" title="2.3 配置你的项目"></a>2.3 配置你的项目</h2><p>在项目里创建一个readme.md即可，这下可以在页面上访问到这个免费的网站了<br>我的网站 <a href="https://pzqu.github.io/" target="_blank" rel="noopener">https://pzqu.github.io/</a></p><h1 id="三、激动人心的博客"><a href="#三、激动人心的博客" class="headerlink" title="三、激动人心的博客"></a>三、激动人心的博客</h1><h2 id="3-1-修改hexo配置文件"><a href="#3-1-修改hexo配置文件" class="headerlink" title="3.1 修改hexo配置文件"></a>3.1 修改hexo配置文件</h2><p>修改根目录的配置文件<code>_config.yml</code>，以下部分如果没有需要手动创建，建议直接拷贝我的，repo为自己刚刚创建的那个项目的git链接（注意冒号与值之间必须有空格）<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/pzqu/pzqu.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p></p><h2 id="3-2-部署成功"><a href="#3-2-部署成功" class="headerlink" title="3.2 部署成功"></a>3.2 部署成功</h2><p>直接执行一套命令,再刷新刚刚的域名即可<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d  //  部署的命令,会生成代码并推送到github上去</span><br></pre></td></tr></table></figure><p></p><h1 id="四、个性化配置你的博客"><a href="#四、个性化配置你的博客" class="headerlink" title="四、个性化配置你的博客"></a>四、个性化配置你的博客</h1><h2 id="4-1-配置博客名，博客描述等信息"><a href="#4-1-配置博客名，博客描述等信息" class="headerlink" title="4.1 配置博客名，博客描述等信息"></a>4.1 配置博客名，博客描述等信息</h2><p>参考官方网站 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration.html</a></p><h2 id="4-2-添加头像"><a href="#4-2-添加头像" class="headerlink" title="4.2 添加头像"></a>4.2 添加头像</h2><p>在主题配置文件里修改<br><code>avatar: images/avatar.gif</code></p><h2 id="4-3-添加日志列表"><a href="#4-3-添加日志列表" class="headerlink" title="4.3 添加日志列表"></a>4.3 添加日志列表</h2><h2 id="4-2-其他"><a href="#4-2-其他" class="headerlink" title="4.2 其他"></a>4.2 其他</h2><p>添加顶部加载条,修改主题配置文件，pace_theme有好几款，自己选一款<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pace: <span class="literal">true</span></span><br><span class="line">pace_theme: pace-theme-flash</span><br></pre></td></tr></table></figure><p></p><p>添加打赏功能，修改主题配置文件，图片可以上传到<code>themes\next\source\images</code><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /images/wxpay.jpg</span><br><span class="line">alipay: /images/alipay.jpg</span><br></pre></td></tr></table></figure><p></p><p>文章阅读量<br>参考 <a href="https://www.jianshu.com/p/702a7aec4d00" target="_blank" rel="noopener">https://www.jianshu.com/p/702a7aec4d00</a></p><p>评论系统<br><a href="http://www.zhaojun.im/hexo-valine/" target="_blank" rel="noopener">http://www.zhaojun.im/hexo-valine/</a></p><p>删除底部强力驱动、统计站点网上自己查<br>添加分享<br>添加评论</p><h1 id="五、配置你的hexo可以插入图片"><a href="#五、配置你的hexo可以插入图片" class="headerlink" title="五、配置你的hexo可以插入图片"></a>五、配置你的hexo可以插入图片</h1><ol><li>把主页配置文件 _config.yml 里的post_asset_folder:这个选项设置为true</li><li>在你的hexo目录下执行<code>npm install hexo-asset-image --save</code></li><li>等待一小段时间后，再运行<code>hexo n &quot;配置像我一样的hexo博客&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>配置像我一样的hexo博客.md</code>文件还有一个同名的文件夹</li><li>最后在<code>配置像我一样的hexo博客.md</code>中想引入图片时，先把图片复制到<code>配置像我一样的hexo博客</code>这个文件夹中，然后只需要在<code>配置像我一样的hexo博客.md</code>中按照markdown的格式引入图片,注意使用相对路径：<br><code>![你想输入的替代文字](配置像我一样的hexo博客/图片名.jpg)</code></li></ol><h1 id="附：加速npm"><a href="#附：加速npm" class="headerlink" title="附：加速npm"></a>附：加速npm</h1><p>配置npm镜像<code>npm config set registry https://registry.npm.taobao.org</code><br>查看npm镜像<code>npm config get registry</code></p><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！</a><br><a href="https://blog.csdn.net/quuqu/article/details/64121812" target="_blank" rel="noopener">npm太慢， 淘宝npm镜像使用方法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq集群的各种运维操作</title>
      <link href="/first-blog/"/>
      <url>/first-blog/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 18 2019 14:26:37 GMT+0800 (GMT+08:00) --><p>摘要：在rabbitmq集群操作或者搭建的时候，常常会因为对于集群的不熟练而导致各种异常错误，常见的有绑定了浮动ip没有绑定实体ip导致，页面上操作mq完全没有问题，但是一到程序操作就出现问题，我们一起来学习下，rabbitmq集群的正确操作</p><a id="more"></a><ul><li><a href="#一rabbitmq集群必要条件">一、rabbitmq集群必要条件</a><ul><li><a href="#11-绑定实体ip即ifconfig所能查询到的绑定到网卡上的ip以下是绑定方法">1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</a></li><li><a href="#12-配置域名映射到实体ip">1.2. 配置域名映射到实体ip</a></li></ul></li><li><a href="#二启动停止">二、启动停止</a><ul><li><a href="#21-停止">2.1 停止</a></li><li><a href="#22-启动">2.2 启动</a></li></ul></li><li><a href="#三重建集群">三、重建集群</a><ul><li><a href="#31-使用21方法停止所有机器">3.1 使用2.1方法停止所有机器</a></li><li><a href="#32-移除rabbitmq配置记录与存储文件">3.2 移除rabbitmq配置记录与存储文件</a></li><li><a href="#33-按22方法启动所有机器">3.3 按2.2方法启动所有机器</a></li><li><a href="#34-停止被加入集群节点app">3.4 停止被加入集群节点app</a></li><li><a href="#35-建立集群">3.5 建立集群</a></li><li><a href="#36-启动集群">3.6 启动集群</a></li><li><a href="#37-检查集群状态">3.7 检查集群状态</a></li><li><a href="#38-添加集群配置-见第四">3.8 添加集群配置 （见第四）</a></li></ul></li><li><a href="#四-添加集群配置">四 添加集群配置</a><ul><li><a href="#41-创建用户">4.1 创建用户</a></li><li><a href="#42-打开15672网页管理端访问mq">4.2 打开15672网页管理端，访问mq</a></li><li><a href="#43-在底部导入json后缀的配置文件即可">4.3 在底部导入.json后缀的配置文件即可</a></li></ul></li></ul><hr><blockquote><p>以下操作都以三节点集群为例，机器名标记为机器A、机器B、机器C，如果为双节点忽略机器C，如果为各多节点则与机器C操作相同</p></blockquote><h1 id="一、rabbitmq集群必要条件"><a href="#一、rabbitmq集群必要条件" class="headerlink" title="一、rabbitmq集群必要条件"></a>一、rabbitmq集群必要条件</h1><h2 id="1-1-绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法"><a href="#1-1-绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip-以下是绑定方法" class="headerlink" title="1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法"></a>1.1. 绑定实体ip，即ifconfig所能查询到的绑定到网卡上的ip,以下是绑定方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑配置路径 /etc/rabbitmq/rabbitmq-env.conf</span></span><br><span class="line">NODE_IP_ADDRESS=172.16.136.133</span><br></pre></td></tr></table></figure><h2 id="1-2-配置域名映射到实体ip"><a href="#1-2-配置域名映射到实体ip" class="headerlink" title="1.2. 配置域名映射到实体ip"></a>1.2. 配置域名映射到实体ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#配置文件1所在路径 /etc/rabbitmq/rabbitmq.config (如果是集群，每台机器都需要修改这个绑定本机实体ip)</span><br><span class="line">#其中rabbit@master是创建集群时所配置的参数，@后面的参数为主机名，示例中为master</span><br><span class="line">[</span><br><span class="line">    &#123;rabbit, [</span><br><span class="line">    &#123;cluster_nodes, &#123;[&apos;rabbit@master&apos;], disc&#125;&#125;,</span><br><span class="line">    &#123;cluster_partition_handling, ignore&#125;,</span><br><span class="line">    &#123;default_user, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;default_pass, &lt;&lt;&quot;guest&quot;&gt;&gt;&#125;,</span><br><span class="line">    &#123;tcp_listen_options, [binary,</span><br><span class="line">        &#123;packet, raw&#125;,</span><br><span class="line">        &#123;reuseaddr, true&#125;,</span><br><span class="line">        &#123;backlog, 128&#125;,</span><br><span class="line">        &#123;nodelay, true&#125;,</span><br><span class="line">        &#123;exit_on_close, false&#125;,</span><br><span class="line">        &#123;keepalive, true&#125;]&#125;</span><br><span class="line">    ]&#125;,</span><br><span class="line">    &#123;kernel, [</span><br><span class="line">        &#123;inet_dist_listen_max, 44001&#125;,</span><br><span class="line">        &#123;inet_dist_listen_min, 44001&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#配置文件2 所在路径 /etc/hosts (如果是集群，每台机器都需要修改这个绑定本机实体ip，而且hosts文件的映射不得重复，如果重复linux系统为以最下面一条记录为准)</span><br><span class="line">172.16.136.133 master</span><br><span class="line">172.16.136.134 venus</span><br><span class="line">172.16.136.135 venus2</span><br></pre></td></tr></table></figure><h1 id="二、启动停止"><a href="#二、启动停止" class="headerlink" title="二、启动停止"></a>二、启动停止</h1><h2 id="2-1-停止"><a href="#2-1-停止" class="headerlink" title="2.1 停止"></a>2.1 停止</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器A</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br><span class="line"><span class="comment">#机器B</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">service rabbitmq-server stop</span><br><span class="line">epmd -<span class="built_in">kill</span></span><br></pre></td></tr></table></figure><h2 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器A</span></span><br><span class="line">service rabbitmq-server start</span><br><span class="line"><span class="comment">#机器B</span></span><br><span class="line">service rabbitmq-server start</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure><h1 id="三、重建集群"><a href="#三、重建集群" class="headerlink" title="三、重建集群"></a>三、重建集群</h1><blockquote><p>注1：此处的mq集群重建是比较快速和有效的方法，面向的是初次安装或者可以接受mq中所存有的数据丢失的情况下，必须先有mq的.json后缀的配置文件或者有把握写入集群中exchange、queue等配置。</p></blockquote><blockquote><p>注2:如果是运行中的mq出现问题，需要在保存数据和配置的情况下恢复集群时，请跳到<a href="/rabbitmq-restart-save-data">rabbitmq集群恢复</a></p></blockquote><h2 id="3-1-使用2-1方法停止所有机器"><a href="#3-1-使用2-1方法停止所有机器" class="headerlink" title="3.1 使用2.1方法停止所有机器"></a>3.1 使用2.1方法停止所有机器</h2><h2 id="3-2-移除rabbitmq配置记录与存储文件"><a href="#3-2-移除rabbitmq配置记录与存储文件" class="headerlink" title="3.2 移除rabbitmq配置记录与存储文件"></a>3.2 移除rabbitmq配置记录与存储文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位于 /var/lib/rabbitmq/mensia</span></span><br><span class="line">mv /var/lib/rabbitmq/mensia /var/lib/rabbitmq/mensia.bak</span><br></pre></td></tr></table></figure><h2 id="3-3-按2-2方法启动所有机器"><a href="#3-3-按2-2方法启动所有机器" class="headerlink" title="3.3 按2.2方法启动所有机器"></a>3.3 按2.2方法启动所有机器</h2><h2 id="3-4-停止被加入集群节点app"><a href="#3-4-停止被加入集群节点app" class="headerlink" title="3.4 停止被加入集群节点app"></a>3.4 停止被加入集群节点app</h2><blockquote><p>比如A、B、C三台机器，将B和C加入到A中去，需要执行以下命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="3-5-建立集群"><a href="#3-5-建立集群" class="headerlink" title="3.5 建立集群"></a>3.5 建立集群</h2><blockquote><p>注意此处master为唯一没有执行<code>rabbitmqctl stop_app</code>的机器<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@master</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="3-6-启动集群"><a href="#3-6-启动集群" class="headerlink" title="3.6 启动集群"></a>3.6 启动集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#机器B</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"><span class="comment">#机器C</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h2 id="3-7-检查集群状态"><a href="#3-7-检查集群状态" class="headerlink" title="3.7 检查集群状态"></a>3.7 检查集群状态</h2><p>在任意一台机器上执行<code>rabbitmqctl cluster_status</code>命令即可检查，输出包含集群中的节点与运行中的节点，兼以主机名标志</p><h2 id="3-8-添加集群配置-（见第四）"><a href="#3-8-添加集群配置-（见第四）" class="headerlink" title="3.8 添加集群配置 （见第四）"></a>3.8 添加集群配置 （见第四）</h2><h1 id="四-添加集群配置"><a href="#四-添加集群配置" class="headerlink" title="四 添加集群配置"></a>四 添加集群配置</h1><h2 id="4-1-创建用户"><a href="#4-1-创建用户" class="headerlink" title="4.1 创建用户"></a>4.1 创建用户</h2><blockquote><p>例子中创建了两个用户<br>添加用户<code>add_user</code>,设置角色<code>set_user_tags</code>,添加rabbitmq虚拟主机<code>add_vhost</code>，设置访问权限<code>set_permissions</code>,以下是详细用法<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建第一个用户</span></span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名 administrator</span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p /  用户名 <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line"><span class="comment"># 创建第二个用户</span></span><br><span class="line">/usr/sbin/rabbitmqctl add_user 用户名2 密码</span><br><span class="line">/usr/sbin/rabbitmqctl set_user_tags 用户名2 management </span><br><span class="line">/usr/sbin/rabbitmqctl add_vhost sip_ext </span><br><span class="line">/usr/sbin/rabbitmqctl set_permissions -p sip_ext 用户名2 <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br></pre></td></tr></table></figure><p></p></blockquote><pre><code>备注：RabbitMQ 虚拟主机，RabbitMQ 通过虚拟主机（vhost）来分发消息。拥有自己独立的权限控制，不同的vhost之间是隔离的，单独的。权限控制的基本单位：vhost。用户只能访问与之绑定的vhost。vhost是AMQP中唯一无法通过协议来创建的基元。只能通过rabbitmqctl工具来创建。 </code></pre><h2 id="4-2-打开15672网页管理端，访问mq"><a href="#4-2-打开15672网页管理端，访问mq" class="headerlink" title="4.2 打开15672网页管理端，访问mq"></a>4.2 打开15672网页管理端，访问mq</h2><p><code>/usr/sbin/rabbitmq-plugins enable rabbitmq_management</code><br>备注：如果发现命令执行完毕没有打开此服务，15672端口没有监听，则是由于没有重启mq导致的</p><h2 id="4-3-在底部导入-json后缀的配置文件即可"><a href="#4-3-在底部导入-json后缀的配置文件即可" class="headerlink" title="4.3 在底部导入.json后缀的配置文件即可"></a>4.3 在底部导入.json后缀的配置文件即可</h2><p><img src="/first-blog/rabbitmq.jpg" alt="rabbitmq更新配置"></p><p>如果覆盖了用户需要使用以下命令修改mq用户密码<br><code>/usr/sbin/rabbitmqctl change_password 用户名 密码</code></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq集群 </tag>
            
            <tag> rabbitmq教程 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
